*
   GIT.FILENAME = 'SERAPHIM'
   GIT.REPO = 'https://github.com/Krowemoh/TCL-Utilities.git'
*
* COMPILER DIRECTIVES
*
   $DEFINE DATABASE.UV
   $DEFINE PLATFORM.LINUX
*
   EQU TRUE TO 1
   EQU FALSE TO 0
*
   DIM REQUEST(12)
*
   EQU REQUEST.TYPE.ATTRIBUTE TO 1
   EQU REQUEST.VERSION.ATTRIBUTE TO 2
   EQU REQUEST.URL.ATTRIBUTE TO 3
   EQU REQUEST.SLUGS.ATTRIBUTE TO 4
   EQU REQUEST.QUERY.ATTRIBUTE TO 5
   EQU REQUEST.HEADERS.ATTRIBUTE TO 6
   EQU REQUEST.COOKIES.ATTRIBUTE TO 7
   EQU REQUEST.RAW.BODY.ATTRIBUTE TO 8
   EQU REQUEST.FORM.ATTRIBUTE TO 9
   EQU REQUEST.FILES.ATTRIBUTE TO 10
   EQU REQUEST.JSON.ATTRIBUTE TO 11
   EQU REQUEST.RAW.REQUEST.ATTRIBUTE TO 12
*
   MAT REQUEST = ''
*
   MIME.TYPE = ''
*
   DIM RESPONSE(4)
*
   EQU RESPONSE.STATUS.ATTRIBUTE TO 1
   EQU RESPONSE.HEADERS.ATTRIBUTE TO 2
   EQU RESPONSE.CONTENT.ATTRIBUTE TO 3
   EQU RESPONSE.CONTENT.TYPE.ATTRIBUTE TO 4
*
   MAT RESPONSE = ''
*
   @USER1 = 'SERAPHIM'
   @USER2 = 'SERAPHIM'
*
   OPEN '','CONTROL-FILE' TO CONTROL.FILE ELSE
      PRINT 'Unable to open file: CONTROL-FILE'
      STOP
   END
*
   OPEN '','BINARY-FILE' TO BINARY.FILE ELSE
      PRINT 'Unable to open file: BINARY-FILE'
      STOP
   END
*
   READ CONFIG FROM CONTROL.FILE,'SERAPHIM' THEN
      SERVER.PORT = CONFIG<1>
      STATIC.FOLDER = CONFIG<2>
   END ELSE
      PRINT 'Configuration not found: CONTROL-FILE SERAPHIM'
      STOP
   END
*
   GOSUB GET.ARGUMENTS
*
   PHANTOM.MODE = TRUE
*
   LOCATE('--NO-PHANTOM',ARGUMENTS;FLAG.POS) THEN
      PHANTOM.MODE = FALSE
      ARGUMENTS = DELETE(ARGUMENTS,FLAG.POS)
   END
*
   CR = CHAR(13)
   LF = CHAR(10)
*
   BODY.DELIMITER = CR:LF:CR:LF
   BODY.DELIMITER.LEN = LEN(BODY.DELIMITER)
*
   ALLOWED.METHODS = 'GET POST PUT PATCH DELETE HEAD OPTIONS'
   CONVERT ' ' TO @AM IN ALLOWED.METHODS
*
   HTTP.STATUSES = ''
*
   HTTP.STATUSES<1,-1> = 200
   HTTP.STATUSES<2,-1> = 'OK'
*
   HTTP.STATUSES<1,-1> = 204
   HTTP.STATUSES<2,-1> = 'No Content'
*
   HTTP.STATUSES<1,-1> = 301
   HTTP.STATUSES<2,-1> = 'Found'
*
   HTTP.STATUSES<1,-1> = 302
   HTTP.STATUSES<2,-1> = 'Moved Permanently'
*
   HTTP.STATUSES<1,-1> = 303
   HTTP.STATUSES<2,-1> = 'See Other'
*
   HTTP.STATUSES<1,-1> = 400
   HTTP.STATUSES<2,-1> = 'Bad Request'
*
   HTTP.STATUSES<1,-1> = 401
   HTTP.STATUSES<2,-1> = 'Unauthorized'
*
   HTTP.STATUSES<1,-1> = 404
   HTTP.STATUSES<2,-1> = 'Not Found'
*
   HTTP.STATUSES<1,-1> = 500
   HTTP.STATUSES<2,-1> = 'Internal Server Error'
*
   HTTP.STATUSES<1,-1> = 501
   HTTP.STATUSES<2,-1> = 'Not Implemented'
*
   OPEN '','MD' TO MD.FILE ELSE
      PRINT 'Unable to open file: MD'
      STOP
   END
*
   $IFDEF DATABASE.D3
      CLEARSELECT
      FLASH.CMD = 'SELECT DICT BP SERAPHIM C/FLASH'
      EXECUTE FLASH.CMD CAPTURING OUTPUT
      READNEXT FLASH.COMPILED ELSE FLASH.COMPILED = 0
*
      IF NOT(FLASH.COMPILED) THEN
         PRINT 'SERAPHIM is not flash compiled.'
         STOP
      END
   $ENDIF
*
* SOCKET INITIALIZATION
*
   $IFDEF DATABASE.D3
      CFUNCTION SOCKET.BUILTIN
*
      SOCKET = %SOCKET(2,1,6)
      IF SOCKET < 0 THEN
         CRT 'ERROR ' : SYSTEM(0) : ' - Socket failed.'
         STOP
      END
*
      CODE = %BIND(SOCKET,2,0,SERVER.PORT)
      IF CODE < 0 THEN
         CRT 'ERROR ' : SYSTEM(0) : ' - Bind failed.'
         %CLOSESOCKET(SOCKET)
         STOP
      END
*
      CODE = %LISTEN(SOCKET,1)
      IF CODE < 0 THEN
         CRT 'ERROR ' : SYSTEM(0) : ' - Listen failed.'
         %CLOSESOCKET(SOCKET)
         STOP
      END
   $ENDIF
*
   $IFDEF DATABASE.QM
      SOCKET = CREATE.SERVER.SOCKET('0.0.0.0',SERVER.PORT,0)
      CODE = STATUS()
      IF CODE THEN
         CRT 'ERROR ' : CODE : ' - CREATE.SERVER.SOCKET failed.'
         CLOSE.SOCKET SOCKET
         STOP
      END
   $ENDIF
*
   $IFDEF DATABASE.UV
      CODE = initServerSocket('0.0.0.0',SERVER.PORT,1,SOCKET)
      IF CODE # 0 THEN
         CRT 'ERROR ' : SYSTEM(0) : ' - initServerSocket failed.'
         CODE = closeSocket(SOCKET)
         STOP
      END
   $ENDIF
*
*
   CRT 'Listening on: 0.0.0.0:' : SERVER.PORT
*
   IF PHANTOM.MODE THEN
      PRINT 'Started in PHANTOM.'
*
   END ELSE
      PRINT 'Started in non-PHANTOM mode.'
   END
*
   CRT
*
   OPEN '','CONTROL-FILE' TO CONTROL.FILE ELSE
      PRINT 'Unable to open file: CONTROL-FILE - Press RETURN':
      INPUT ANYTHING
      STOP
   END
*
   DONE = FALSE
*
   CLIENT.ADDRESS = 0
   CLIENT.PORT = 0
*
   LOOP UNTIL DONE DO
*
      READ ROUTES FROM CONTROL.FILE,'ROUTES' ELSE ROUTES = ''
*
      $IFDEF DATABASE.D3
         FD = %ACCEPT(SOCKET,&CLIENT.ADDRESS,&CLIENT.PORT)
         IF FD < 0 THEN
            CRT 'ERROR ' : SYSTEM(0) : ' = Accept failed.'
            %CLOSESOCKET(SOCKET)
            STOP
         END
      $ENDIF
*
      $IFDEF DATABASE.QM
         FD = ACCEPT.SOCKET.CONNECTION(SOCKET,0)
         CODE = STATUS()
         IF CODE THEN
            CRT 'ERROR ' : CODE : ' = Accept failed.'
            CLOSE.SOCKET SOCKET
            STOP
         END
      $ENDIF
*
      $IFDEF DATABASE.UV
         CODE = acceptConnection(SOCKET,1,0,NULL,NULL,FD)
         IF CODE # 0 THEN
            CRT 'ERROR ' : SYSTEM(0) : ' = Accept failed.'
            CODE = closeSocket(SOCKET)
            STOP
         END
      $ENDIF
*
      GOSUB INITIALIZE.REQUEST
      MAT RESPONSE = ''
*
      GOSUB READ.REQUEST
      REQUEST(REQUEST.RAW.REQUEST.ATTRIBUTE) = RAW.REQUEST
*
      GOSUB GET.STATUS.LINE
      REQUEST(REQUEST.TYPE.ATTRIBUTE) = REQUEST.TYPE
      REQUEST(REQUEST.VERSION.ATTRIBUTE) = REQUEST.VERSION
      REQUEST(REQUEST.URL.ATTRIBUTE) = REQUEST.URL
      REQUEST(REQUEST.QUERY.ATTRIBUTE) = REQUEST.QUERY
*
      GOSUB GET.HEADERS
      REQUEST(REQUEST.HEADERS.ATTRIBUTE) = REQUEST.HEADERS
      REQUEST(REQUEST.COOKIES.ATTRIBUTE) = REQUEST.COOKIES
*
      IF REQUEST.TYPE = 'POST' THEN
         GOSUB GET.POST.DATA
         REQUEST(REQUEST.RAW.BODY.ATTRIBUTE) = REQUEST.RAW.BODY
         REQUEST(REQUEST.FORM.ATTRIBUTE) = REQUEST.FORM
         REQUEST(REQUEST.FILES.ATTRIBUTE) = REQUEST.FILES
         REQUEST(REQUEST.JSON.ATTRIBUTE) = REQUEST.JSON
      END
*
      T1 = TIME()
*
      BEGIN CASE
         CASE REQUEST.ERROR # ''
            PRINT REQUEST.ERROR
*
            RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 400
            RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = 'Bad request.'
            GOSUB SEND.HTTP.RESPONSE
*
         CASE REQUEST.TYPE = 'OPTIONS'
            RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 204
            RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = ''
            GOSUB SEND.HTTP.RESPONSE
*
         CASE REQUEST.URL = '/kill'
            DONE = TRUE
*
            RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 200
            RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = 'Killing server.'
            GOSUB SEND.HTTP.RESPONSE
*
         CASE REQUEST.URL = '/restart'
            DONE = TRUE
*
            RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 200
            RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = 'Restarting server.'
            GOSUB SEND.HTTP.RESPONSE
*
            $IFDEF DATABASE.D3
               %CLOSESOCKET(FD)
               %CLOSESOCKET(SOCKET)
            $ENDIF
*
            $IFDEF DATABASE.QM
               CLOSE.SOCKET FD
               CLOSE.SOCKET SOCKET
            $ENDIF
*
            $IFDEF DATABASE.UV
               CODE = closeSocket(FD)
               CODE = closeSocket(SOCKET)
            $ENDIF
*
            CHAIN 'SERAPHIM'
*
         CASE TRUE
            PROCEED = TRUE
*
            NUMBER.OF.ROUTES = DCOUNT(ROUTES<1>,@VM)
            PROCEED = FALSE
*
            FOR ROUTE.CTR = 1 TO NUMBER.OF.ROUTES UNTIL PROCEED = TRUE
               ROUTE = ROUTES<1,ROUTE.CTR>
*
               ROUTE.PATTERN = ''
               SLUG.PATTERN = "0X'{'0X'}'0X"
               SLUG.CTR = 0
*
               LOOP UNTIL NOT(ROUTE MATCHES SLUG.PATTERN) DO
                  ONE = MATCHFIELD(ROUTE,SLUG.PATTERN,1)
                  SLUG = MATCHFIELD(ROUTE,SLUG.PATTERN,3)
                  THREE = MATCHFIELD(ROUTE,SLUG.PATTERN,5)
*
                  ROUTE = "'" : ONE : "'0X'" : THREE : "'"
*
                  IF REQUEST.URL MATCHES ROUTE THEN
                     SLUG.CTR = SLUG.CTR + 2
*
                     REQUEST(REQUEST.SLUGS.ATTRIBUTE)<1,-1> = SLUG
*
                     SLUG.VALUE = MATCHFIELD(REQUEST.URL,ROUTE,SLUG.CTR)
                     REQUEST(REQUEST.SLUGS.ATTRIBUTE)<2,-1> = SLUG.VALUE
                  END
               REPEAT
*
               ROUTE.PATTERN = ROUTE
*
               IF REQUEST.URL MATCHES ROUTE.PATTERN THEN
                  PROCEED = TRUE
                  ROUTE.POS = ROUTE.CTR
               END ELSE
                  REQUEST(REQUEST.SLUGS.ATTRIBUTE)<1> = ''
                  REQUEST(REQUEST.SLUGS.ATTRIBUTE)<2> = ''
               END
            NEXT ROUTE.CTR
*
            IF NOT(PROCEED) THEN
               FILE.EXT = OCONV(REQUEST.URL[3],'MCL')
*
               BEGIN CASE
                  CASE FILE.EXT = 'css'
                     MIME.TYPE = 'text/css'
                  CASE FILE.EXT = 'jpg'
                     MIME.TYPE = 'image/jpeg'
                  CASE FILE.EXT = 'png'
                     MIME.TYPE = 'image/png'
                  CASE TRUE
                     MIME.TYPE = 'text/html'
               END CASE
*
               FILE.PATH = STATIC.FOLDER : REQUEST.URL
*
               READ BINARY.ITEM FROM BINARY.FILE,REQUEST.URL THEN
                  RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 200
                  FILE.CONTENT = BINARY.ITEM<10>
                  FILE.CONTENT = ICONV(FILE.CONTENT,'MX0C')
                  RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = FILE.CONTENT
                  RESPONSE(RESPONSE.CONTENT.TYPE.ATTRIBUTE) = MIME.TYPE
                  GOSUB SEND.HTTP.RESPONSE
*
               END ELSE
                  OPENSEQ FILE.PATH TO FLAT.FILE THEN
                     READBLK FILE.CONTENT FROM FLAT.FILE, 100000000 THEN
                        RELEASE FLAT.FILE
                        CLOSESEQ FLAT.FILE
*
                        RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 200
                        RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = FILE.CONTENT
                        RESPONSE(RESPONSE.CONTENT.TYPE.ATTRIBUTE) = MIME.TYPE
                        GOSUB SEND.HTTP.RESPONSE
                     END ELSE
                        RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 500
                        RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = 'Failed to read content.'
                        GOSUB SEND.HTTP.RESPONSE
                     END
*
                  END ELSE
                     RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 404
                     RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = 'Page not found.'
                     GOSUB SEND.HTTP.RESPONSE
                  END
               END
            END
*
            IF PROCEED THEN
               FUNC = TRIM(ROUTES<2,ROUTE.POS>)
*
               READ MD.ITEM FROM MD.FILE,FUNC ELSE
                  RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 500
                  RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = 'Subroutine "' : FUNC : '" was not cataloged.'
                  GOSUB SEND.HTTP.RESPONSE
                  PROCEED = FALSE
               END
            END
*
            IF PROCEED THEN
               $IFDEF DATABASE.D3
                  PROGRAM.FOLDER.NAME = TRIM(FIELD(MD.ITEM<4>,' ',1))
*
                  CLEARSELECT
                  FLASH.CMD = 'SELECT DICT ' : PROGRAM.FOLDER.NAME : ' ' : FUNC : ' C/FLASH'
                  EXECUTE FLASH.CMD
                  READNEXT FLASH.COMPILED ELSE FLASH.COMPILED = 0
*
                  IF NOT(FLASH.COMPILED) THEN
                     RESPONSE(RESPONSE.STATUS.ATTRIBUTE) = 500
                     RESPONSE(RESPONSE.CONTENT.ATTRIBUTE) = 'Subroutine "' : FUNC : '" was not flash compiled.'
                     GOSUB SEND.HTTP.RESPONSE
                     PROCEED = FALSE
                  END
               $ENDIF
            END
*
            IF PROCEED THEN
               IF PHANTOM.MODE THEN
                  $IFDEF DATABASE.D3
                     %CLOSESOCKET(SOCKET)
                  $ENDIF
*
                  $IFDEF DATABASE.QM
                     CLOSE.SOCKET SOCKET
                  $ENDIF
*
                  $IFDEF DATABASE.UV
                     CODE = closeSocket(SOCKET)
                  $ENDIF
*
                  EXECUTE 'PHANTOM SERAPHIM' CAPTURING RESULT
*
                  PHANTOM.STARTED = INDEX(OCONV(RESULT,'MCU'),'STARTED',1) > 0
*
                  IF PHANTOM.STARTED THEN
                     DONE = TRUE
                  END ELSE
                     DONE = FALSE
                  END
               END
*
               CALL @FUNC(MAT REQUEST,MAT RESPONSE)
               GOSUB SEND.HTTP.RESPONSE
            END
*
      END CASE
*
      T2 = TIME()
*
      TIME.TAKEN = T2 - T1
      GOSUB LOG.RESPONSE
*
      $IFDEF DATABASE.D3
         %CLOSESOCKET(FD)
      $ENDIF
*
      $IFDEF DATABASE.QM
         CLOSE.SOCKET FD
      $ENDIF
*
      $IFDEF DATABASE.UV
         CODE = closeSocket(FD)
      $ENDIF
   REPEAT
*
   $IFDEF DATABASE.D3
      %CLOSESOCKET(SOCKET)
   $ENDIF
*
   $IFDEF DATABASE.QM
      CLOSE.SOCKET SOCKET
   $ENDIF
*
   $IFDEF DATABASE.UV
      CODE = closeSocket(SOCKET)
   $ENDIF
*
   STOP
*
*********************  S U B R O U T I N E  *********************
*
INITIALIZE.REQUEST:NULL
*
   MAT REQUEST =''
*
   RAW.REQUEST = ''
*
   REQUEST.ERROR = ''
*
   REQUEST.TYPE = ''
   REQUEST.VERSION = ''
   REQUEST.URL = ''
   REQUEST.QUERY = ''
*
   REQUEST.HEADERS = ''
   REQUEST.COOKIES = ''
*
   REQUEST.RAW.BODY = ''
   REQUEST.FORM = ''
   REQUEST.FILES = ''
   REQUEST.JSON = ''
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
READ.REQUEST:NULL
*
   BUFFER.SIZE = 1000
*
   READ.DONE = FALSE
*
   LOOP UNTIL READ.DONE DO
      $IFDEF DATABASE.D3
         CHAR BUFFER[BUFFER.SIZE]
      $ENDIF
*
      $IFDEF DATABASE.QM
         BUFFER = SPACES(BUFFER.SIZE)
         CONVERT ' ' TO '' IN BUFFER
      $ENDIF
*
      $IFDEF DATABASE.UV
         BUFFER = SPACES(BUFFER.SIZE)
         CONVERT ' ' TO '' IN BUFFER
      $ENDIF
*
      $IFDEF DATABASE.D3
         READ.SIZE = %RECV(FD,BUFFER,BUFFER.SIZE,0)
      $ENDIF
*
      $IFDEF DATABASE.QM
         BUFFER = READ.SOCKET(FD,BUFFER.SIZE,1,0)
         READ.SIZE = LEN(BUFFER)
      $ENDIF
*
      $IFDEF DATABASE.UV
         CODE = readSocket(FD,BUFFER,BUFFER.SIZE,0,1,READ.SIZE)
      $ENDIF
*
      IF READ.SIZE < 0 THEN
         CRT 'Read Error: ' : SYSTEM(0)
         READ.DONE = TRUE
*
      END ELSE IF READ.SIZE < BUFFER.SIZE THEN
         RAW.REQUEST = RAW.REQUEST : BUFFER[1,BUFFER.SIZE]
         READ.DONE = TRUE
*
      END ELSE
         RAW.REQUEST = RAW.REQUEST : BUFFER
      END
   REPEAT
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GET.STATUS.LINE:NULL
*
   IF RAW.REQUEST = '' THEN
      REQUEST.ERROR = 'Invalid request - request is blank.'
      RETURN
   END
*
   STATUS.LINE = FIELD(RAW.REQUEST,CR:LF,1)
*
   REQUEST.TYPE = FIELD(STATUS.LINE,' ',1)
*
   LOCATE(REQUEST.TYPE,ALLOWED.METHODS;ANYPOS) ELSE
      REQUEST.ERROR = 'Invalid request type: ' : REQUEST.TYPE
      RETURN
   END
*
   REQUEST.VERSION = FIELD(STATUS.LINE,' ',3)
*
   REQUEST.URL = FIELD(STATUS.LINE,' ',2)
   REQUEST.QUERY = ''
*
   IF INDEX(REQUEST.URL,'?',1) THEN
      QUERY.PARAMS = FIELD(REQUEST.URL,'?',2)
      QUERY.LENGTH = LEN(QUERY.PARAMS)
*
      TOKEN = ''
      IN.NAME = TRUE
*
      FOR I = 1 TO QUERY.LENGTH
         LETTER = QUERY.PARAMS[I,1]
*
         IF IN.NAME AND LETTER = '=' THEN
            REQUEST.QUERY<1,-1> = TOKEN
            TOKEN = ''
            IN.NAME = FALSE
*
         END ELSE IF LETTER = '&' THEN
            REQUEST.QUERY<2,-1> = TOKEN
            TOKEN = ''
            IN.NAME = TRUE
*
         END ELSE
            TOKEN = TOKEN : LETTER
         END
      NEXT I
*
      IF TOKEN # '' THEN
         REQUEST.QUERY<2,-1> = TOKEN
      END
*
      REQUEST.URL = FIELD(REQUEST.URL,'?',1)
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GET.HEADERS:NULL
*
   START.POS = INDEX(RAW.REQUEST,CR:LF,1)
*
   IF REQUEST.TYPE = 'POST' THEN
      HEADERS = RAW.REQUEST[START.POS+2,INDEX(RAW.REQUEST,BODY.DELIMITER,1)-START.POS-2]
   END ELSE
      HEADERS = RAW.REQUEST[START.POS+2,LEN(RAW.REQUEST)-START.POS-2]
   END
*
   HEADERS.LENGTH = LEN(HEADERS)
*
   TOKEN = ''
   IN.NAME = TRUE
*
   FOR I = 1 TO HEADERS.LENGTH
      LETTER = HEADERS[I,1]
*
      IF IN.NAME AND LETTER = ':' THEN
         REQUEST.HEADERS<1,-1> = TRIM(TOKEN)
         TOKEN = ''
         IN.NAME = FALSE
*
      END ELSE IF LETTER = CR THEN
         IF HEADERS[I+1,1] = LF THEN
            I = I + 1
         END
*
         REQUEST.HEADERS<2,-1> = TRIM(TOKEN)
         TOKEN = ''
         IN.NAME = TRUE
*
      END ELSE
         TOKEN = TOKEN : LETTER
      END
   NEXT I
*
   IF TOKEN # '' THEN
      REQUEST.HEADERS<2,-1> = TRIM(TOKEN)
   END
*
   COOKIE.FOUND = TRUE
*
   LOCATE('Cookie',REQUEST.HEADERS<1>,1;ANYPOS) ELSE
      LOCATE('cookie',REQUEST.HEADERS<1>,1;ANYPOS) ELSE
         COOKIE.FOUND = FALSE
      END
   END
   
   IF COOKIE.FOUND THEN
      COOKIES = REQUEST.HEADERS<2,ANYPOS>
      CONVERT ';' TO @AM IN COOKIES
      NUMBER.OF.COOKIES = DCOUNT(COOKIES,@AM)
*
      FOR COOKIE.CTR = 1 TO NUMBER.OF.COOKIES
         COOKIE = COOKIES<COOKIE.CTR>
*
         CONVERT '=' TO @AM IN COOKIE
*
         REQUEST.COOKIES<1,-1> = TRIM(COOKIE<1>)
         REQUEST.COOKIES<2,-1> = TRIM(COOKIE<2>)
      NEXT COOKIE.CTR
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GET.POST.DATA:NULL
*
   LOCATE('Content-Type',REQUEST.HEADERS,1;ANYPOS) ELSE
      LOCATE('content-type',REQUEST.HEADERS,1;ANYPOS) ELSE
         REQUEST.ERROR = 'Cannot find Content-Type, make sure it is spelled correctly.'
         RETURN
      END
   END
*
   CONTENT.TYPE = REQUEST.HEADERS<2,ANYPOS>
*
   LOCATE('Content-Length',REQUEST.HEADERS,1;ANYPOS) ELSE
      REQUEST.ERROR = 'Cannot find Content-Length, make sure it is set correctly.'
      RETURN
   END
*
   CONTENT.LENGTH = REQUEST.HEADERS<2,ANYPOS>
*
   REQUEST.RAW.BODY = RAW.REQUEST[INDEX(RAW.REQUEST,BODY.DELIMITER,1)+BODY.DELIMITER.LEN,CONTENT.LENGTH]
*
   IF CONTENT.TYPE = 'application/x-www-form-urlencoded' THEN
      TOKEN = ''
*
      FOR I = 1 TO CONTENT.LENGTH
         LETTER = REQUEST.RAW.BODY[I,1]
*
         IF LETTER = '=' THEN
            REQUEST.FORM<1,-1> = TOKEN
            TOKEN = ''
*
         END ELSE IF LETTER = '&' THEN
            REQUEST.FORM<2,-1> = TOKEN
            TOKEN = ''
*
         END ELSE
            TOKEN = TOKEN : LETTER
         END
      NEXT I
*
      IF TOKEN # '' THEN
         REQUEST.FORM<2,-1> = TOKEN
      END
*
   END ELSE IF CONTENT.TYPE = 'application/json' THEN
      REQUEST.JSON = REQUEST.RAW.BODY
*
   END ELSE IF CONTENT.TYPE[1,19] = 'multipart/form-data' THEN
      BOUNDARY = TRIM(CONTENT.TYPE[INDEX(CONTENT.TYPE,'=',1)+1,9999])
*
* BOUNDARY IS PREPENDED WITH --
*
      BOUNDARY = '--' : BOUNDARY
*
* ESCAPE OUT CHARS SO WE CAN USE @AM, 255 BREAKS THIS IS THE SEGMENT MARK
*
      REQUEST.RAW.BODY = CHANGE(REQUEST.RAW.BODY,@AM,'<ESC>254<ESC>')
      REQUEST.RAW.BODY = CHANGE(REQUEST.RAW.BODY,CHAR(255),'<ESC>255<ESC>')
      REQUEST.RAW.BODY = CHANGE(REQUEST.RAW.BODY,BOUNDARY,@AM)
*
      NUMBER.OF.BINS = DCOUNT(REQUEST.RAW.BODY,@AM)
*
      FOR BIN.CTR = 1 TO NUMBER.OF.BINS
         IF BIN.CTR = 1 OR BIN.CTR = NUMBER.OF.BINS THEN
            CONTINUE
         END
*
         BIN.DATA = REQUEST.RAW.BODY<BIN.CTR>
*
* REMOVE TRAILING CR:LF
*
         BIN.DATA = BIN.DATA[1,LEN(BIN.DATA)-2]
*
* REMOVE LEADING CR:LF
*
         BIN.DATA = BIN.DATA[3,LEN(BIN.DATA)-2]
*
* FIND \r\n\r\n TO FIND DATA SECTION
*
         BIN.POS = INDEX(BIN.DATA,CR:LF:CR:LF,1)
*
* HEADER SECTION IS UP TO THE \r\n\r\n
*
         BIN.HEADER = BIN.DATA[1,BIN.POS]
*
* DATA SECTION IS EVERYTHING AFTERWARDS, SUBTRACT 3 TO LEAVE A \n AT THE END
*
         BIN.DATA = BIN.DATA[BIN.POS+4,LEN(BIN.DATA)-LEN(BIN.HEADER)-3]
*
* UNESCAPE CHAR(254) AND CHAR(255)
*
         BIN.DATA = CHANGE(BIN.DATA,'<ESC>254<ESC>',@AM)
         BIN.DATA = CHANGE(BIN.DATA,'<ESC>255<ESC>',CHAR(255))
*
* CONVERT THE BINARY DATA INTO HEX SO WE CAN PASS AROUND
*
         BIN.DATA = OCONV(BIN.DATA,'MX0C')
*
* GET THE NAME OF THE UPLOADED FILE
*
         PATTERN = \0X'filename="'0X'"'0X\
         BIN.NAME = MATCHFIELD(BIN.HEADER,PATTERN,3)
*
         REQUEST.FILES<1,-1> = BIN.NAME
         REQUEST.FILES<2,-1> = BIN.DATA
      NEXT BIN.CTR
*
   END ELSE
      REQUEST.ERROR = 'Unsupported content type: ' : CONTENT.TYPE
   END
   
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SEND.HTTP.RESPONSE:NULL
*
   CONTENT.TYPE = RESPONSE(RESPONSE.CONTENT.TYPE.ATTRIBUTE)
*
   IF CONTENT.TYPE = '' THEN
      CONTENT.TYPE = 'text/html'
   END
*
   RESPONSE.STATUS = RESPONSE(RESPONSE.STATUS.ATTRIBUTE)
*
   IF MIME.TYPE[1,5] = 'text/' THEN
      RESPONSE.BODY = CHANGE(RESPONSE(RESPONSE.CONTENT.ATTRIBUTE),@AM,CR:LF)
   END ELSE
      RESPONSE.BODY = RESPONSE(RESPONSE.CONTENT.ATTRIBUTE)
   END
*
   LOCATE(RESPONSE.STATUS,HTTP.STATUSES,1;POS) THEN
      STATUS.TEXT = HTTP.STATUSES<2,POS>
   END ELSE
      PRINT 'Invalid http status "' : RESPONSE.STATUS : '".'
      STATUS.TEXT = 'Invalid Status'
   END
*
   HEADERS = RESPONSE(RESPONSE.HEADERS.ATTRIBUTE)
*
   BUFFER = ''
   BUFFER<-1> = 'HTTP/1.1 ' : RESPONSE.STATUS : ' ' : STATUS.TEXT
   BUFFER<-1> = 'Date: ' : OCONV(DATE(),'D')
   BUFFER<-1> = 'Server: SERAPHIM'
   BUFFER<-1> = 'Access-Control-Allow-Origin: *'
   BUFFER<-1> = 'Access-Control-Allow-Methods: GET, POST, OPTIONS, DELETE, PUT'
   BUFFER<-1> = 'Access-Control-Allow-Headers: *'
*
   IF HEADERS THEN
      BUFFER<-1> = HEADERS
   END
*
   BUFFER<-1> = 'Content-Length: ' : LEN(RESPONSE.BODY)
   BUFFER<-1> = 'Content-Type: ' : CONTENT.TYPE
   BUFFER<-1> = 'Connection: Closed'
*
   BUFFER = CHANGE(BUFFER,@AM,CR:LF)
   BUFFER = BUFFER : CR:LF : CR:LF : RESPONSE.BODY
*
   BUFFER.LENGTH = LEN(BUFFER)
*
   $IFDEF DATABASE.D3
      CODE = %SEND(FD,BUFFER,BUFFER.LENGTH,0)
   $ENDIF
*
   $IFDEF DATABASE.QM
      WRITE.SIZE = WRITE.SOCKET(FD,BUFFER,0,0)
   $ENDIF
*
   $IFDEF DATABASE.UV
      CODE = writeSocket(FD,BUFFER,10000,1,WRITE.SIZE)
   $ENDIF
*
   MIME.TYPE = ''
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
LOG.RESPONSE:NULL
*
   PRINT '> [' : OCONV(DATE(),'D') : ' ' :
   PRINT OCONV(TIME(),'MTH') : '] ' :
   PRINT REQUEST.TYPE : ' ' :
   PRINT REQUEST.URL : ' ' :
   PRINT RESPONSE.STATUS : ' ' :
   PRINT TIME.TAKEN : 's '
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GET.ARGUMENTS:NULL
*
   COMMAND = SENTENCE()
*
   ARGUMENTS = ''
   TOKEN = ''
*
   FOR LETTER.CTR = 1 TO LEN(COMMAND)
      CHARACTER = COMMAND[LETTER.CTR,1]
      IF CHARACTER = ' ' THEN
         IF TOKEN # '' THEN ARGUMENTS<-1> = TOKEN
         TOKEN = ''
*
      END ELSE IF CHARACTER = '"' THEN
         IF TOKEN # '' THEN ARGUMENTS<-1> = TOKEN
         TOKEN = ''
*
         LOOP
            LETTER.CTR = LETTER.CTR + 1
            CHARACTER = COMMAND[LETTER.CTR,1]
         UNTIL CHARACTER = '"' OR LETTER.CTR > LEN(COMMAND) DO
            TOKEN = TOKEN : CHARACTER
         REPEAT
*
         IF TOKEN # '' THEN ARGUMENTS<-1> = TOKEN
         TOKEN = ''
*
      END ELSE
         TOKEN = TOKEN : CHARACTER
      END
   NEXT LETTER.CTR
*
   IF TOKEN # '' THEN ARGUMENTS<-1> = TOKEN
*
   RETURN
*
* END OF PROGRAM
*
   END
*
