*
   GIT.FILENAME = 'EVA'
   GIT.REPO = 'https://github.com/Krowemoh/eva.git'
*
* COMPILER DIRECTIVES
*
   $DEFINE DATABASE.UV
   $DEFINE PLATFORM.LINUX
*
   $IFDEF PLATFORM.LINUX
      $IFDEF DATABASE.UV
         EXECUTE 'SH -c "echo $TERM"' CAPTURING ORIGINAL.TERM
         EXECUTE 'SH -c "echo $TERMINAL_EMULATOR"' CAPTURING TERMINAL.EMULATOR
      $ENDIF
*
      $IFDEF DATABASE.D3
         EXECUTE '!echo $TERM' CAPTURING ORIGINAL.TERM
         EXECUTE '!echo $TERMINAL_EMULATOR' CAPTURING TERMINAL.EMULATOR
      $ENDIF
*
      $IFDEF DATABASE.QM
         EXECUTE '!echo $TERM' CAPTURING ORIGINAL.TERM
         EXECUTE '!echo $TERMINAL_EMULATOR' CAPTURING TERMINAL.EMULATOR
      $ENDIF
   $ENDIF
*
   $IFDEF PLATFORM.WINDOWS
      ORIGINAL.TERM = 'ansi'
      TERMINAL.EMULATOR = ''
   $ENDIF
*
   EXECUTE 'TERM xterm' CAPTURING RESULTS
*
* VERSION
*
   VERSION = '10'
*
   @USER1 = 'EVA'
   @USER2 = 'EVA'
*
   EQU TRUE TO 1
   EQU FALSE TO 0
*
* WINTEGRATE CODES:
*
   COM.START =  CHAR(27) : CHAR(1)
   EQU COM.END TO CHAR(13)
   EQU STX TO CHAR(2)
*
   WINTEGRATE.FLAG = FALSE
   DARK.MODE = FALSE
*
   TERM.WIDTH = 132
   TERM.HEIGHT = 66
*
   IF TERMINAL.EMULATOR<1> = 'putty' THEN
      DARK.MODE = TRUE
      GOSUB SETUP.PUTTY
*
   END ELSE
      GOSUB CHECK.WINTEGRATE
*
      IF WINTEGRATE.FLAG THEN
         GOSUB SETUP.WINTEGRATE
      END
*
   END
*
   EXECUTE 'TERM ' : TERM.WIDTH : ',' : TERM.HEIGHT
*
* INITIALIZE HELP
*
   HELP.LINES = ''
   GOSUB BUILD.HELP.LINES
*
* INITIALIZE KEYS
*
   EQU KEY.CTRL.A TO CHAR(1)
   EQU KEY.CTRL.C TO CHAR(3)
   EQU KEY.CTRL.F TO CHAR(6)
   EQU KEY.CTRL.Q TO CHAR(17)
   EQU KEY.CTRL.R TO CHAR(18)
   EQU KEY.CTRL.S TO CHAR(19)
   EQU KEY.CTRL.V TO CHAR(22)
   EQU KEY.CTRL.Z TO CHAR(26)
*
   EQU KEY.ESCAPE TO CHAR(27)
   EQU KEY.BACKSPACE TO CHAR(8)
   EQU KEY.TAB TO CHAR(9)
   EQU KEY.LINE.FEED TO CHAR(10)
   EQU KEY.CARRIAGE.RETURN TO CHAR(13)
   EQU KEY.SPACE TO CHAR(32)
   EQU KEY.DOUBLE.QUOTE TO CHAR(34)
   EQU KEY.SINGLE.QUOTE TO CHAR(39)
   EQU KEY.DELETE TO CHAR(127)
*
   EQU KEY.EXCLAIMATION.MARK TO CHAR(33)
*
   EQU ESCAPE.CODE TO CHAR(27)
*
* INITIALIZE ANSI 16 COLORS
*
   RESET.COLOR = ''
   BLACK = ''
   RED = ''
   GREEN = ''
   YELLOW = ''
   BLUE = ''
   MAGENTA = ''
   CYAN = ''
   WHITE = ''
   RAW.WHITE = ''
*
   BRIGHTBLACK = ''
   BRIGHTRED = ''
   BRIGHTGREEN = ''
   BRIGHTYELLOW = ''
   BRIGHTBLUE = ''
   BRIGHTMAGENTA = ''
   BRIGHTCYAN = ''
   BRIGHTWHITE = ''
*
   BACKGROUND.BLACK = ''
   BACKGROUND.RED = ''
   BACKGROUND.GREEN = ''
   BACKGROUND.YELLOW = ''
   BACKGROUND.BLUE = ''
   BACKGROUND.MAGENTA = ''
   BACKGROUND.CYAN = ''
   BACKGROUND.WHITE = ''
*
   BACKGROUND.BRIGHTBLACK = ''
   BACKGROUND.BRIGHTRED = ''
   BACKGROUND.BRIGHTGREEN = ''
   BACKGROUND.BRIGHTYELLOW = ''
   BACKGROUND.BRIGHTBLUE = ''
   BACKGROUND.BRIGHTMAGENTA = ''
   BACKGROUND.BRIGHTCYAN = ''
   BACKGROUND.BRIGHTWHITE = ''
*
   IF DARK.MODE THEN
      RESET.COLOR = ESCAPE.CODE : '[0m'
*
      BLACK = RESET.COLOR : ESCAPE.CODE : '[30m'
      RAW.BLACK = ESCAPE.CODE : '[30m'
      RED = RESET.COLOR : ESCAPE.CODE : '[31m'
      RAW.RED = ESCAPE.CODE : '[31m'
      GREEN = RESET.COLOR : ESCAPE.CODE : '[32m'
      YELLOW = RESET.COLOR : ESCAPE.CODE : '[33m'
      BLUE = RESET.COLOR : ESCAPE.CODE : '[34m'
      MAGENTA = RESET.COLOR : ESCAPE.CODE : '[35m'
      CYAN = RESET.COLOR : ESCAPE.CODE : '[36m'
      WHITE = RESET.COLOR : ESCAPE.CODE : '[37m'
      RAW.WHITE = ESCAPE.CODE : '[37m'
*
      BRIGHTBLACK = RESET.COLOR : ESCAPE.CODE : '[30;1m'
      BRIGHTRED = RESET.COLOR : ESCAPE.CODE : '[31;1m'
      BRIGHTGREEN = RESET.COLOR : ESCAPE.CODE : '[32;1m'
      BRIGHTYELLOW = RESET.COLOR : ESCAPE.CODE : '[33;1m'
      BRIGHTBLUE = RESET.COLOR : ESCAPE.CODE : '[34;1m'
      BRIGHTMAGENTA = RESET.COLOR : ESCAPE.CODE : '[35;1m'
      BRIGHTCYAN = RESET.COLOR : ESCAPE.CODE : '[36;1m'
      BRIGHTWHITE = RESET.COLOR : ESCAPE.CODE : '[37;1m'
*
      BACKGROUND.BLACK = RESET.COLOR : ESCAPE.CODE : '[40m'
      BACKGROUND.RED = RESET.COLOR : ESCAPE.CODE : '[41m'
      BACKGROUND.GREEN = RESET.COLOR : ESCAPE.CODE : '[42m'
      BACKGROUND.YELLOW = RESET.COLOR : ESCAPE.CODE : '[43m'
      BACKGROUND.BLUE = RESET.COLOR : ESCAPE.CODE : '[44m'
      BACKGROUND.MAGENTA = RESET.COLOR : ESCAPE.CODE : '[45m'
      BACKGROUND.CYAN = RESET.COLOR : ESCAPE.CODE : '[46m'
      BACKGROUND.WHITE = RESET.COLOR : ESCAPE.CODE : '[47m'
*
      BACKGROUND.BRIGHTBLACK = RESET.COLOR : ESCAPE.CODE : '[40;1m'
      BACKGROUND.BRIGHTRED = RESET.COLOR : ESCAPE.CODE : '[41;1m'
      BACKGROUND.BRIGHTGREEN = RESET.COLOR : ESCAPE.CODE : '[42;1m'
      BACKGROUND.BRIGHTYELLOW = RESET.COLOR : ESCAPE.CODE : '[43;1m'
      BACKGROUND.BRIGHTBLUE = RESET.COLOR : ESCAPE.CODE : '[44;1m'
      BACKGROUND.BRIGHTMAGENTA = RESET.COLOR : ESCAPE.CODE : '[45;1m'
      BACKGROUND.BRIGHTCYAN = RESET.COLOR : ESCAPE.CODE : '[46;1m'
      BACKGROUND.BRIGHTWHITE = RESET.COLOR : ESCAPE.CODE : '[47;1m'
   END
*
* INITIALIZE COLORSCHEME
*
   MESSAGE.COLOR = BRIGHTGREEN
   EDITOR.COLOR = BRIGHTWHITE
   HEADER.COLOR = BRIGHTGREEN
   FOREGROUND.COLOR = WHITE
*
   LINE.NUMBER.COLOR = BRIGHTBLACK
*
   COMMENT.COLOR = BRIGHTBLACK
   STMT.COLOR = GREEN
   FUNCTION.COLOR = MAGENTA
   OPERATOR.COLOR = YELLOW
   SPECIAL.COLOR = YELLOW
   NUMBER.COLOR = YELLOW
*
   STRING.COLOR = CYAN
*
* INITIALIZE SCREEN CLEARING
*
   CLEAR.SCREEN = @(-1)
   CLEAR.REST.OF.SCREEN = @(-3)
   CLEAR.REST.OF.LINE = @(-4)
   CLEAR.LINE = @(0) : CLEAR.REST.OF.LINE
*
   $IFDEF DATABASE.UV
      UP.ARROW = 'OA'
      DOWN.ARROW = 'OB'
      LEFT.ARROW = 'OD'
      RIGHT.ARROW = 'OC'
*
      PAGE.UP = '[5~'
      PAGE.DOWN = '[6~'
   $ENDIF
*
   $IFDEF DATABASE.QM
      UP.ARROW = '[A'
      DOWN.ARROW = '[B'
      LEFT.ARROW = '[D'
      RIGHT.ARROW = '[C'
*
      PAGE.UP = '[5~'
      PAGE.DOWN = '[6~'
   $ENDIF
*
   $IFDEF DATABASE.D3
      UP.ARROW = '[A'
      DOWN.ARROW = '[B'
      LEFT.ARROW = '[D'
      RIGHT.ARROW = '[C'
*
      PAGE.UP = '[5~'
      PAGE.DOWN = '[6~'
   $ENDIF
*
   F5 = '[16~'
   F6 = '[17~'
*
* INITIALIZE TERMINAL SIZE
*
   SCREEN.WIDTH = TERM.WIDTH
   SCREEN.HEIGHT = TERM.HEIGHT
*
   $IFDEF DATABASE.UV
      BOTTOM = @(0,SCREEN.HEIGHT)
   $ENDIF
*
   $IFDEF DATABASE.QM
      BOTTOM = @(0,SCREEN.HEIGHT-1)
   $ENDIF
*
   $IFDEF DATABASE.D3
      BOTTOM = @(0,SCREEN.HEIGHT)
   $ENDIF
*
   MARGIN.TOP = 1
   MARGIN.BOTTOM = 1
   MARGIN.LEFT = 3
   MARGIN.RIGHT = 1
*
   ORIGINAL.MARGIN.RIGHT = 1
*
* SET VOC
*
   $IFDEF DATABASE.UV
      VOC = 'VOC'
   $ENDIF
*
   $IFDEF DATABASE.QM
      VOC = 'VOC'
   $ENDIF
*
   $IFDEF DATABASE.D3
      VOC = 'MD'
   $ENDIF
*
   OPEN '',VOC TO VOC.FILE ELSE
      PRINT 'Failed to open: VOC'
      STOP
   END
*
* OPEN EVA-HISTORY-FILE
*
   EQU EVA.SEARCH.ATTRIBUTE TO 1
   EQU EVA.EDITOR.ATTRIBUTE TO 2
   EQU EVA.YANKED.ATTRIBUTE TO 3
*
   EVA.HISTORY.OPENED = TRUE
*
   OPEN '','EVA-HISTORY-FILE' TO EVA.HISTORY.FILE ELSE
      OPEN '',VOC TO VOC.FILE THEN
         EVA.ENTRY = ''
         $IFDEF PLATFORM.LINUX
            $IFDEF DATABASE.UV
               EVA.ENTRY<1> = 'F'
               EVA.ENTRY<2> = '/tmp/.eva/'
               EVA.ENTRY<3> = '/tmp/.eva/'
            $ENDIF
*
            $IFDEF DATABASE.QM
               EVA.ENTRY<1> = 'F'
               EVA.ENTRY<2> = '/tmp/.eva/'
               EVA.ENTRY<3> = '/tmp/.eva/'
            $ENDIF
*
            $IFDEF DATABASE.D3
               EVA.ENTRY<1> = 'Q'
               EVA.ENTRY<3> = 'UNIX:/tmp/.eva/'
            $ENDIF
         $ENDIF
         $IFDEF PLATFORM.WINDOWS
            $IFDEF DATABASE.UV
               EVA.ENTRY<1> = 'F'
               EVA.ENTRY<2> = 'DOS:C:\.eva\'
               EVA.ENTRY<3> = 'DOS:C:\.eva\'
            $ENDIF
*
            $IFDEF DATABASE.QM
               EVA.ENTRY<1> = 'F'
               EVA.ENTRY<2> = 'DOS:C:\.eva\'
               EVA.ENTRY<3> = 'DOS:C:\.eva\'
            $ENDIF
*
            $IFDEF DATABASE.D3
               EVA.ENTRY<1> = 'Q'
               EVA.ENTRY<3> = 'DOS:C:\.eva\'
            $ENDIF
         $ENDIF
*
         WRITE EVA.ENTRY ON VOC.FILE,'EVA-HISTORY-FILE'
*
         OPEN '','EVA-HISTORY-FILE' TO EVA.HISTORY.FILE ELSE
            $IFDEF PLATFORM.LINUX
               $IFDEF DATABASE.UV
                  EXECUTE 'SH -c "mkdir -p /tmp/.eva/"'
               $ENDIF
*
               $IFDEF DATABASE.QM
                  EXECUTE '!mkdir -p /tmp/.eva/'
               $ENDIF
*
               $IFDEF DATABASE.D3
                  EXECUTE '!mkdir -p /tmp/.eva/'
               $ENDIF
            $ENDIF
            $IFDEF PLATFORM.WINDOWS
               EXECUTE '! mkdir C:\.eva'
            $ENDIF
            OPEN '','EVA-HISTORY-FILE' TO EVA.HISTORY.FILE ELSE
               EVA.HISTORY.OPENED = FALSE
            END
         END
      END ELSE
         EVA.HISTORY.OPENED = FALSE
      END
   END
*
* INITALIZE USER INFORMATION
*
   $IFDEF DATABASE.UV
      USER.NAME = @ACCOUNT
      PORT.NUMBER = @USERNO
      ACCOUNT.NAME = @WHO
   $ENDIF
*
   $IFDEF DATABASE.QM
      USER.NAME = @USER
      PORT.NUMBER = @USERNO
      ACCOUNT.NAME = @WHO
   $ENDIF
*
   $IFDEF DATABASE.D3
      USER.NAME = @USER
      PORT.NUMBER = @USERNO
      ACCOUNT.NAME = @ACCOUNT
   $ENDIF
*
* INITALIZE EVA BY USER
*
   EVA.HISTORY.NAME = USER.NAME : '.eva_history'
*
   IF EVA.HISTORY.OPENED THEN
      READ EVA.HISTORY FROM EVA.HISTORY.FILE, EVA.HISTORY.NAME ELSE EVA.HISTORY = ''
*
      SEARCH.HISTORY = EVA.HISTORY<EVA.SEARCH.ATTRIBUTE>
      EDITOR.HISTORY = EVA.HISTORY<EVA.EDITOR.ATTRIBUTE>
      YANKED.LINES = EVA.HISTORY<EVA.YANKED.ATTRIBUTE>
      PASTE.NEWLINE = TRUE
*
   END ELSE
      SEARCH.HISTORY = ''
      EDITOR.HISTORY = ''
      YANKED.LINES = ''
      PASTE.NEWLINE = FALSE
   END
*
* READ IN COMMAND
*
   GOSUB GET.ARGUMENTS
*
   LOCATE('--NO-LOCK',ARGUMENTS;FLAG.POS) THEN
      OPEN.READONLY = TRUE
      ARGUMENTS = DELETE(ARGUMENTS,FLAG.POS)
   END ELSE
      OPEN.READONLY = FALSE
   END
*
   NUMBER.OF.ARGUMENTS = DCOUNT(ARGUMENTS,@AM)
*
   QUIT.ALL.FLAG = FALSE
   VIEW.NUMBERS = TRUE
*
   IS.DICTIONARY = FALSE
*
   IS.UNIVERSE.FILE = TRUE
   IS.OS.FILE = FALSE
   CREATE.NEW.OS.FILE = FALSE
*
* OPEN FILE AND GO TO MAIN:
*
   IF ARGUMENTS<2> = 'DICT' THEN
      FILENAME = ARGUMENTS<3>
*
      OPEN 'DICT',FILENAME TO FILE ELSE
         PRINT 'Unable to open dict file: ' : FILENAME
         STOP
      END
*
      IS.DICTIONARY = TRUE
*
   END ELSE
      FILENAME = TRIM(ARGUMENTS<2>)
      FILE.LINES = ''
*
      OPEN '',FILENAME TO FILE THEN
         IS.UNIVERSE.FILE = TRUE
         IS.OS.FILE = FALSE
*
      END ELSE
         $IFDEF DATABASE.D3
            PRINT 'Unable to open file: ' FILENAME
            STOP
         $ENDIF
*
         $IFDEF DATABASE.QM
            PRINT 'Unable to open file: ' FILENAME
            STOP
         $ENDIF
*
         $IFDEF DATABASE.UV
            $IFDEF PLATFORM.LINUX
               OPENSEQ FILENAME TO FLAT.FILE ELSE
                  EXECUTE 'SH -c "file ' : FILENAME  : '"' CAPTURING RESULTS
*
                  IS.DIRECTORY = FALSE
                  IF INDEX(RESULTS,': directory',1) THEN
                     IS.DIRECTORY = TRUE
                  END
*
                  IF IS.DIRECTORY THEN
                     PRINT 'Unable to open directory: ' : FILENAME
                     STOP
*
                  END ELSE IF FILENAME[1,1] = '/' THEN
                     CREATE.NEW.OS.FILE = TRUE
*
                  END ELSE
                     PRINT 'Unable to open file: ' : FILENAME
                     STOP
                  END
               END
*
               IS.OS.FILE = TRUE
               IS.UNIVERSE.FILE = FALSE
*
               IF CREATE.NEW.OS.FILE THEN
                  FILE.LINES = ''
*
               END ELSE
                  READBLK FILE.LINES FROM FLAT.FILE, 100000000 THEN
                     RELEASE FLAT.FILE
                     CLOSESEQ FLAT.FILE
                  END
                  LAST.CHAR = FILE.LINES[LEN(FILE.LINES),1]
                  IF LAST.CHAR = CHAR(10) THEN
                     FILE.LINES = FILE.LINES[1,LEN(FILE.LINES)-1]
                  END
                  FILE.LINES = CHANGE(FILE.LINES,CHAR(10),@AM)
               END
            $ENDIF
*
            $IFDEF PLATFORM.WINDOWS
               PRINT 'Unable to open file: ' FILENAME
               STOP
            $ENDIF
         $ENDIF
*
      END
   END
*
   IF NOT(IS.DICTIONARY) AND NUMBER.OF.ARGUMENTS > 2 THEN
      LIST.OF.FILES = ''
*
      FOR I = 3 TO NUMBER.OF.ARGUMENTS
         LIST.OF.FILES<-1> = ARGUMENTS<I>
      NEXT I
*
      $IFDEF DATABASE.UV
         SELECT LIST.OF.FILES
      $ENDIF
*
      $IFDEF DATABASE.QM
         SELECT LIST.OF.FILES
      $ENDIF
*
      $IFDEF DATABASE.D3
         SELECT LIST.OF.FILES TO ACTIVE.LIST
      $ENDIF
*
   END ELSE IF IS.DICTIONARY AND NUMBER.OF.ARGUMENTS > 3 THEN
      LIST.OF.FILES = ''
*
      FOR I = 4 TO NUMBER.OF.ARGUMENTS
         LIST.OF.FILES<-1> = ARGUMENTS<I>
      NEXT I
*
      $IFDEF DATABASE.UV
         SELECT LIST.OF.FILES
      $ENDIF
*
      $IFDEF DATABASE.QM
         SELECT LIST.OF.FILES
      $ENDIF
*
      $IFDEF DATABASE.D3
         SELECT LIST.OF.FILES TO ACTIVE.LIST
      $ENDIF
   END
*
   IF IS.UNIVERSE.FILE THEN
      LOOP
         $IFDEF DATABASE.UV
            READNEXT RECORD.ID ELSE RECORD.ID = ''
         $ENDIF
*
         $IFDEF DATABASE.QM
            READNEXT RECORD.ID ELSE RECORD.ID = ''
         $ENDIF
*
         $IFDEF DATABASE.D3
            READNEXT RECORD.ID FROM ACTIVE.LIST ELSE RECORD.ID = ''
         $ENDIF
      UNTIL RECORD.ID = '' DO
         IF RECORD.ID[1,1] = '"' AND RECORD.ID[LEN(RECORD.ID),1] = '"' THEN
            RECORD.ID = RECORD.ID[2,LEN(RECORD.ID)-2]
         END
*
         IF OPEN.READONLY THEN
            READ RAW.LINES FROM FILE,RECORD.ID ELSE
               PRINT 'Unabled to read file as read only.'
               RETURN
            END
*
         END ELSE
            READU RAW.LINES FROM FILE,RECORD.ID LOCKED
               PRINT 'Record is locked: ' : RECORD.ID : ' - View Only? (Y/n) ':
               INPUT ANYTHING
*
               IF ANYTHING # 'Y' THEN
                  EXIT
               END
*
               READ RAW.LINES FROM FILE,RECORD.ID ELSE
                  PRINT 'Unabled to read file as read only.'
                  RETURN
               END
*
               OPEN.READONLY = TRUE
*
            END ELSE RAW.LINES = ''
         END
*
         GOSUB MAIN
*
         RELEASE FILE,RECORD.ID
*
         IF QUIT.ALL.FLAG THEN
            EXIT
         END
      REPEAT
*
   END ELSE
      RAW.LINES = FILE.LINES
      GOSUB MAIN
   END
*
   EXECUTE 'TERM ' : ORIGINAL.TERM CAPTURING RESULTS
*
   IF WINTEGRATE.FLAG THEN
      WINT.KEY = 'Emulation'
      WINT.VALUE = ORIGINAL.WINT.TERM
      GOSUB SET.WINTEGRATE.VALUE
   END
*
   STOP
*
*********************  S U B R O U T I N E  *********************
*
GET.ARGUMENTS:NULL
*
   COMMAND = SENTENCE()
*
   ARGUMENTS = ''
   TOKEN = ''
*
   FOR LETTER.CTR = 1 TO LEN(COMMAND)
      CHARACTER = COMMAND[LETTER.CTR,1]
      IF CHARACTER = ' ' THEN
         IF TOKEN # '' THEN ARGUMENTS<-1> = TOKEN
         TOKEN = ''
*
      END ELSE IF CHARACTER = '"' THEN
         IF TOKEN # '' THEN ARGUMENTS<-1> = TOKEN
         TOKEN = ''
*
         LOOP
            LETTER.CTR = LETTER.CTR + 1
            CHARACTER = COMMAND[LETTER.CTR,1]
         UNTIL CHARACTER = '"' OR LETTER.CTR > LEN(COMMAND) DO
            TOKEN = TOKEN : CHARACTER
         REPEAT
*
         IF TOKEN # '' THEN ARGUMENTS<-1> = TOKEN
         TOKEN = ''
*
      END ELSE
         TOKEN = TOKEN : CHARACTER
      END
   NEXT LETTER.CTR
*
   IF TOKEN # '' THEN ARGUMENTS<-1> = TOKEN
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
MAIN:NULL
*
   SHOW.BLOCK = FALSE
   HIGHLIGHT.BLOCK = ''
*
   UP.CARET.MODE = FALSE
*
* INITIALIZE CHECKSUM
*
   $IFDEF DATABASE.UV
      CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
   $ENDIF
*
   $IFDEF DATABASE.QM
      CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
   $ENDIF
*
   $IFDEF DATABASE.D3
      CURRENT.CHECKSUM = OCONV(RAW.LINES,'u001e')
   $ENDIF
*
* UNDO INITIALIZATION
*
   EQU UNDO.SIZE TO 1000
*
   DIM UNDO.STACK(UNDO.SIZE)
   DIM REDO.STACK(UNDO.SIZE)
*
   MAT UNDO.STACK = ''
   MAT REDO.STACK = ''
*
   UNDO.PTR = 0
   REDO.PTR = 0
*
   IF IS.UNIVERSE.FILE THEN
      FULL.NAME = ACCOUNT.NAME : '_' : FILENAME : '_' : RECORD.ID
   END ELSE
      FULL.NAME = ACCOUNT.NAME : '_' : FILENAME
   END
*
   READ CHECKSUM.MATRIX FROM EVA.HISTORY.FILE,'CHECKSUM' ELSE CHECKSUM.MATRIX = ''
*
   UNDO.MATRIX = ''
   UNDO.FILE.NAME = FULL.NAME : '.eva_undo'
*
   LOCATE(FULL.NAME,CHECKSUM.MATRIX<1>,1;CHECKSUM.POS) THEN
      ORIGINAL.CHECKSUM = CHECKSUM.MATRIX<2,CHECKSUM.POS>
*
      IF CURRENT.CHECKSUM = ORIGINAL.CHECKSUM THEN
         READ UNDO.MATRIX FROM EVA.HISTORY.FILE,UNDO.FILE.NAME ELSE UNDO.MATRIX = ''
*
      END ELSE
         CHECKSUM.MATRIX = DELETE(CHECKSUM.MATRIX,1,CHECKSUM.POS)
         CHECKSUM.MATRIX = DELETE(CHECKSUM.MATRIX,2,CHECKSUM.POS)
*
         WRITE CHECKSUM.MATRIX ON EVA.HISTORY.FILE,'CHECKSUM'
         DELETE EVA.HISTORY.FILE,UNDO.FILE.NAME
      END
   END
*
   IF UNDO.MATRIX # '' THEN
      UNDO.PTR = DCOUNT(UNDO.MATRIX,@AM)
      FOR UNDO.CTR = 1 TO UNDO.PTR
         $IFDEF DATABASE.UV
            RAISED.RECORD = RAISE(UNDO.MATRIX<UNDO.CTR>)
         $ENDIF
         $IFDEF DATABASE.QM
            RAISED.RECORD = RAISE(UNDO.MATRIX<UNDO.CTR>)
         $ENDIF
         $IFDEF DATABASE.D3
            RAISED.RECORD = UNDO.MATRIX<UNDO.CTR>
            CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
         $ENDIF
         UNDO.STACK(UNDO.CTR) = RAISED.RECORD
      NEXT UNDO.CTR
   END
*
   SEARCH.LINE.NUMBERS = ''
   SEARCH.X.POSITIONS = ''
   SEARCH.POSITION = 0
   FORWARD.SEARCH = TRUE
   ORIGINAL.SEARCH.STRING = ''
*
   SEARCH.STRING = SEARCH.HISTORY<1,DCOUNT(SEARCH.HISTORY<1>,@VM)>
*
   PRINT @(0,0) : CLEAR.REST.OF.SCREEN
*
   QUIT.FLAG = FALSE
*
* INITIALIZE RIGHT WINDOW
*
   RIGHT.WINDOW.LINES = ''
   SHOW.RIGHT.WINDOW = FALSE
*
   ORIGINAL.RAW.LINES = RAW.LINES
*
   NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
   IF NUMBER.OF.RAW.LINES = 0 THEN NUMBER.OF.RAW.LINES = 1
*
   IF VIEW.NUMBERS = FALSE THEN
      MARGIN.LEFT = 0
*
   END ELSE IF NUMBER.OF.RAW.LINES < 10 THEN
      PADDING.LEFT = 'R#2 '
      MARGIN.LEFT = 2 + 1
*
   END ELSE
      PADDING.LEFT = 'R#' : LEN(NUMBER.OF.RAW.LINES) : ' '
      MARGIN.LEFT = LEN(NUMBER.OF.RAW.LINES) + 1
   END
*
   OPEN '','MD' TO MD.FILE ELSE
      PRINT 'Unable to open file: MD - Press RETURN'
      STOP
   END
*
* VIEWPOINT SIZE
*
   VIEW.WIDTH = SCREEN.WIDTH - MARGIN.LEFT - MARGIN.RIGHT
   VIEW.HEIGHT = SCREEN.HEIGHT - MARGIN.TOP - MARGIN.BOTTOM
*
   TAB.SIZE = 3
   ORIGINAL.X.POS = 0
   ERROR.MESSAGE = ''
*
   EDITOR.PROMPT = ':'
   SEARCH.PROMPT = '/'
*
   EDITOR.MARGIN.LEFT = LEN(EDITOR.PROMPT)
   SEARCH.MARGIN.LEFT = LEN(SEARCH.PROMPT)
*
   LINE.START = 1
   CURRENT.LINE = 1
   BLOCK.START = 1
   BLOCK.END = 1
*
* STACK INITIALIZATION
*
   INSIDE.VIEW.BUFFER = FALSE
*
   ORIGINAL.RAW.LINES.STACK = ''
   RAW.LINES.STACK = ''
   REAL.LINE.NUMBER.STACK = ''
   HISTORY.STACK = ''
   HISTORY.X.Y.STACK = ''
   HISTORY.POS.STACK = ''
   LINE.START.STACK = ''
   NEST.LEVEL = 0
*
   RETURN.STACK = ''
   RETURN.CTR = 0
*
   PAGE.HEIGHT = VIEW.HEIGHT
*
   GOSUB PUT.CURSOR.TOP.LEFT
*
* SET FILETYPE
*
   FILETYPE = ''
*
   READ ANYTHING FROM MD.FILE,FILENAME:'.O' THEN
      FILETYPE = 'BASIC'
   END
*
   IF FILETYPE = '' THEN
      IF IS.UNIVERSE.FILE THEN
         IF FILENAME[LEN(FILENAME)-1,2] = 'BP' OR FILENAME = 'MPROCLIB' OR FILENAME = 'WIN.PROGS' THEN
            FILETYPE = 'BASIC'
*
         END ELSE IF IS.DICTIONARY THEN
            FILETYPE = 'DICT'
            GOSUB TOGGLE.DICTIONARY
*
         END ELSE IF RAW.LINES<1> = 'PQ' THEN
            FILETYPE = 'PROC'
*
         END ELSE IF OCONV(RECORD.ID[LEN(RECORD.ID)-4,5],'MCU') = '.HTML' THEN
            TAB.SIZE = 4
            FILETYPE = 'HTML'
*
         END ELSE IF OCONV(RECORD.ID[LEN(RECORD.ID)-2,5],'MCU') = '.MD' THEN
            FILETYPE = 'MARKDOWN'
*
         END ELSE
            FILETYPE = 'DATA'
            GOSUB TOGGLE.DICTIONARY
         END
*
      END ELSE
         IF OCONV(FILENAME[LEN(FILENAME)-4,5],'MCU') = '.JSON' THEN
            FILETYPE = 'JSON'
*
         END ELSE IF OCONV(FILENAME[LEN(FILENAME)-4,5],'MCU') = '.HTML' THEN
            FILETYPE = 'HTML'
*
         END ELSE IF OCONV(FILENAME[LEN(FILENAME)-2,3],'MCU') = '.MD' THEN
            FILETYPE = 'MARKDOWN'
*
         END ELSE
            FILETYPE = 'TXT'
         END
      END
   END
*
   IF FILETYPE = 'MARKDOWN' THEN
      IF TERM.WIDTH > 80 THEN
         MARGIN.RIGHT = INT((TERM.WIDTH - 80) / 2)
         MARGIN.LEFT = MARGIN.RIGHT
         VIEW.WIDTH = SCREEN.WIDTH - MARGIN.LEFT - MARGIN.RIGHT
         VIEW.NUMBERS = FALSE
      END
   END
*
   ARCHIVE.FILENAME = 'ARCHIVE-' : FILENAME
   ARCHIVE.OPENED = FALSE
*
   OPEN '', ARCHIVE.FILENAME TO ARCHIVE.FILE THEN
      ARCHIVE.OPENED = TRUE
   END
*
* SETUP SYNTAX
*
   GOSUB SYNTAX.INIT
*
   GOSUB PUT.CURSOR.TOP.LEFT
*
   GOSUB CONVERT.RAW.LINES
   GOSUB DISPLAY.LINES
   GOSUB PUT.CURSOR.TOP.LEFT
*
   INITIAL.SEARCH = TRUE
   GOSUB PROCESS.SEARCH
*
   INPUT.AVAILABLE = FALSE
   PROCESS.CHAR = ''
*
   EDITOR.COMMAND.AVAILABLE = FALSE
   EDITOR.COMMAND = ''
*
   HISTORY = ''
   HISTORY.X.Y = ''
   HISTORY.POS = 1
*
* CC.LIST INIT
*
   CC.BREAK.CHARACTERS = '( ) , : + - ; * < > = [ ]' : ' "' : " '"
   CONVERT ' ' TO @AM IN CC.BREAK.CHARACTERS
   CC.BREAK.CHARACTERS = CC.BREAK.CHARACTERS : @AM : ' '
*
   MAX.SUGGESTIONS = 4
   CC.START.LINE = 1
   CC.LIST.OPEN = FALSE
   SNIPPETS = ''
   SNIPPET.HEADERS = ''
*
   IF FILETYPE = 'BASIC' THEN
      GOSUB ADD.DEFAULT.SNIPPETS
   END
*
   IF FILETYPE = 'MARKDOWN' THEN
      GOSUB ADD.MARKDOWN.SNIPPETS
   END
*
   PATH = '/home/usr/nivethan/.vim/UltiSnips/all.snippets'
   GOSUB ADD.SNIPPETS
*
   IF DCOUNT(RAW.LINES,@AM) < 3000 AND FILETYPE = 'BASIC' THEN
      GOSUB ADD.AUTO.COMPLETE
   END
*
   LOOP WHILE TRUE DO
      IF INPUT.AVAILABLE THEN
         CHR = PROCESS.CHAR
         INPUT.AVAILABLE = FALSE
      END ELSE
         $IFDEF DATABASE.UV
            CHR = KEYIN()
         $ENDIF
         $IFDEF DATABASE.QM
            CHR = KEYIN()
         $ENDIF
         $IFDEF DATABASE.D3
            INPUT CHR,0
         $ENDIF
      END
*
      ASCII.CODE = SEQ(CHR)
      GOSUB PRINT.CURRENT.LINE
*
      IF ASCII.CODE = SEQ(KEY.ESCAPE) THEN
         GOSUB PROCESS.ESCAPE.KEY
         GOSUB PROCESS.BASE.ESCAPE.KEY
*
      END ELSE IF ASCII.CODE = SEQ(KEY.BACKSPACE) OR ASCII.CODE = SEQ(KEY.DELETE) THEN
         IF X.POS > MARGIN.LEFT THEN
            ORIGINAL.X.POS = 0
            X.POS = X.POS - 1
            GOSUB DISPLAY.HEADER
            PRINT @(X.POS, Y.POS) :
         END
*
      END ELSE IF ASCII.CODE = SEQ(KEY.SPACE) THEN
         IF SHOW.BLOCK THEN
            SHOW.BLOCK = FALSE
            HIGHLIGHT.BLOCK = ''
*
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Cleared highlighting.' :
*
         END ELSE
            SHOW.BLOCK = TRUE
            HIGHLIGHT.BLOCK = X.POS
*
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Highlighting: ' : X.POS :
         END
*
         GOSUB DISPLAY.LINES
*
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) THEN
         LINE = TRIM(LINES<CURRENT.LINE>)
*
         FIRST.WORD = FIELD(LINE,' ',1)
         SECOND.WORD = FIELD(LINE,' ',2)
*
         IF FIRST.WORD = 'GOSUB' THEN
            GOSUB.NAME = SECOND.WORD : ':'
            FOUND.GOSUB = FALSE
*
            FOR REAL.LINE.NUMBER = 1 TO NUMBER.OF.RAW.LINES
               RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
               IF INDEX(RAW.LINE,GOSUB.NAME,1) THEN
                  FOUND.GOSUB = TRUE
*
                  RETURN.CTR = RETURN.CTR + 1
                  RETURN.STACK<RETURN.CTR> = LINE.NUMBERS<CURRENT.LINE>
*
                  GOTO.LINE = REAL.LINE.NUMBER
                  GOSUB GOTO.LINE.POSITION
*
                  X.POS = MARGIN.LEFT
                  PRINT @(X.POS,Y.POS) :
*
                  EXIT
               END
            NEXT REAL.LINE.NUMBER
*
            IF NOT(FOUND.GOSUB) THEN
               PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
               PRINT 'Failed to find gosub.' :
               PRINT @(X.POS,Y.POS) :
            END
*
         END ELSE IF FIRST.WORD = 'RETURN' THEN
            IF RETURN.CTR = 0 THEN
               GOSUB SCROLL.DOWN
*
            END ELSE
               GOTO.LINE = RETURN.STACK<RETURN.CTR> + 1
*
               RETURN.STACK<RETURN.CTR> = ''
               RETURN.CTR = RETURN.CTR - 1
*
               GOSUB GOTO.LINE.POSITION
               X.POS = MARGIN.LEFT
               PRINT @(X.POS,Y.POS) :
            END
*
         END ELSE
            GOSUB SCROLL.DOWN
         END
*
      END ELSE IF CHR = ':' THEN
         GOSUB PROCESS.EDITOR.COMMAND
*
      END ELSE IF CHR = 'h' THEN
         GOSUB PRINT.CURRENT.LINE
         GOSUB SCROLL.LEFT
         PRINT @(X.POS, Y.POS) :
*
      END ELSE IF CHR = 'l' THEN
         GOSUB PRINT.CURRENT.LINE
         GOSUB SCROLL.RIGHT
         PRINT @(X.POS, Y.POS) :
*
      END ELSE IF CHR = 'j' THEN
         GOSUB SCROLL.DOWN
*
      END ELSE IF CHR = 'k' THEN
         GOSUB SCROLL.UP
*
      END ELSE IF ASCII.CODE = SEQ(KEY.SINGLE.QUOTE) THEN
         REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         UNDO.OP = 'CHANGE'
         GOSUB PUSH.HISTORY
*
         GOSUB GET.INSERT.CHAR.POS
*
         START.POS = INSERT.CHAR.POSITION
         END.POS = INSERT.CHAR.POSITION
*
         BREAK.CHAR = ''
*
         FOR START.POS = INSERT.CHAR.POSITION TO 1 STEP -1
            RAW.CHAR = RAW.LINE[START.POS,1]
            IF RAW.CHAR = ' ' THEN
               BREAK.CHAR = ' '
               START.POS = START.POS + 1
               EXIT
            END ELSE IF RAW.CHAR = "'" THEN
               BREAK.CHAR = "'"
               EXIT
            END
         NEXT START.POS
*
         IF START.POS = 0 THEN
            START.POS = 1
         END
*
         FOR END.POS = INSERT.CHAR.POSITION+1 TO LEN(RAW.LINE)
            RAW.CHAR = RAW.LINE[END.POS,1]
            IF RAW.CHAR = BREAK.CHAR THEN
               EXIT
            END
         NEXT END.POS
*
         IF BREAK.CHAR = ' ' THEN
            RAW.LINE = RAW.LINE[1,START.POS-1] : "'" : RAW.LINE[START.POS,END.POS-START.POS] : "'" : RAW.LINE[END.POS,9999]
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
            X.POS = X.POS + 1
         END ELSE
            RAW.LINE = RAW.LINE[1,START.POS-1] : RAW.LINE[START.POS+1,END.POS-START.POS-1] : RAW.LINE[END.POS+1,9999]
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
            X.POS = X.POS - 1
         END
*
         GOSUB UPDATE.LINE
*
         GOSUB PRINT.CURRENT.LINE
*
         IF X.POS > SCREEN.WIDTH - MARGIN.RIGHT THEN
            X.POS = MARGIN.LEFT + 1
            Y.POS = Y.POS + 1
            CURRENT.LINE = CURRENT.LINE + 1
         END
*
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF ASCII.CODE = SEQ(KEY.DOUBLE.QUOTE) THEN
         REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         UNDO.OP = 'CHANGE'
         GOSUB PUSH.HISTORY
*
         GOSUB GET.INSERT.CHAR.POS
*
         START.POS = INSERT.CHAR.POSITION
         END.POS = INSERT.CHAR.POSITION
*
         BREAK.CHAR = ''
*
         FOR START.POS = INSERT.CHAR.POSITION TO 1 STEP -1
            RAW.CHAR = RAW.LINE[START.POS,1]
            IF RAW.CHAR = ' ' THEN
               BREAK.CHAR = ' '
               START.POS = START.POS + 1
               EXIT
            END ELSE IF RAW.CHAR = '"' THEN
               BREAK.CHAR = '"'
               EXIT
            END
         NEXT START.POS
*
         IF START.POS = 0 THEN
            START.POS = 1
         END
*
         FOR END.POS = INSERT.CHAR.POSITION+1 TO LEN(RAW.LINE)
            RAW.CHAR = RAW.LINE[END.POS,1]
            IF RAW.CHAR = BREAK.CHAR THEN
               EXIT
            END
         NEXT END.POS
*
         IF BREAK.CHAR = ' ' THEN
            RAW.LINE = RAW.LINE[1,START.POS-1] : '"' : RAW.LINE[START.POS,END.POS-START.POS] : '"' : RAW.LINE[END.POS,9999]
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
            X.POS = X.POS + 1
         END ELSE
            RAW.LINE = RAW.LINE[1,START.POS-1] : RAW.LINE[START.POS+1,END.POS-START.POS-1] : RAW.LINE[END.POS+1,9999]
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
            X.POS = X.POS - 1
         END
*
         GOSUB UPDATE.LINE
*
         GOSUB PRINT.CURRENT.LINE
*
         IF X.POS > SCREEN.WIDTH - MARGIN.RIGHT THEN
            X.POS = MARGIN.LEFT + 1
            Y.POS = Y.POS + 1
            CURRENT.LINE = CURRENT.LINE + 1
         END
*
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = 'c' THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         UNDO.OP = 'CHANGE'
         GOSUB PUSH.HISTORY
*
         IF FILETYPE = 'BASIC' THEN
            IF RAW.LINE[1,6] = '*TEMP ' THEN
               RAW.LINE = CHANGE(RAW.LINE,'*TEMP ','',1)
            END ELSE
               RAW.LINE = '*TEMP ' : RAW.LINE
            END
         END ELSE IF FILETYPE = 'PROC' THEN
            IF RAW.LINE[1,8] = 'C *TEMP ' THEN
               RAW.LINE = CHANGE(RAW.LINE,'C *TEMP ','',1)
            END ELSE
               RAW.LINE = 'C *TEMP ' : RAW.LINE
            END
         END
         
         RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
         GOSUB UPDATE.LINE
         GOSUB DISPLAY.LINES
*
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = 's' THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         INSERT.LINE = '*********************  S U B R O U T I N E  *********************'
         GOSUB PROCESS.INSERT.LINE
*
         INSERT.LINE = '*'
         GOSUB PROCESS.INSERT.LINE
*
         INSERT.LINE = ':NULL'
         GOSUB PROCESS.INSERT.LINE
*
         IF Y.POS > VIEW.HEIGHT THEN
            LINE.START = LINE.START + 1
            Y.POS = VIEW.HEIGHT
         END
*
         GOSUB DISPLAY.LINES
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = 'e' THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         IF FILETYPE = 'BASIC' THEN
            INSERT.LINE = '*'
*
         END ELSE IF FILETYPE = 'PROC' THEN
            INSERT.LINE = 'C'
         END
*
         GOSUB PROCESS.INSERT.LINE
*
         IF Y.POS > VIEW.HEIGHT THEN
            LINE.START = LINE.START + 1
            Y.POS = VIEW.HEIGHT
         END
*
         GOSUB DISPLAY.LINES
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = 'd' THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         GOSUB PROCESS.DELETE.LINE
*
      END ELSE IF CHR = 'o' THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         INSERT.LINE = ''
         GOSUB PROCESS.INSERT.LINE
*
         IF Y.POS > VIEW.HEIGHT THEN
            LINE.START = LINE.START + 1
            Y.POS = VIEW.HEIGHT
         END
*
         GOSUB DISPLAY.LINES
         PRINT @(X.POS,Y.POS) :
*
         PROCESS.CHAR = 'i'
         INPUT.AVAILABLE = TRUE
*
      END ELSE IF CHR = 'x' THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         GOSUB PROCESS.DELETE.CHARACTER
*
      END ELSE IF CHR = 'r' THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         GOSUB PROCESS.REPLACE.CHARACTER
*
      END ELSE IF CHR = 'u' OR ASCII.CODE = SEQ(KEY.CTRL.Z) THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         GOSUB UNDO.HISTORY
*
      END ELSE IF ASCII.CODE = SEQ(KEY.CTRL.R) THEN
         IF INSIDE.VIEW.BUFFER THEN CONTINUE
*
         GOSUB REDO.HISTORY
*
      END ELSE IF CHR = 'v' THEN
         V.DELETE = FALSE
*
         ORIGINAL.X.POS = X.POS
         START.COPY.POS = X.POS - MARGIN.LEFT
         HIGHLIGHTED.CHARS = 1
*
         LINE = LINES<CURRENT.LINE>
         LINE.LEN = LEN(LINE)
*
         LINE = LINE[1,START.COPY.POS] : BACKGROUND.CYAN : LINE[START.COPY.POS+1,HIGHLIGHTED.CHARS] : RESET.COLOR : LINE[START.COPY.POS+HIGHLIGHTED.CHARS+1,9999]
         PRINT @(MARGIN.LEFT,Y.POS) : LINE
         PRINT @(X.POS,Y.POS) :
*
         LOOP WHILE TRUE DO
            $IFDEF DATABASE.UV
               CHR = KEYIN()
            $ENDIF
            $IFDEF DATABASE.QM
               CHR = KEYIN()
            $ENDIF
            $IFDEF DATABASE.D3
               INPUT CHR,0
            $ENDIF
*
            ASCII.CODE = SEQ(CHR)
*
            IF ASCII.CODE = SEQ(KEY.ESCAPE) THEN
               GOSUB PROCESS.ESCAPE.KEY
*
               IF ESCAPE.SEQUENCE = LEFT.ARROW THEN
                  IF X.POS > ORIGINAL.X.POS THEN
                     X.POS = X.POS - 1
                     HIGHLIGHTED.CHARS = HIGHLIGHTED.CHARS - 1
                  END
               END ELSE IF ESCAPE.SEQUENCE = RIGHT.ARROW THEN
                  IF X.POS < LINE.LEN + MARGIN.LEFT - 1 THEN
                     X.POS = X.POS + 1
                     HIGHLIGHTED.CHARS = HIGHLIGHTED.CHARS + 1
                  END
               END
*
               GOSUB PRINT.CURRENT.LINE
*
               LINE = LINES<CURRENT.LINE>
               LINE = LINE[1,START.COPY.POS] : BACKGROUND.CYAN : LINE[START.COPY.POS+1,HIGHLIGHTED.CHARS] : RESET.COLOR : LINE[START.COPY.POS+HIGHLIGHTED.CHARS+1,9999]
               PRINT @(MARGIN.LEFT,Y.POS) : LINE
               PRINT @(X.POS,Y.POS) :
*
            END ELSE
               IF ASCII.CODE = SEQ('$') THEN
                  HIGHLIGHTED.CHARS = LINE.LEN - START.COPY.POS + 1
                  X.POS = LINE.LEN + MARGIN.LEFT
*
                  LINE = LINES<CURRENT.LINE>
                  LINE = LINE[1,START.COPY.POS] : BACKGROUND.CYAN : LINE[START.COPY.POS+1,HIGHLIGHTED.CHARS] : RESET.COLOR : LINE[START.COPY.POS+HIGHLIGHTED.CHARS+1,9999]
*
                  PRINT @(MARGIN.LEFT,Y.POS) : LINE
                  PRINT @(X.POS,Y.POS) :
*
               END ELSE IF ASCII.CODE = SEQ('d') THEN
                  V.DELETE = TRUE
                  EXIT
*
               END ELSE
                  EXIT
               END
            END
         REPEAT
*
         PASTE.NEWLINE = FALSE
         YANKED.LINES = LINES<CURRENT.LINE>[START.COPY.POS+1,HIGHLIGHTED.CHARS]
         IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
*
         IF V.DELETE THEN
            X.POS = ORIGINAL.X.POS
            FOR V.CTR = 1 TO HIGHLIGHTED.CHARS
               GOSUB PROCESS.DELETE.CHARACTER
            NEXT V.CTR
         END ELSE
            GOSUB PRINT.CURRENT.LINE
            PRINT @(X.POS,Y.POS) :
         END
*
         X.POS = ORIGINAL.X.POS
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = 'y' THEN
         PASTE.NEWLINE = TRUE
         REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
         YANKED.LINES = RAW.LINES<REAL.LINE.NUMBER>
         IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
         PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
         PRINT 'Copied line ' : CURRENT.LINE : '.' :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = 'p' THEN
         GOSUB PASTE.BLOCK
*
      END ELSE IF CHR = '/' OR ASCII.CODE = SEQ(KEY.CTRL.F) THEN
         GOSUB PROCESS.SEARCH.INPUT
         GOSUB PROCESS.SEARCH
*
         IF SEARCH.RESULTS.EXIST THEN
            FORWARD.SEARCH = TRUE
            GOSUB GOTO.SEARCH.RESULT
         END
*
      END ELSE IF ASCII.CODE = SEQ('n') THEN
         GOSUB PROCESS.SEARCH
*
         IF SEARCH.RESULTS.EXIST THEN
            FORWARD.SEARCH = TRUE
            GOSUB GOTO.SEARCH.RESULT
         END
*
      END ELSE IF ASCII.CODE = SEQ('N') THEN
         GOSUB PROCESS.SEARCH
*
         IF SEARCH.RESULTS.EXIST THEN
            FORWARD.SEARCH = FALSE
            GOSUB GOTO.SEARCH.RESULT
         END
*
      END ELSE IF CHR = '$' THEN
         LINE.LEN = LEN(LINES<CURRENT.LINE>)
         X.POS = MARGIN.LEFT + LINE.LEN - 1
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = '0' THEN
         X.POS = MARGIN.LEFT
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = '1' THEN
         BLOCK.START = LINE.NUMBERS<CURRENT.LINE>
         PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
         PRINT 'Block started from line ' : BLOCK.START : '.' :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = '2' THEN
         BLOCK.END = LINE.NUMBERS<CURRENT.LINE>
*
         IF BLOCK.END < BLOCK.START THEN
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Cannot copy from ' : BLOCK.START : ' to ' : BLOCK.END : '.' :
            PRINT @(X.POS,Y.POS) :
            CONTINUE
         END
*
         IF BLOCK.END > DCOUNT(RAW.LINES,@AM) THEN
            BLOCK.END = DCOUNT(RAW.LINES,@AM)
         END
*
         PASTE.NEWLINE = TRUE
         YANKED.LINES = ''
         FOR BLOCK.CTR = BLOCK.START TO BLOCK.END
            YANKED.LINES<1,-1> = RAW.LINES<BLOCK.CTR>
         NEXT BLOCK.CTR
         IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
*
         PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
         PRINT 'Copied ' : BLOCK.END - BLOCK.START : ' lines from ' : BLOCK.START : ' to ' : BLOCK.END : '.' :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF CHR = 'i' THEN
         GOSUB PROCESS.INSERT
*
      END ELSE IF CHR = 'G' THEN
         GOTO.LINE = DCOUNT(RAW.LINES,@AM)
         GOSUB GOTO.LINE.POSITION
*
         X.POS = MARGIN.LEFT
         PRINT @(X.POS,Y.POS) :
*
      END ELSE
         PRINT @(X.POS,Y.POS) :
      END
*
      IF QUIT.FLAG THEN
         EXIT
      END
   REPEAT
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SYNTAX.INIT:NULL
*
   IF FILETYPE = 'BASIC' THEN
      GOSUB SYNTAX.INIT.BASIC
*
   END ELSE IF FILETYPE = 'HTML' THEN
      GOSUB SYNTAX.INIT.HTML
*
   END ELSE IF FILETYPE = 'PROC' THEN
      GOSUB SYNTAX.INIT.PROC
*
   END ELSE IF FILETYPE = 'DATA' THEN
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SYNTAX.INIT.BASIC:NULL
*
   STATEMENTS = ''
   STATEMENTS = STATEMENTS : ' ' : '$DEFINE $IFDEF $ENDIF ABORT ACTIVATEKEY AUTHORIZATION AUXMAP'
   STATEMENTS = STATEMENTS : ' ' : 'BEGIN BREAK BSCAN'
   STATEMENTS = STATEMENTS : ' ' : 'CALL CALLING CAPTURING CASE CHAIN CLEAR CLEARDATA CLEARFILE CLEARPROMPTS CLEARSELECT CLOSE'
   STATEMENTS = STATEMENTS : ' ' : 'CLOSESEQ COMMIT COMMON CONTINUE CREATE CRT'
   STATEMENTS = STATEMENTS : ' ' : 'DATA DEACTIVATEKEY DEBUG DEFFUN DELETE DELETELIST DELETEU DIM DIMENSION DISABLEDEC DISPLAY DO'
   STATEMENTS = STATEMENTS : ' ' : 'EQU ECHO ELSE ENABLEDEC END ENTER EOF EQUATE ERRMSG ERROR EXECUTE EXIT'
   STATEMENTS = STATEMENTS : ' ' : 'FILELOCK FILEUNLOCK FIND FINDSTR FLUSH FOOTING FOR FORMLIST FROM FUNCTION'
   STATEMENTS = STATEMENTS : ' ' : 'GET GETLIST GETX GO GOSUB GOTO GROUPSTORE'
   STATEMENTS = STATEMENTS : ' ' : 'HEADING HUSH'
   STATEMENTS = STATEMENTS : ' ' : 'IF INCLUDE IN INPUT INPUTIF INPUTCLEAR INPUTDISP INPUTDP INPUTERR INPUTNULL INPUTTRAP INS ISOLATION'
   STATEMENTS = STATEMENTS : ' ' : 'KEYEDIT KEYEXIT KEYTRAP'
   STATEMENTS = STATEMENTS : ' ' : 'LET LEVEL LOCATE LOCK LOOP LOCKED'
   STATEMENTS = STATEMENTS : ' ' : 'MAT MATBUILD MATPARSE MATREAD MATREADL MATREADU MATWRITE MATWRITEU'
   STATEMENTS = STATEMENTS : ' ' : 'NAP NEXT NOBUF'
   STATEMENTS = STATEMENTS : ' ' : 'OFF ON OPEN OPENDEV OPENPATH OPENSEQ'
   STATEMENTS = STATEMENTS : ' ' : 'PAGE PASSLIST PERFORM PRECISION PRINT PRINTER PRINTERR PROCREAD PROCWRITE PROGRAM PROMPT '
   STATEMENTS = STATEMENTS : ' ' : 'RANDOMIZE READ READBLK READL READLIST READNEXT READSEQ READT READU READV READVL READVU RELEASE'
   STATEMENTS = STATEMENTS : ' ' : 'REPEAT RESET RETURN RETURNING REVREMOVE REWIND ROLLBACK'
   STATEMENTS = STATEMENTS : ' ' : 'SELECT SELECTE SELECTINDEX SELECTINFO SEND SET SETREM SLEEP SSELECT START STOP STEP SUBROUTINE'
   STATEMENTS = STATEMENTS : ' ' : 'TABSTOP THEN TIMEOUT TO TPRINT TRANSACTION TTYCTL TTYGET TTYSET'
   STATEMENTS = STATEMENTS : ' ' : 'UNLOCK UNTIL UPRINT'
   STATEMENTS = STATEMENTS : ' ' : 'WEOF WEOFSEQ WHILE WRITE WRITEBLK WRITELIST WRITESEQ WRITESEQF WRITET WRITEU WRITEV WRITEVU'
*
   CONVERT ' ' TO @AM IN STATEMENTS
*
   FUNCTIONS = ''
   FUNCTIONS = FUNCTIONS : ' ' : 'ABS ABSS ACOS ADDS ALPHA ANDS ASCII ASIN ASSIGNED ATAN'
   FUNCTIONS = FUNCTIONS : ' ' : 'BITAND BITNOT BITOR BITRESET BITSET BITTEST BITXOR BYTE BYTELEN BYTETYPE BYTEVAL'
   FUNCTIONS = FUNCTIONS : ' ' : 'CATS CHANGE CHAR CHARS CHECKSUM COL1 COL2 COMPARE CONVERT COS COSH COUNT COUNTS'
   FUNCTIONS = FUNCTIONS : ' ' : 'DATE DCOUNT DEL DIV DIVS DOWNCASE DQUOTE DTX'
   FUNCTIONS = FUNCTIONS : ' ' : 'EBCDIC EQS EREPLACE EXCHANGE EXP EXTRACT'
   FUNCTIONS = FUNCTIONS : ' ' : 'FADD FDIV FFIX FFLT FIELD FIELDS FIELDSTORE FILEINFO FIX FMT FMTDP FMTS FMTSDP FMUL FOLD FOLDDP FSUB'
   FUNCTIONS = FUNCTIONS : ' ' : 'GES GETLOCALE GETREM GROUP GTS'
   FUNCTIONS = FUNCTIONS : ' ' : 'ICONV ICONVS IFS ILPROMPT INDEX INDEXS INDICES INMAT INSERT INT ISNULL ISNULLS ITYPE'
   FUNCTIONS = FUNCTIONS : ' ' : 'KEYIN'
   FUNCTIONS = FUNCTIONS : ' ' : 'LEFT LEN LENDP LENS LENSDP LES LEVEL LN LOCALEINFO LOWER LTS'
   FUNCTIONS = FUNCTIONS : ' ' : 'MATCHFIELD MAXIMUM MINIMUM MOD MODS MULS'
   FUNCTIONS = FUNCTIONS : ' ' : 'NEG NEGS NES NOT NOTS NUM NUMS NOW'
   FUNCTIONS = FUNCTIONS : ' ' : 'OCONV OCONVS ORS'
   FUNCTIONS = FUNCTIONS : ' ' : 'PWR'
   FUNCTIONS = FUNCTIONS : ' ' : 'QUOTE'
   FUNCTIONS = FUNCTIONS : ' ' : 'RAISE REAL RECORDLOCKED RECORDLOCKL RECORDLOCKU REMOVE REPLACE REUSE REM'
   FUNCTIONS = FUNCTIONS : ' ' : 'RIGHT RND RPC.CALL RPC.CONNECT RPC.DISCONNECT'
   FUNCTIONS = FUNCTIONS : ' ' : 'SADD SCMP SDIV SEEK SENTENCE SEQ SEQS SETLOCALE SIN SINH SMUL SOUNDEX SPACE SPACES SPLICE SQRT'
   FUNCTIONS = FUNCTIONS : ' ' : 'SQUOTE SSUB START STR STRS SUBR SUBS SUBSTRINGS SUM SUMMATION SYSTEM'
   FUNCTIONS = FUNCTIONS : ' ' : 'TAN TANH TERMINFO TIME TIMEDATE TPARM TRANS TRIM TRIMB TRIMBS TRIMF TRIMFS TRIMS'
   FUNCTIONS = FUNCTIONS : ' ' : 'UNASSIGNED UNICHAR UNICHARS UNISEQ UNISEQS UPCASE'
   FUNCTIONS = FUNCTIONS : ' ' : 'XLATE XTD'
   FUNCTIONS = FUNCTIONS : ' ' : 'amInitialize amReceiveMsg amReceiveRequest amSendMsg amSendRequest amSendResponse amTerminate'
*
   CONVERT ' ' TO @AM IN FUNCTIONS
*
   OPERATORS = ''
   OPERATORS = OPERATORS : ' ' : '+'
   OPERATORS = OPERATORS : ' ' : '*'
   OPERATORS = OPERATORS : ' ' : '/'
   OPERATORS = OPERATORS : ' ' : '-'
   OPERATORS = OPERATORS : ' ' : '='
   OPERATORS = OPERATORS : ' ' : ':'
   OPERATORS = OPERATORS : ' ' : '<>'
   OPERATORS = OPERATORS : ' ' : '#'
   OPERATORS = OPERATORS : ' ' : '<'
   OPERATORS = OPERATORS : ' ' : '>'
   OPERATORS = OPERATORS : ' ' : '>='
   OPERATORS = OPERATORS : ' ' : '<='
   OPERATORS = OPERATORS : ' ' : ':='
   OPERATORS = OPERATORS : ' ' : '+='
   OPERATORS = OPERATORS : ' ' : 'AND OR NULL'
*
   CONVERT ' ' TO @AM IN OPERATORS
*
   SPECIALS = ''
   SPECIALS = SPECIALS : ' ' : '@DATE'
   SPECIALS = SPECIALS : ' ' : '@FM'
   SPECIALS = SPECIALS : ' ' : '@VM'
   SPECIALS = SPECIALS : ' ' : '@SVM'
   SPECIALS = SPECIALS : ' ' : '@TM'
   SPECIALS = SPECIALS : ' ' : '@STM'
   SPECIALS = SPECIALS : ' ' : '@AM'
   SPECIALS = SPECIALS : ' ' : '@NULL'
   SPECIALS = SPECIALS : ' ' : '@COMMAND'
   SPECIALS = SPECIALS : ' ' : '@ID'
   SPECIALS = SPECIALS : ' ' : '@OPTION'
   SPECIALS = SPECIALS : ' ' : '@RECORD'
   SPECIALS = SPECIALS : ' ' : '@SENTENCE'
   SPECIALS = SPECIALS : ' ' : '@SELECTED'
   SPECIALS = SPECIALS : ' ' : '@TTY'
   SPECIALS = SPECIALS : ' ' : '@USER1'
   SPECIALS = SPECIALS : ' ' : '@USER2'
   SPECIALS = SPECIALS : ' ' : '@PATH'
   SPECIALS = SPECIALS : ' ' : '@WHO'
   SPECIALS = SPECIALS : ' ' : '@ACCOUNT'
   SPECIALS = SPECIALS : ' ' : '@USER'
   SPECIALS = SPECIALS : ' ' : '@USERNO'
*
   CONVERT ' ' TO @AM IN SPECIALS
*
   BREAK.CHARACTERS = '( ) , : + - / ; * < > #'
   CONVERT ' ' TO @AM IN BREAK.CHARACTERS
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SYNTAX.INIT.HTML:NULL
*
   STATEMENTS = 'a abbr acronym address applet area article aside audio b base basefont bdi bdo bgsound big blink blockquote body br button canvas caption center cite code col colgroup content data datalist dd decorator del details dfn dir div dl dt element em embed fieldset figcaption figure font footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins isindex kbd keygen label legend li link listing main map mark marquee menu menuitem meta meter nav nobr noframes noscript object ol optgroup option output p param plaintext pre progress q rp rt ruby s samp script section select shadow small source spacer span strike strong sub summary sup table tbody td template textarea tfoot th thead time title tr track tt u ul var video wbr xmp'
   BASIC.STATEMENTS = 'FOR NEXT READ FROM ELSE OPEN TO PRINT IF THEN END ELSE LOOP UNTIL DO REPEAT INCLUDE CALL OF'
   STATEMENTS = STATEMENTS : ' ' : BASIC.STATEMENTS
   CONVERT ' ' TO @AM IN STATEMENTS
*
   FUNCTIONS = 'function {{ }}'
   BASIC.FUNCTIONS = 'DCOUNT LEN OCONV DATE'
   FUNCTIONS = FUNCTIONS : ' ' : BASIC.FUNCTIONS
   CONVERT ' ' TO @AM IN FUNCTIONS
*
   OPERATORS = '< = > >= <= # : AND OR NOT'
   CONVERT ' ' TO @AM IN OPERATORS
*
   SPECIALS = 'class href style placeholder value rel charset name lang alt title src action method for type'
   BASIC.SPECIALS = '@AM @VM @SVM @TM @STM NULL'
   SPECIALS = SPECIALS : ' ' : BASIC.SPECIALS
   CONVERT ' ' TO @AM IN SPECIALS
*
   BREAK.CHARACTERS = '= ( ) , : + - / ; * < > #'
   CONVERT ' ' TO @AM IN BREAK.CHARACTERS
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SYNTAX.INIT.PROC:NULL
*
   STATEMENTS = 'IF GO'
   CONVERT ' ' TO @AM IN STATEMENTS
*
   FUNCTIONS = ''
   CONVERT ' ' TO @AM IN FUNCTIONS
*
   OPERATORS = '< = > >= <= #'
   CONVERT ' ' TO @AM IN OPERATORS
*
   SPECIALS = ''
   CONVERT ' ' TO @AM IN SPECIALS
*
   BREAK.CHARACTERS = '( ) , : + - / ; * < > #'
   CONVERT ' ' TO @AM IN BREAK.CHARACTERS
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PUSH.HISTORY:NULL
*
   IF NEST.LEVEL # 0 THEN
      RETURN
   END
*
   REDO.PTR = 0
   UNDO.PTR = UNDO.PTR + 1
*
   IF UNDO.PTR >= UNDO.SIZE THEN
      NEW.SIZE = UNDO.SIZE / 2
      UNDO.PTR = NEW.SIZE
*
      FOR UNDO.CTR = 1 TO NEW.SIZE
         UNDO.STACK(UNDO.CTR) = UNDO.STACK(UNDO.CTR+NEW.SIZE)
      NEXT UNDO.CTR
*
      FOR UNDO.CTR = NEW.SIZE TO UNDO.SIZE
         UNDO.STACK(UNDO.CTR) = ''
      NEXT UNDO.CTR
*
      MAT REDO.STACK = ''
   END
*
   IF UNDO.OP = 'CHANGE' THEN
      UNDO.STACK(UNDO.PTR) = ''
      UNDO.STACK(UNDO.PTR)<1> = UNDO.OP
      UNDO.STACK(UNDO.PTR)<2> = REAL.LINE.NUMBER
      UNDO.STACK(UNDO.PTR)<3> = RAW.LINE
      UNDO.STACK(UNDO.PTR)<4,1> = X.POS
      UNDO.STACK(UNDO.PTR)<4,2> = Y.POS
      UNDO.STACK(UNDO.PTR)<4,3> = CURRENT.LINE
      UNDO.STACK(UNDO.PTR)<4,4> = LINE.START
*
   END ELSE IF UNDO.OP = 'INSERT.LINE' THEN
      UNDO.STACK(UNDO.PTR) = ''
      UNDO.STACK(UNDO.PTR)<1> = UNDO.OP
      UNDO.STACK(UNDO.PTR)<2> = NEXT.LINE.NUMBER
      UNDO.STACK(UNDO.PTR)<3> = INSERT.LINE
      UNDO.STACK(UNDO.PTR)<4,1> = X.POS
      UNDO.STACK(UNDO.PTR)<4,2> = Y.POS
      UNDO.STACK(UNDO.PTR)<4,3> = CURRENT.LINE
      UNDO.STACK(UNDO.PTR)<4,4> = LINE.START
*
   END ELSE IF UNDO.OP = 'DELETE.LINE' THEN
      UNDO.STACK(UNDO.PTR) = ''
      UNDO.STACK(UNDO.PTR)<1> = UNDO.OP
      UNDO.STACK(UNDO.PTR)<2> = REAL.LINE.NUMBER
      UNDO.STACK(UNDO.PTR)<3> = RAW.LINE
      UNDO.STACK(UNDO.PTR)<4,1> = X.POS
      UNDO.STACK(UNDO.PTR)<4,2> = Y.POS
      UNDO.STACK(UNDO.PTR)<4,3> = CURRENT.LINE
      UNDO.STACK(UNDO.PTR)<4,4> = LINE.START
*
   END ELSE IF UNDO.OP = 'FORMAT.FILE' THEN
      UNDO.STACK(UNDO.PTR) = ''
      UNDO.STACK(UNDO.PTR)<1> = UNDO.OP
      UNDO.STACK(UNDO.PTR)<2> = REAL.LINE.NUMBER
*
      $IFDEF DATABASE.UV
         UNDO.STACK(UNDO.PTR)<3> = LOWER(RAW.LINES)
      $ENDIF
*
      $IFDEF DATABASE.QM
         UNDO.STACK(UNDO.PTR)<3> = LOWER(RAW.LINES)
      $ENDIF
*
      $IFDEF DATABASE.D3
         LOWERED.RECORD = RAW.LINES
         CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
         UNDO.STACK(UNDO.PTR)<3> = LOWERED.RECORD
      $ENDIF
*
      UNDO.STACK(UNDO.PTR)<4,1> = X.POS
      UNDO.STACK(UNDO.PTR)<4,2> = Y.POS
      UNDO.STACK(UNDO.PTR)<4,3> = CURRENT.LINE
      UNDO.STACK(UNDO.PTR)<4,4> = LINE.START
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
UNDO.HISTORY:NULL
*
   IF NEST.LEVEL # 0 THEN
      RETURN
   END
*
   IF UNDO.PTR <= 0 THEN
      PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
      PRINT 'Already at the earliest change.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   UNDO = UNDO.STACK(UNDO.PTR)
   UNDO.PTR = UNDO.PTR - 1
*
   IF UNDO<1> = 'CHANGE' THEN
      REAL.LINE.NUMBER = UNDO<2>
*
      REDO.PTR  = REDO.PTR + 1
      REDO.STACK(REDO.PTR) = ''
      REDO.STACK(REDO.PTR)<1> = 'CHANGE'
      REDO.STACK(REDO.PTR)<2> = REAL.LINE.NUMBER
      REDO.STACK(REDO.PTR)<3> = RAW.LINES<REAL.LINE.NUMBER>
      REDO.STACK(REDO.PTR)<4,1> = UNDO<4,1>
      REDO.STACK(REDO.PTR)<4,2> = UNDO<4,2>
      REDO.STACK(REDO.PTR)<4,3> = UNDO<4,3>
      REDO.STACK(REDO.PTR)<4,4> = UNDO<4,4>
*
      RAW.LINE = UNDO<3>
      X.POS = UNDO<4,1>
      Y.POS = UNDO<4,2>
      CURRENT.LINE = UNDO<4,3>
      LINE.START = UNDO<4,4>
*
      RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
   END ELSE IF UNDO<1> = 'INSERT.LINE' THEN
      REAL.LINE.NUMBER = UNDO<2>
*
      REDO.PTR  = REDO.PTR + 1
      REDO.STACK(REDO.PTR) = ''
      REDO.STACK(REDO.PTR)<1> = 'INSERT.LINE'
      REDO.STACK(REDO.PTR)<2> = REAL.LINE.NUMBER-1
      REDO.STACK(REDO.PTR)<3> = RAW.LINES<REAL.LINE.NUMBER>
      REDO.STACK(REDO.PTR)<4,1> = UNDO<4,1>
      REDO.STACK(REDO.PTR)<4,2> = UNDO<4,2>
      REDO.STACK(REDO.PTR)<4,3> = UNDO<4,3>
      REDO.STACK(REDO.PTR)<4,4> = UNDO<4,4>
*
      RAW.LINES = DELETE(RAW.LINES,REAL.LINE.NUMBER)
*
      X.POS = UNDO<4,1>
      Y.POS = UNDO<4,2>
      CURRENT.LINE = UNDO<4,3>
      LINE.START = UNDO<4,4>
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
   END ELSE IF UNDO<1> = 'DELETE.LINE' THEN
      REAL.LINE.NUMBER = UNDO<2>
      INSERT.LINE = UNDO<3>
*
      REDO.PTR  = REDO.PTR + 1
      REDO.STACK(REDO.PTR) = ''
      REDO.STACK(REDO.PTR)<1> = 'DELETE.LINE'
      REDO.STACK(REDO.PTR)<2> = REAL.LINE.NUMBER
      REDO.STACK(REDO.PTR)<3> = INSERT.LINE
      REDO.STACK(REDO.PTR)<4,1> = UNDO<4,1>
      REDO.STACK(REDO.PTR)<4,2> = UNDO<4,2>
      REDO.STACK(REDO.PTR)<4,3> = UNDO<4,3>
      REDO.STACK(REDO.PTR)<4,4> = UNDO<4,4>
*
      RAW.LINES = INSERT(RAW.LINES,REAL.LINE.NUMBER;INSERT.LINE)
*
      X.POS = UNDO<4,1>
      Y.POS = UNDO<4,2>
      CURRENT.LINE = UNDO<4,3>
      LINE.START = UNDO<4,4>
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
   END ELSE IF UNDO<1> = 'FORMAT.FILE' THEN
      REAL.LINE.NUMBER = UNDO<2>
*
      REDO.PTR  = REDO.PTR + 1
      REDO.STACK(REDO.PTR) = ''
      REDO.STACK(REDO.PTR)<1> = 'FORMAT.FILE'
      REDO.STACK(REDO.PTR)<2> = REAL.LINE.NUMBER
*
      $IFDEF DATABASE.UV
         REDO.STACK(REDO.PTR)<3> = LOWER(RAW.LINES)
      $ENDIF
*
      $IFDEF DATABASE.QM
         REDO.STACK(REDO.PTR)<3> = LOWER(RAW.LINES)
      $ENDIF
*
      $IFDEF DATABASE.D3
         LOWERED.RECORD = RAW.LINES
         CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
         REDO.STACK(REDO.PTR)<3> = LOWERED.RECORD
      $ENDIF
*
      REDO.STACK(REDO.PTR)<4,1> = UNDO<4,1>
      REDO.STACK(REDO.PTR)<4,2> = UNDO<4,2>
      REDO.STACK(REDO.PTR)<4,3> = UNDO<4,3>
      REDO.STACK(REDO.PTR)<4,4> = UNDO<4,4>
*
      $IFDEF DATABASE.UV
         RAW.LINES = RAISE(UNDO<3>)
      $ENDIF
*
      $IFDEF DATABASE.QM
         RAW.LINES = RAISE(UNDO<3>)
      $ENDIF
*
      $IFDEF DATABASE.D3
         RAISED.RECORD = RAW.LINES
         CONVERT @VM:@SVM:@TM:@STM TO @AM:@VM:@SVM:@TM IN RAISED.RECORD
         RAW.LINES = RAISED.RECORD
      $ENDIF
*
      X.POS = UNDO<4,1>
      Y.POS = UNDO<4,2>
      CURRENT.LINE = UNDO<4,3>
      LINE.START = UNDO<4,4>
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
   END
*
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
REDO.HISTORY:NULL
*
   IF INSIDE.VIEW.BUFFER THEN RETURN
*
   IF NEST.LEVEL # 0 THEN
      RETURN
   END
*
   IF REDO.PTR <= 0 THEN
      PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
      PRINT 'Already at the latest change.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   UNDO.PTR = UNDO.PTR + 1
   REDO = REDO.STACK(REDO.PTR)
   REDO.STACK(REDO.PTR) = ''
*
   REDO.PTR = REDO.PTR - 1
*
   IF REDO<1> = 'CHANGE' THEN
      REAL.LINE.NUMBER = REDO<2>
      RAW.LINE = REDO<3>
      X.POS = REDO<4,1>
      Y.POS = REDO<4,2>
      CURRENT.LINE = REDO<4,3>
      LINE.START = REDO<4,4>
*
      RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
   END ELSE IF REDO<1> = 'INSERT.LINE' THEN
      REAL.LINE.NUMBER = REDO<2>
      INSERT.LINE = REDO<3>
      X.POS = REDO<4,1>
      Y.POS = REDO<4,2>
      CURRENT.LINE = REDO<4,3>
      LINE.START = REDO<4,4>
*
      RAW.LINES = INSERT(RAW.LINES,REAL.LINE.NUMBER+1;INSERT.LINE)
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
   END ELSE IF REDO<1> = 'DELETE.LINE' THEN
      REAL.LINE.NUMBER = REDO<2>
      X.POS = REDO<4,1>
      Y.POS = REDO<4,2>
      CURRENT.LINE = REDO<4,3>
      LINE.START = REDO<4,4>
*
      RAW.LINES = DELETE(RAW.LINES,REAL.LINE.NUMBER)
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
   END ELSE IF REDO<1> = 'FORMAT.FILE' THEN
      REAL.LINE.NUMBER = REDO<2>
      X.POS = REDO<4,1>
      Y.POS = REDO<4,2>
      CURRENT.LINE = REDO<4,3>
      LINE.START = REDO<4,4>
*
      $IFDEF DATABASE.UV
         RAW.LINES = RAISE(REDO<3>)
      $ENDIF
*
      $IFDEF DATABASE.QM
         RAW.LINES = RAISE(REDO<3>)
      $ENDIF
*
      $IFDEF DATABASE.D3
         RAISED.RECORD = RAW.LINES
         CONVERT @VM:@SVM:@TM:@STM TO @AM:@VM:@SVM:@TM IN RAISED.RECORD
         RAW.LINES = RAISED.RECORD
      $ENDIF
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
   END
*
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PUSH.EXPLODE:NULL
*
   NEST.LEVEL = NEST.LEVEL + 1
*
   $IFDEF DATABASE.UV
      ORIGINAL.RAW.LINES.STACK<NEST.LEVEL> = LOWER(ORIGINAL.RAW.LINES)
      RAW.LINES.STACK<NEST.LEVEL> = LOWER(RAW.LINES)
*
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      REAL.LINE.NUMBER.STACK<NEST.LEVEL> = REAL.LINE.NUMBER
*
      HISTORY.STACK<NEST.LEVEL> = LOWER(HISTORY)
      HISTORY.X.Y.STACK<NEST.LEVEL> = LOWER(HISTORY.X.Y)
      HISTORY.POS.STACK<NEST.LEVEL> = HISTORY.POS
*
      LINE.START.STACK<NEST.LEVEL> = LINE.START
   $ENDIF
*
   $IFDEF DATABASE.QM
      ORIGINAL.RAW.LINES.STACK<NEST.LEVEL> = LOWER(ORIGINAL.RAW.LINES)
      RAW.LINES.STACK<NEST.LEVEL> = LOWER(RAW.LINES)
*
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      REAL.LINE.NUMBER.STACK<NEST.LEVEL> = REAL.LINE.NUMBER
*
      HISTORY.STACK<NEST.LEVEL> = LOWER(HISTORY)
      HISTORY.X.Y.STACK<NEST.LEVEL> = LOWER(HISTORY.X.Y)
      HISTORY.POS.STACK<NEST.LEVEL> = HISTORY.POS
*
      LINE.START.STACK<NEST.LEVEL> = LINE.START
   $ENDIF
*
   $IFDEF DATABASE.D3
      LOWERED.RECORD = ORIGINAL.RAW.LINES
      CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
      ORIGINAL.RAW.LINES.STACK<NEST.LEVEL> = LOWERED.RECORD
*
      LOWERED.RECORD = RAW.LINES
      CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
      RAW.LINES.STACK<NEST.LEVEL> = LOWERED.RECORD
*
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      REAL.LINE.NUMBER.STACK<NEST.LEVEL> = REAL.LINE.NUMBER
*
      LOWERED.RECORD = HISTORY
      CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
      HISTORY.STACK<NEST.LEVEL> = LOWERED.RECORD
*
      LOWERED.RECORD = HISTORY.X.Y
      CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
      HISTORY.X.Y.STACK<NEST.LEVEL> = LOWERED.RECORD
*
      HISTORY.POS.STACK<NEST.LEVEL> = HISTORY.POS
*
      LINE.START.STACK<NEST.LEVEL> = LINE.START
*
   $ENDIF
*
   RETURN
*
*********************  s u b r o u t i n e  *********************
*
POP.EXPLODE:NULL
*
   $IFDEF DATABASE.UV
      LOWERED.RECORD = LOWER(RAW.LINES)
   $ENDIF
*
   $IFDEF DATABASE.QM
      LOWERED.RECORD = LOWER(RAW.LINES)
   $ENDIF
*
   $IFDEF DATABASE.D3
      LOWERED.RECORD = RAW.LINES
      CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
   $ENDIF
*
   ROW = LOWERED.RECORD
*
   $IFDEF DATABASE.UV
      RAISED.RECORD = RAISE(RAW.LINES.STACK<NEST.LEVEL>)
   $ENDIF
*
   $IFDEF DATABASE.QM
      RAISED.RECORD = RAISE(RAW.LINES.STACK<NEST.LEVEL>)
   $ENDIF
*
   $IFDEF DATABASE.D3
      RAISED.RECORD = RAW.LINES.STACK<NEST.LEVEL>
      CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
   $ENDIF
*
   RAW.LINES = RAISED.RECORD
*
   REAL.LINE.NUMBER = REAL.LINE.NUMBER.STACK<NEST.LEVEL>
*
   IF SAVE.ROW THEN
      RAW.LINES<REAL.LINE.NUMBER> = ROW
   END
*
   $IFDEF DATABASE.UV
      RAISED.RECORD = RAISE(ORIGINAL.RAW.LINES.STACK<NEST.LEVEL>)
   $ENDIF
*
   $IFDEF DATABASE.QM
      RAISED.RECORD = RAISE(ORIGINAL.RAW.LINES.STACK<NEST.LEVEL>)
   $ENDIF
*
   $IFDEF DATABASE.D3
      RAISED.RECORD = ORIGINAL.RAW.LINES.STACK<NEST.LEVEL>
      CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
   $ENDIF
*
   ORIGINAL.RAW.LINES = RAISED.RECORD
*
   $IFDEF DATABASE.UV
      RAISED.RECORD = RAISE(HISTORY.STACK<NEST.LEVEL>)
   $ENDIF
*
   $IFDEF DATABASE.QM
      RAISED.RECORD = RAISE(HISTORY.STACK<NEST.LEVEL>)
   $ENDIF
*
   $IFDEF DATABASE.D3
      RAISED.RECORD =HISTORY.STACK<NEST.LEVEL>
      CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
   $ENDIF
*
   HISTORY = RAISED.RECORD
*
   $IFDEF DATABASE.UV
      RAISED.RECORD = RAISE(HISTORY.X.Y.STACK<NEST.LEVEL>)
   $ENDIF
*
   $IFDEF DATABASE.QM
      RAISED.RECORD = RAISE(HISTORY.X.Y.STACK<NEST.LEVEL>)
   $ENDIF
*
   $IFDEF DATABASE.D3
      RAISED.RECORD = HISTORY.X.Y.STACK<NEST.LEVEL>
      CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
   $ENDIF
*
   HISTORY.X.Y = RAISED.RECORD
*
   HISTORY.POS = HISTORY.POS.STACK<NEST.LEVEL>
   LINE.START = LINE.START.STACK<NEST.LEVEL>
*
   RAW.LINES.STACK<NEST.LEVEL> = ''
   REAL.LINE.NUMBER.STACK<NEST.LEVEL> = ''
   ORIGINAL.RAW.LINES.STACK<NEST.LEVEL> = ''
   HISTORY.STACK<NEST.LEVEL> = ''
   HISTORY.X.Y.STACK<NEST.LEVEL> = ''
   HISTORY.POS.STACK<NEST.LEVEL> = ''
   LINE.START.STACK<NEST.LEVEL> = ''
*
   GOSUB CONVERT.RAW.LINES
   GOSUB DISPLAY.LINES
   GOSUB PUT.CURSOR.TOP.LEFT
*
   GOTO.LINE = REAL.LINE.NUMBER
   GOSUB GOTO.LINE.POSITION
*
   NEST.LEVEL = NEST.LEVEL - 1
*
   IF INSIDE.VIEW.BUFFER THEN
      INSIDE.VIEW.BUFFER = FALSE
   END
*
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PRINT.ERROR.MESSAGE:NULL
*
   PRINT BOTTOM : CLEAR.REST.OF.LINE :
   PRINT BRIGHTRED : 'E -> ' :
   PRINT ERROR.MESSAGE :
   PRINT @(X.POS, Y.POS) :
   INPUT ANYTHING :
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PUT.CURSOR.TOP.LEFT:NULL
*
* PLACE CURSOR IN TOP LEFT
*
   X.POS = MARGIN.LEFT
   Y.POS = MARGIN.TOP
   PRINT @(X.POS, Y.POS) :
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SET.X.POS:NULL
*
   IF ORIGINAL.X.POS # 0 THEN
      X.POS = ORIGINAL.X.POS
      ORIGINAL.X.POS = 0
   END
*
   LINE.LEN = LEN(LINES<CURRENT.LINE>)
   IF LINE.LEN = 0 THEN LINE.LEN = 1
*
   IF X.POS >= LINE.LEN + MARGIN.LEFT THEN
      ORIGINAL.X.POS = X.POS
      X.POS = LINE.LEN + MARGIN.LEFT - 1
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GOTO.LINE.POSITION:NULL
*
   LOCATE(GOTO.LINE,LINE.NUMBERS;CURRENT.LINE) ELSE CURRENT.LINE = NUMBER.OF.LINES
*
   IF CURRENT.LINE > LINE.END OR CURRENT.LINE < LINE.START THEN
      LINE.START = CURRENT.LINE - 15
      IF LINE.START < 1 THEN LINE.START = 1
      GOSUB DISPLAY.LINES
   END
*
   Y.POS = CURRENT.LINE - LINE.START + MARGIN.TOP
*
   GOSUB DISPLAY.HEADER
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GOTO.VISIBLE.LINE.POSITION:NULL
*
   IF CURRENT.LINE > LINE.END OR CURRENT.LINE < LINE.START THEN
      LINE.START = CURRENT.LINE - 15
      IF LINE.START < 1 THEN LINE.START = 1
      GOSUB DISPLAY.LINES
   END
*
   Y.POS = CURRENT.LINE - LINE.START + MARGIN.TOP
*
   GOSUB DISPLAY.HEADER
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.HEADER:NULL
*
   PRINT @(0,0) : CLEAR.REST.OF.LINE
   PRINT @(MARGIN.LEFT,0) :
   PRINT CLEAR.REST.OF.LINE :
   PRINT HEADER.COLOR :
*
   IF IS.UNIVERSE.FILE THEN
      PRINT FILENAME : ' ' : RECORD.ID :
   END ELSE
      PRINT FILENAME :
   END
*
   RETURN
*
   PRINT ' C: ' : CURRENT.LINE :
   PRINT ' L: ' : LINE.NUMBERS<CURRENT.LINE> :
   PRINT ' X: ' : X.POS :
   PRINT ' Y: ' : Y.POS :
   PRINT ' LS: ' : LINE.START :
   PRINT ' LE: ' : LINE.END :
   PRINT ' CH: ' : X.POS - MARGIN.LEFT + 1 :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.FOOTER:NULL
*
   PRINT BOTTOM : CLEAR.REST.OF.LINE :
   RETURN
*********************  S U B R O U T I N E  *********************
*
SETUP.DISPLAY:NULL
*
   GOSUB DISPLAY.HEADER
   PRINT @(0,MARGIN.TOP) : WHITE :
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
CONVERT.RAW.LINES:NULL
*
   LINES = ''
   LINE.NUMBERS = ''
*
   NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
   IF NUMBER.OF.RAW.LINES = 0 THEN NUMBER.OF.RAW.LINES = 1
*
   FOR RAW.LINE.CTR = 1 TO NUMBER.OF.RAW.LINES
      RAW.LINE = RAW.LINES<RAW.LINE.CTR>
      RAW.LINE.LEN = LEN(RAW.LINE)
*
      IF UP.CARET.MODE AND FILETYPE = 'DATA' THEN
         FOR CHAR.CTR = 0 TO 9
            RAW.LINE = CHANGE(RAW.LINE,CHAR(CHAR.CTR),'^00':CHAR.CTR)
         NEXT CHAR.CTR
*
         FOR CHAR.CTR = 10 TO 31
            RAW.LINE = CHANGE(RAW.LINE,CHAR(CHAR.CTR),'^0':CHAR.CTR)
         NEXT CHAR.CTR
*
         FOR CHAR.CTR = 127 TO 253
            RAW.LINE = CHANGE(RAW.LINE,CHAR(CHAR.CTR),'^':CHAR.CTR)
         NEXT CHAR.CTR
*
         RAW.LINES<RAW.LINE.CTR> = RAW.LINE
      END
*
      IF NOT(UP.CARET.MODE) AND FILETYPE = 'DATA' THEN
         FOR CHAR.CTR = 0 TO 9
            RAW.LINE = CHANGE(RAW.LINE,'^00':CHAR.CTR,CHAR(CHAR.CTR))
         NEXT CHAR.CTR
*
         FOR CHAR.CTR = 10 TO 31
            RAW.LINE = CHANGE(RAW.LINE,'^0':CHAR.CTR,CHAR(CHAR.CTR))
         NEXT CHAR.CTR
*
         FOR CHAR.CTR = 127 TO 254
            RAW.LINE = CHANGE(RAW.LINE,'^':CHAR.CTR,CHAR(CHAR.CTR))
         NEXT CHAR.CTR
*
         RAW.LINES<RAW.LINE.CTR> = RAW.LINE
      END
*
      IF RAW.LINE.LEN < VIEW.WIDTH THEN
         IF RAW.LINE.CTR = 1 THEN
            LINES = RAW.LINE
         END ELSE
            LINES = LINES : @AM : RAW.LINE
         END
         LINE.NUMBERS<-1> = RAW.LINE.CTR
      END ELSE
         FOR J = 1 TO RAW.LINE.LEN STEP VIEW.WIDTH
            IF RAW.LINE.CTR = 1 AND J = 1 THEN
               LINES = RAW.LINE[J,VIEW.WIDTH]
            END ELSE
               LINES = LINES : @AM : RAW.LINE[J,VIEW.WIDTH]
            END
            LINE.NUMBERS<-1> = RAW.LINE.CTR
         NEXT J
      END
   NEXT RAW.LINE.CTR
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
* UPDATE LINE GIVEN A REAL.LINE.NUMBER
*
* 1. GET ALL LINES THAT BELONG TO REAL.LINE.NUMBER
* 2. DELETE THEM
* 3. CHUNK THE RAW.LINE
* 4. INSERT THEM BACK INTO LINES
*
UPDATE.LINE:NULL
*
   LOCATE(REAL.LINE.NUMBER,LINE.NUMBERS;LINE.START.POS) ELSE LINE.START.POS = CURRENT.LINE
*
   DONE = FALSE
   LINE.POS = LINE.START.POS
*
   LOOP UNTIL DONE DO
      IF LINE.NUMBERS<LINE.POS> = REAL.LINE.NUMBER THEN
         LINES = DELETE(LINES,LINE.POS)
         LINE.NUMBERS = DELETE(LINE.NUMBERS,LINE.POS)
      END ELSE
         DONE = TRUE
      END
   REPEAT
*
   RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
   RAW.LINE.LEN = LEN(RAW.LINE)
   IF RAW.LINE.LEN = 0 THEN RAW.LINE.LEN = 1
*
   INSERT.LINE.POS = LINE.START.POS
*
   IF RAW.LINE.LEN > VIEW.WIDTH AND MOD(RAW.LINE.LEN,VIEW.WIDTH) = 0 THEN
      RAW.LINE.LEN = RAW.LINE.LEN + 1
   END
*
   FOR J = 1 TO RAW.LINE.LEN STEP VIEW.WIDTH
      LINES = INSERT(LINES,INSERT.LINE.POS;RAW.LINE[J,VIEW.WIDTH])
      LINE.NUMBERS = INSERT(LINE.NUMBERS,INSERT.LINE.POS;REAL.LINE.NUMBER)
      INSERT.LINE.POS = INSERT.LINE.POS + 1
   NEXT J
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
COLORIZE.TOKEN:NULL
*
   LOCATE(TOKEN,STATEMENTS;ANY.POS) THEN
      TOKEN = STMT.COLOR : TOKEN : FOREGROUND.COLOR
      RETURN
   END
*
   LOCATE(TOKEN,FUNCTIONS;ANY.POS) THEN
      TOKEN = FUNCTION.COLOR : TOKEN : FOREGROUND.COLOR
      RETURN
   END
*
   LOCATE(TOKEN,OPERATORS;ANY.POS) THEN
      TOKEN = OPERATOR.COLOR : TOKEN : FOREGROUND.COLOR
      RETURN
   END
*
   LOCATE(TOKEN,SPECIALS;ANY.POS) THEN
      TOKEN = SPECIAL.COLOR : TOKEN : FOREGROUND.COLOR
      RETURN
   END
*
   IF TOKEN # '' AND NUM(TOKEN) THEN
      TOKEN = NUMBER.COLOR : TOKEN : FOREGROUND.COLOR
      RETURN
   END
*
   RETURN
*
*********************  s u b r o u t i n e  *********************
*
TOKENIZE.LINE:NULL
*
   IF FILETYPE = 'BASIC' OR FILETYPE = 'HTML' THEN
      GOSUB TOKENIZE.LINE.BASIC
*
   END ELSE IF FILETYPE = 'PROC' THEN
      GOSUB TOKENIZE.LINE.PROC
*
   END ELSE IF FILETYPE = 'DATA' THEN
      GOSUB TOKENIZE.LINE.DATA
*
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
TOKENIZE.LINE.BASIC:NULL
*
   TOKEN = ''
   TOKENS = ''
*
   CREATED.FIRST.TOKEN = FALSE
   HIT.SEMICOLON = FALSE
*
   FOR LETTER.CTR = 1 TO LEN(LINE)
      CHARACTER = LINE[LETTER.CTR,1]
      TWO.CHARACTERS = LINE[1,2]
      THREE.CHARACTERS = LINE[1,3]
*
      IF DQ.STACK.CTR # 0 OR CHARACTER = '"' THEN
         IF DQ.STACK.CTR = 0 THEN
            TOKENS<-1> = TOKEN
            DQ.STACK.CTR = 1
         END
*
         STRING = CHARACTER
         LETTER.CTR = LETTER.CTR + 1
*
         LOOP UNTIL DQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
            CHARACTER = LINE[LETTER.CTR,1]
            LETTER.CTR = LETTER.CTR + 1
            IF CHARACTER = '"' THEN
               DQ.STACK.CTR = DQ.STACK.CTR - 1
            END
            STRING = STRING : CHARACTER
         REPEAT
*
         CREATED.FIRST.TOKEN = TRUE
         TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
         TOKEN = ''
         LETTER.CTR = LETTER.CTR - 1
*
      END ELSE IF SQ.STACK.CTR # 0 OR CHARACTER = "'" THEN
         IF SQ.STACK.CTR = 0 THEN
            TOKENS<-1> = TOKEN
         END
*
         STRING = CHARACTER
         LETTER.CTR = LETTER.CTR + 1
*
         IF SQ.STACK.CTR = 0 THEN
            SQ.STACK.CTR = 1
         END
*
         LOOP UNTIL SQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
            CHARACTER = LINE[LETTER.CTR,1]
            LETTER.CTR = LETTER.CTR + 1
            IF CHARACTER = "'" THEN
               SQ.STACK.CTR = SQ.STACK.CTR - 1
            END
            STRING = STRING : CHARACTER
         REPEAT
*
         CREATED.FIRST.TOKEN = TRUE
         TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
         TOKEN = ''
         LETTER.CTR = LETTER.CTR - 1
*
      END ELSE IF BSQ.STACK.CTR # 0 OR CHARACTER = "\" THEN
         IF BSQ.STACK.CTR = 0 THEN
            TOKENS<-1> = TOKEN
         END
*
         STRING = CHARACTER
         LETTER.CTR = LETTER.CTR + 1
*
         IF BSQ.STACK.CTR = 0 THEN
            BSQ.STACK.CTR = 1
         END
*
         LOOP UNTIL BSQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
            CHARACTER = LINE[LETTER.CTR,1]
            LETTER.CTR = LETTER.CTR + 1
            IF CHARACTER = "\" THEN
               BSQ.STACK.CTR = BSQ.STACK.CTR - 1
            END
            STRING = STRING : CHARACTER
         REPEAT
*
         CREATED.FIRST.TOKEN = TRUE
         TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
         TOKEN = ''
         LETTER.CTR = LETTER.CTR - 1
*
      END ELSE IF CHARACTER = ';' THEN
         TOKENS<-1> = TOKEN
         HIT.SEMICOLON = TRUE
         GOSUB COLORIZE.TOKEN
         TOKENS<-1> = ';'
         TOKEN = ''
*
      END ELSE IF CHARACTER = '*' OR CHARACTER = '!' OR TWO.CHARACTERS = '$*' OR THREE.CHARACTERS = 'REM' THEN
         IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
         GOSUB COLORIZE.TOKEN
         TOKENS<-1> = TOKEN
*
         IF CREATED.FIRST.TOKEN AND HIT.SEMICOLON = FALSE THEN
            TOKEN = CHARACTER
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
            TOKEN = ''
*
         END ELSE
            TOKENS<-1> = COMMENT.COLOR : LINE[LETTER.CTR,999]
            TOKEN = ''
            LETTER.CTR = LEN(LINE)
         END
*
      END ELSE IF CHARACTER = ' ' THEN
         IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
         GOSUB COLORIZE.TOKEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = ' '
         TOKEN = ''
*
      END ELSE IF ASCII(CHARACTER) = CHAR(253) THEN
         IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
         GOSUB COLORIZE.TOKEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = STMT.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE IF ASCII(CHARACTER) = CHAR(252) THEN
         IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
         GOSUB COLORIZE.TOKEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = FUNCTION.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE IF ASCII(CHARACTER) = CHAR(251) THEN
         IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
         GOSUB COLORIZE.TOKEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = SPECIAL.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE
         LOCATE(CHARACTER,BREAK.CHARACTERS;BREAK.POS) THEN
            IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
*
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
*
            TOKEN = BREAK.CHARACTERS<BREAK.POS>
            GOSUB COLORIZE.TOKEN
*
            TOKENS<-1> = TOKEN
            TOKEN = ''
         END ELSE
            TOKEN = TOKEN : CHARACTER
         END
      END
   NEXT LETTER.CTR
*
   GOSUB COLORIZE.TOKEN
   TOKENS<-1> = TOKEN
*
   LINE = TOKENS
   CONVERT @AM TO '' IN LINE
*
   TOKEN.LEN = DCOUNT(TOKENS,@AM)
   IF TOKEN.LEN = 3 AND TOKENS<2> = OPERATOR.COLOR:':':FOREGROUND.COLOR AND TOKENS<TOKEN.LEN> = OPERATOR.COLOR:'NULL':FOREGROUND.COLOR THEN
      LINE = MAGENTA : LINE : FOREGROUND.COLOR
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
TOKENIZE.LINE.PROC:NULL
*
   TOKEN = ''
   TOKENS = ''
   PROC.COMMANDS = 'PQ RI RO STON PH PW'
   CONVERT ' ' TO @AM IN PROC.COMMANDS
*
   FOR LETTER.CTR = 1 TO LEN(LINE)
      CHARACTER = LINE[LETTER.CTR,1]
*
      IF LETTER.CTR = 1 THEN
         TOKEN = CHARACTER
         TWO.CHARACTERS = LINE[1,2]
*
         LOCATE(LINE,PROC.COMMANDS;POS) THEN
            TOKENS<-1> = GREEN : LINE : FOREGROUND.COLOR
            LETTER.CTR = LEN(LINE)
            TOKEN = ''
            CONTINUE
         END
*
         IF TWO.CHARACTERS = 'IP' THEN
            TOKENS<-1> = GREEN : TWO.CHARACTERS : FOREGROUND.COLOR
            LETTER.CTR = LETTER.CTR + 1
            TOKEN = ''
*
         END ELSE IF TOKEN = 'H' THEN
            TOKENS<-1> = GREEN : TOKEN : FOREGROUND.COLOR
            TOKEN = ''
*
         END ELSE IF TOKEN = 'X' THEN
            TOKENS<-1> = GREEN : TOKEN : FOREGROUND.COLOR
            TOKEN = ''
*
         END ELSE IF TOKEN = 'U' THEN
            TOKENS<-1> = MAGENTA : LINE : FOREGROUND.COLOR
            LETTER.CTR = LEN(LINE)
            TOKEN = ''
*
         END ELSE IF TOKEN = 'A' THEN
            TOKENS<-1> = MAGENTA : LINE : FOREGROUND.COLOR
            LETTER.CTR = LEN(LINE)
            TOKEN = ''
*
         END ELSE IF TOKEN = 'O' THEN
            TOKENS<-1> = GREEN : LINE[1,1] : FOREGROUND.COLOR
            TOKENS<-1> = CYAN : LINE[2,999] : FOREGROUND.COLOR
            LETTER.CTR = LEN(LINE)
            TOKEN = ''
*
         END ELSE IF TOKEN = 'C' THEN
            TOKENS<-1> = COMMENT.COLOR : LINE : FOREGROUND.COLOR
            LETTER.CTR = LEN(LINE)
            TOKEN = ''
*
         END ELSE IF TOKEN = 'S' THEN
            TOKENS<-1> = GREEN : TOKEN : FOREGROUND.COLOR
            TOKEN = ''
*
         END ELSE IF TOKEN = 'P' THEN
            TOKENS<-1> = GREEN : TOKEN : FOREGROUND.COLOR
            TOKEN = ''
*
         END ELSE IF TOKEN = '(' THEN
            TOKENS<-1> = OPERATOR.COLOR : TOKEN : FOREGROUND.COLOR
            TOKEN = ''
         END
*
      END ELSE IF DQ.STACK.CTR # 0 OR CHARACTER = '"' THEN
         IF DQ.STACK.CTR = 0 THEN
            TOKENS<-1> = TOKEN
         END
         STRING = CHARACTER
         LETTER.CTR = LETTER.CTR + 1
*
         IF DQ.STACK.CTR = 0 THEN
            DQ.STACK.CTR = 1
         END
*
         LOOP UNTIL DQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
            CHARACTER = LINE[LETTER.CTR,1]
            LETTER.CTR = LETTER.CTR + 1
            IF CHARACTER = '"' THEN
               DQ.STACK.CTR = DQ.STACK.CTR - 1
            END
            STRING = STRING : CHARACTER
         REPEAT
*
         CREATED.FIRST.TOKEN = TRUE
         TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
         TOKEN = ''
         LETTER.CTR = LETTER.CTR - 1
*
      END ELSE IF SQ.STACK.CTR # 0 OR CHARACTER = "'" THEN
         IF SQ.STACK.CTR = 0 THEN
            TOKENS<-1> = TOKEN
         END
*
         STRING = CHARACTER
         LETTER.CTR = LETTER.CTR + 1
*
         IF SQ.STACK.CTR = 0 THEN
            SQ.STACK.CTR = 1
         END
*
         LOOP UNTIL SQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
            CHARACTER = LINE[LETTER.CTR,1]
            LETTER.CTR = LETTER.CTR + 1
            IF CHARACTER = "'" THEN
               SQ.STACK.CTR = SQ.STACK.CTR - 1
            END
            STRING = STRING : CHARACTER
         REPEAT
*
         CREATED.FIRST.TOKEN = TRUE
         TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
         TOKEN = ''
         LETTER.CTR = LETTER.CTR - 1
*
      END ELSE IF CHARACTER = ' ' THEN
         GOSUB COLORIZE.TOKEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = ' '
         TOKEN = ''
*
      END ELSE IF ASCII(CHARACTER) = CHAR(253) THEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = STMT.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE IF ASCII(CHARACTER) = CHAR(252) THEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = FUNCTION.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE IF ASCII(CHARACTER) = CHAR(251) THEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = SPECIAL.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE
         LOCATE(CHARACTER,BREAK.CHARACTERS;BREAK.POS) THEN
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
            TOKEN = BREAK.CHARACTERS<BREAK.POS>
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
            TOKEN = ''
         END ELSE
            TOKEN = TOKEN : CHARACTER
         END
      END
   NEXT LETTER.CTR
*
   GOSUB COLORIZE.TOKEN
   TOKENS<-1> = TOKEN
*
   LINE = TOKENS
   CONVERT @AM TO '' IN LINE
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
TOKENIZE.LINE.DATA:NULL
*
   TOKEN = ''
   TOKENS = ''
*
   FOR LETTER.CTR = 1 TO LEN(LINE)
      CHARACTER = LINE[LETTER.CTR,1]
*
      IF UP.CARET.MODE AND FILETYPE = 'DATA' AND CHARACTER = '^' THEN
         MV.MARK = LINE[LETTER.CTR,4]
*
         IF MV.MARK = '^251' THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = SPECIAL.COLOR : MV.MARK : FOREGROUND.COLOR
            TOKEN = ''
            LETTER.CTR = LETTER.CTR + 3
            CONTINUE
*
         END ELSE IF MV.MARK = '^252' THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = FUNCTION.COLOR : MV.MARK : FOREGROUND.COLOR
            TOKEN = ''
            LETTER.CTR = LETTER.CTR + 3
            CONTINUE
*
         END ELSE IF MV.MARK = '^253' THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = STMT.COLOR : MV.MARK : FOREGROUND.COLOR
            TOKEN = ''
            LETTER.CTR = LETTER.CTR + 3
            CONTINUE
         END
      END
*
      IF ASCII(CHARACTER) = CHAR(253) THEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = STMT.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE IF ASCII(CHARACTER) = CHAR(252) THEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = FUNCTION.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE IF ASCII(CHARACTER) = CHAR(251) THEN
         TOKENS<-1> = TOKEN
         TOKENS<-1> = SPECIAL.COLOR : CHARACTER : FOREGROUND.COLOR
         TOKEN = ''
*
      END ELSE
         TOKEN = TOKEN : CHARACTER
      END
   NEXT LETTER.CTR
*
   TOKENS<-1> = TOKEN
*
   LINE = TOKENS
   CONVERT @AM TO '' IN LINE
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.LINES:NULL
*
   NUMBER.OF.LINES = DCOUNT(LINES,@AM)
   IF NUMBER.OF.LINES = 0 THEN NUMBER.OF.LINES = 1
*
   IF NUMBER.OF.LINES < 10 THEN
      IF MARGIN.LEFT < 3 THEN
         PADDING.LEFT = 'R#2 '
         MARGIN.LEFT = 2 + 1
      END ELSE
         PADDING.LEFT = 'R#' : MARGIN.LEFT - 1 : ' '
      END
   END ELSE
      IF MARGIN.LEFT < LEN(NUMBER.OF.LINES) THEN
         PADDING.LEFT = 'R#' : LEN(NUMBER.OF.LINES) : ' '
         MARGIN.LEFT = LEN(NUMBER.OF.LINES) + 1
      END ELSE
         PADDING.LEFT = 'R#' : MARGIN.LEFT - 1 : ' '
      END
   END
*
   IF LINE.START < 1 THEN LINE.START = 1
*
   LINE.END = LINE.START + VIEW.HEIGHT - 1
   IF LINE.END > NUMBER.OF.LINES THEN LINE.END = NUMBER.OF.LINES
*
   IF (LINE.END - LINE.START) < VIEW.HEIGHT-1 THEN
      PRINT @(0,0) : CLEAR.SCREEN
   END
*
   GOSUB SETUP.DISPLAY
*
   DQ.STACK.CTR = 0
   SQ.STACK.CTR = 0
   BSQ.STACK.CTR = 0
*
   PREV.LINE.NUMBER = 0
*
   PRINT @(0,MARGIN.TOP) :
   PRINT.POS = MARGIN.TOP
*
   LINE.FOREGROUND.COLOR = FOREGROUND.COLOR
*
   FOR I = LINE.START TO LINE.END
      LINE = LINES<I>
      LINE.NUMBER = LINE.NUMBERS<I>
*
      IF PREV.LINE.NUMBER # LINE.NUMBER THEN
         DQ.STACK.CTR = 0
         SQ.STACK.CTR = 0
         BSQ.STACK.CTR = 0
      END
*
      GOSUB TOKENIZE.LINE
*
      IF RAW.LINES<LINE.NUMBER>[1,1] = '*' OR RAW.LINES<LINE.NUMBER>[1,1] = '!' THEN
         LINE.FOREGROUND.COLOR = COMMENT.COLOR
      END ELSE
         LINE.FOREGROUND.COLOR = FOREGROUND.COLOR
      END
*
      IF VIEW.NUMBERS THEN
         PRINT LINE.NUMBER.COLOR : LINE.NUMBER PADDING.LEFT :
      END ELSE
         PRINT '' PADDING.LEFT :
      END
*
      PRINT LINE.FOREGROUND.COLOR : LINE : CLEAR.REST.OF.LINE
*
      IF SHOW.RIGHT.WINDOW THEN
         AVAILABLE.LENGTH = MARGIN.RIGHT - 1 - 1
         RIGHT.WINDOW.LINE = RIGHT.WINDOW.LINES<LINE.NUMBER>
         PRINT @(VIEW.WIDTH+MARGIN.LEFT+1,PRINT.POS) :
         PRINT LINE.NUMBER.COLOR :
         LINE.TO.PRINT =  LINE.NUMBER PADDING.LEFT : RIGHT.WINDOW.LINE
         PRINT LINE.TO.PRINT[1,AVAILABLE.LENGTH]
      END
*
      PREV.LINE.NUMBER = LINE.NUMBER
      PRINT.POS = PRINT.POS + 1
   NEXT I
*
   IF SHOW.BLOCK THEN
      PRINT.POS = MARGIN.TOP
      FOR I = LINE.START TO LINE.END
         LINE = LINES<I>
         CHAR.TO.PRINT = TRIM(LINE[HIGHLIGHT.BLOCK-MARGIN.LEFT+1,1])
*
         IF CHAR.TO.PRINT = '' THEN
            PRINT @(HIGHLIGHT.BLOCK,PRINT.POS) : '|' :
         END
*
         PRINT.POS = PRINT.POS + 1
      NEXT I
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PRINT.CURRENT.LINE:NULL
*
   LINE = LINES<CURRENT.LINE>
   LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
   PREVIOUS.LINE = LINE.NUMBERS<CURRENT.LINE - 1>
   NEXT.LINE = LINE.NUMBERS<CURRENT.LINE + 1>
*
   IF PREVIOUS.LINE = LINE.NUMBER OR NEXT.LINE = LINE.NUMBER THEN
      LOCATE(LINE.NUMBER,LINE.NUMBERS;LINE.FROM) ELSE LINE.FROM = 1
*
      LINE.TO = LINE.FROM
      LINE.TO.MAX = DCOUNT(LINE.NUMBERS,@AM)
*
      FOR PRINT.CTR = LINE.FROM TO LINE.TO.MAX
         IF LINE.NUMBERS<PRINT.CTR> # LINE.NUMBER THEN
            EXIT
         END
         LINE.TO = PRINT.CTR
      NEXT PRINT.CTR
*
      IF LINE.FROM < CURRENT.LINE THEN
         LINE.DIFF = CURRENT.LINE - LINE.FROM
         LINE.Y.POS = Y.POS - LINE.DIFF
      END ELSE
         LINE.Y.POS = Y.POS
      END
*
      GOSUB DISPLAY.LINES.FROM.TO
      RETURN
   END
*
   DQ.STACK.CTR = 0
   SQ.STACK.CTR = 0
   BSQ.STACK.CTR = 0
*
   GOSUB TOKENIZE.LINE
*
   PRINT @(0,Y.POS) : CLEAR.REST.OF.LINE :
*
   IF VIEW.NUMBERS THEN
      PRINT LINE.NUMBER.COLOR : LINE.NUMBER PADDING.LEFT :
   END ELSE
      PRINT '' PADDING.LEFT :
   END
*
   PRINT FOREGROUND.COLOR : LINE
*
   IF SHOW.RIGHT.WINDOW THEN
      AVAILABLE.LENGTH = MARGIN.RIGHT - 1 - 1
      RIGHT.WINDOW.LINE = RIGHT.WINDOW.LINES<LINE.NUMBER>
      PRINT @(VIEW.WIDTH+MARGIN.LEFT+1,Y.POS) :
      PRINT LINE.NUMBER.COLOR :
      LINE.TO.PRINT = LINE.NUMBER PADDING.LEFT : RIGHT.WINDOW.LINE
      PRINT LINE.TO.PRINT[1,AVAILABLE.LENGTH]
   END
*
   IF SHOW.BLOCK THEN
      LINE = LINES<CURRENT.LINE>
      CHAR.TO.PRINT = TRIM(LINE[HIGHLIGHT.BLOCK-MARGIN.LEFT+1,1])
      IF CHAR.TO.PRINT = '' THEN
         PRINT @(HIGHLIGHT.BLOCK,Y.POS) : '|'
      END
   END
*
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.LINES.FROM.TO:NULL
*
   DQ.STACK.CTR = 0
   SQ.STACK.CTR = 0
   BSQ.STACK.CTR = 0
*
   PREV.LINE.NUMBER = 0
*
   NUMBER.OF.LINES = DCOUNT(LINES,@AM)
   IF NUMBER.OF.LINES = 0 THEN NUMBER.OF.LINES = 1
*
   IF LINE.TO > NUMBER.OF.LINES THEN LINE.TO = NUMBER.OF.LINES
*
   LINES.FROM.CTR = 0
   FOR I = LINE.FROM TO LINE.TO
      LINE = LINES<I>
      LINE.NUMBER = LINE.NUMBERS<I>
      IF PREV.LINE.NUMBER # LINE.NUMBER THEN
         DQ.STACK.CTR = 0
         SQ.STACK.CTR = 0
         BSQ.STACK.CTR = 0
      END
*
      PRINT @(0,LINE.Y.POS+LINES.FROM.CTR) : CLEAR.REST.OF.LINE :
      GOSUB TOKENIZE.LINE
*
      IF VIEW.NUMBERS THEN
         PRINT LINE.NUMBER.COLOR : LINE.NUMBER PADDING.LEFT :
      END ELSE
         PRINT '' PADDING.LEFT :
      END
*
      PRINT FOREGROUND.COLOR : LINE :
      PREV.LINE.NUMBER = LINE.NUMBER
*
      LINES.FROM.CTR = LINES.FROM.CTR + 1
   NEXT I
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.ESCAPE.KEY:NULL
*
   PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
   PRINT @(X.POS,Y.POS) :
*
   ESCAPE.SEQUENCE = ''
*
   $IFDEF DATABASE.UV
      CHR = KEYIN()
   $ENDIF
*
   $IFDEF DATABASE.QM
      CHR = KEYIN()
   $ENDIF
*
   $IFDEF DATABASE.D3
      INPUT CHR,0
   $ENDIF
*
   ESCAPE.SEQUENCE = CHR
*
   IF SEQ(CHR) = SEQ('O') THEN
      $IFDEF DATABASE.UV
         CHR = KEYIN()
      $ENDIF
*
      $IFDEF DATABASE.QM
         CHR = KEYIN()
      $ENDIF
*
      $IFDEF DATABASE.D3
         INPUT CHR,0
      $ENDIF
*
      ESCAPE.SEQUENCE = ESCAPE.SEQUENCE : CHR
*
   END ELSE IF CHR = '[' THEN
      LOOP
         $IFDEF DATABASE.UV
            CHR = KEYIN()
         $ENDIF
*
         $IFDEF DATABASE.QM
            CHR = KEYIN()
         $ENDIF
*
         $IFDEF DATABASE.D3
            INPUT CHR,0
         $ENDIF
*
         ESCAPE.SEQUENCE = ESCAPE.SEQUENCE : CHR
      UNTIL NOT(NUM(CHR)) DO REPEAT
*
   END ELSE
      INPUT.AVAILABLE = TRUE
      PROCESS.CHAR = CHR
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.BASE.ESCAPE.KEY:NULL
*
   IF ESCAPE.SEQUENCE = PAGE.UP THEN
      GOSUB PRINT.CURRENT.LINE
*
      OLD.LINE.START = LINE.START
*
      LINE.START = LINE.START - PAGE.HEIGHT
      IF LINE.START < 1 THEN
         LINE.START = 1
      END
*
      IF OLD.LINE.START = LINE.START THEN
         PRINT @(X.POS, Y.POS) :
         RETURN
      END
*
      CURRENT.LINE = CURRENT.LINE - PAGE.HEIGHT
*
      IF CURRENT.LINE < 1 THEN
         CURRENT.LINE = 1
         Y.POS = MARGIN.TOP
      END ELSE
         Y.POS = CURRENT.LINE - LINE.START + MARGIN.TOP
      END
*
      GOSUB SET.X.POS
      GOSUB DISPLAY.HEADER
      GOSUB DISPLAY.LINES
      PRINT @(X.POS, Y.POS) :
*
   END ELSE IF ESCAPE.SEQUENCE = PAGE.DOWN THEN
      GOSUB PRINT.CURRENT.LINE
*
      NUMBER.OF.LINES = DCOUNT(LINES,@AM)
      IF LINE.START + PAGE.HEIGHT > NUMBER.OF.LINES THEN
         PRINT @(X.POS, Y.POS) :
         RETURN
      END
*
      LINE.START = LINE.START + PAGE.HEIGHT
*
      CURRENT.LINE = CURRENT.LINE + PAGE.HEIGHT
      IF CURRENT.LINE > NUMBER.OF.LINES THEN
         CURRENT.LINE = NUMBER.OF.LINES
         Y.POS = CURRENT.LINE - LINE.START + MARGIN.TOP
      END
*
      GOSUB SET.X.POS
      GOSUB DISPLAY.HEADER
      GOSUB DISPLAY.LINES
      PRINT @(X.POS, Y.POS) :
*
   END ELSE IF ESCAPE.SEQUENCE = UP.ARROW THEN
      GOSUB PRINT.CURRENT.LINE
      GOSUB SCROLL.UP
      PRINT @(X.POS, Y.POS) :
*
   END ELSE IF ESCAPE.SEQUENCE = DOWN.ARROW THEN
      GOSUB PRINT.CURRENT.LINE
      GOSUB SCROLL.DOWN
      PRINT @(X.POS, Y.POS) :
*
   END ELSE IF ESCAPE.SEQUENCE = LEFT.ARROW THEN
      GOSUB PRINT.CURRENT.LINE
      GOSUB SCROLL.LEFT
      PRINT @(X.POS, Y.POS) :
*
   END ELSE IF ESCAPE.SEQUENCE = RIGHT.ARROW THEN
      GOSUB PRINT.CURRENT.LINE
      GOSUB SCROLL.RIGHT
      PRINT @(X.POS, Y.POS) :
*
   END ELSE IF ESCAPE.SEQUENCE = F5 THEN
      GOSUB PRECOMPILE
*
   END ELSE IF ESCAPE.SEQUENCE = F6 THEN
      GOSUB DECOMPILE
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.EDITOR.COMMAND:NULL
*
   PRINT BOTTOM : CLEAR.REST.OF.LINE :
   PRINT EDITOR.COLOR : EDITOR.PROMPT : EDITOR.COMMAND :
*
   INPUT.PROMPT = EDITOR.PROMPT
   INPUT.STRING = ''
   INPUT.X.POS = 0
   INPUT.MARGIN.LEFT = EDITOR.MARGIN.LEFT
   INPUT.HISTORY = EDITOR.HISTORY
*
   IF EDITOR.COMMAND.AVAILABLE THEN
      EDITOR.COMMAND.AVAILABLE = FALSE
   END ELSE
      GOSUB PROCESS.INPUT
      EDITOR.COMMAND = INPUT.STRING
   END
*
   IF EDITOR.HISTORY<1,DCOUNT(EDITOR.HISTORY<1>,@VM)> # EDITOR.COMMAND THEN
      EDITOR.HISTORY<1,-1> = EDITOR.COMMAND
      IF EVA.HISTORY.OPENED THEN WRITEV EDITOR.HISTORY ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.EDITOR.ATTRIBUTE
   END
*
   IF EDITOR.COMMAND # '' AND NUM(EDITOR.COMMAND) THEN
      GOTO.LINE = EDITOR.COMMAND
      GOSUB GOTO.LINE.POSITION
      X.POS = MARGIN.LEFT
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND = 'invert' THEN
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
      RAW.LINE.LEN = LEN(RAW.LINE)
*
      INVERTED.STRING = ''
      FOR LETTER.CTR = 1 TO RAW.LINE.LEN
         CHAR = RAW.LINE[LETTER.CTR,1]
         SEQ.CHAR = SEQ(CHAR)
         IF SEQ.CHAR >= 97 AND SEQ.CHAR <= 122 THEN
            INVERTED.STRING = INVERTED.STRING : OCONV(CHAR,'MCU')
         END ELSE IF SEQ.CHAR >= 65 AND SEQ.CHAR <= 90 THEN
            INVERTED.STRING = INVERTED.STRING : OCONV(CHAR,'MCL')
         END ELSE
            INVERTED.STRING = INVERTED.STRING : CHAR
         END
      NEXT LETTER.CTR
*
      RAW.LINES<REAL.LINE.NUMBER> = INVERTED.STRING
      GOSUB UPDATE.LINE
*
      GOSUB PRINT.CURRENT.LINE
*
   END ELSE IF EDITOR.COMMAND = 'lower' THEN
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      RAW.LINES<REAL.LINE.NUMBER> = OCONV(RAW.LINES<REAL.LINE.NUMBER>,'MCL')
      GOSUB UPDATE.LINE
      RAW.LINE.LEN = LEN(RAW.LINES<REAL.LINE.NUMBER>)
      GOSUB PRINT.CURRENT.LINE
*
   END ELSE IF EDITOR.COMMAND = 'upper' THEN
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      RAW.LINES<REAL.LINE.NUMBER> = OCONV(RAW.LINES<REAL.LINE.NUMBER>,'MCU')
      GOSUB UPDATE.LINE
      RAW.LINE.LEN = LEN(RAW.LINES<REAL.LINE.NUMBER>)
      GOSUB PRINT.CURRENT.LINE
*
   END ELSE IF EDITOR.COMMAND = 'numbers' THEN
      VIEW.NUMBERS = NOT(VIEW.NUMBERS)
      NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
      IF VIEW.NUMBERS THEN
         IF NUMBER.OF.RAW.LINES < 10 THEN
            IF MARGIN.LEFT < 3 THEN
               PADDING.LEFT = 'R#2 '
               MARGIN.LEFT = 2 + 1
            END ELSE
               PADDING.LEFT = 'R#' : MARGIN.LEFT - 1 : ' '
            END
         END ELSE
            IF MARGIN.LEFT < LEN(NUMBER.OF.RAW.LINES) THEN
               PADDING.LEFT = 'R#' : LEN(NUMBER.OF.RAW.LINES) : ' '
               MARGIN.LEFT = LEN(NUMBER.OF.RAW.LINES) + 1
            END ELSE
               PADDING.LEFT = 'R#' : MARGIN.LEFT - 1 : ' '
            END
         END
      END
*
      GOSUB DISPLAY.LINES
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND = 'archive' THEN
      IF IS.OS.FILE THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to archive OS file.'
         RETURN
      END
*
      IF ARCHIVE.OPENED THEN
         ARCHIVE.DATE = OCONV(DATE(),'D')
         CONVERT ' ' TO '' IN ARCHIVE.DATE
*
         ID.OK = FALSE
         SEQ = 0
         LOOP
            $IFDEF DATABASE.UV
               ARCHIVE.ID = ARCHIVE.DATE : '*' : RECORD.ID
            $ENDIF
            $IFDEF DATABASE.QM
               ARCHIVE.ID = ARCHIVE.DATE : '*' : RECORD.ID
            $ENDIF
            $IFDEF DATABASE.D3
               ARCHIVE.ID = FILENAME : '*' : ARCHIVE.DATE : '*' : RECORD.ID
            $ENDIF
            IF SEQ # 0 THEN ARCHIVE.ID = ARCHIVE.ID : '*' : SEQ
            READV ANYTHING FROM ARCHIVE.FILE, ARCHIVE.ID, 1 ELSE ID.OK = TRUE
         UNTIL ID.OK DO
            SEQ = SEQ + 1
         REPEAT
*
         WRITE RAW.LINES ON ARCHIVE.FILE, ARCHIVE.ID
*
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Archived in ' : ARCHIVE.FILENAME : ' as ' : ARCHIVE.ID :'.' :
*
      END ELSE
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to archive.' :
      END
*
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND[1,5] = 'count' THEN
      SUBSTRING = OCONV(EDITOR.COMMAND[7,9999],'MCU')
      SUM = COUNT(RAW.LINES,SUBSTRING)
*
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'Counted ' : SUM : ' occurances of ' : SUBSTRING :
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND = 'fa' THEN
      IF NEST.LEVEL # 0 OR FILETYPE # 'DATA' THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to open dictionary' :
         PRINT @(X.POS,Y.POS) :
*
         RETURN
      END
*
      GOSUB TOGGLE.DICTIONARY
*
   END ELSE IF EDITOR.COMMAND = 'dict' THEN
      IF IS.OS.FILE THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to open dictionary on OS file.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      GOSUB PUSH.EXPLODE
      INSIDE.VIEW.BUFFER = TRUE
*
      RAW.LINES = DICT.LINES
      ORIGINAL.RAW.LINES = RAW.LINES
*
      HISTORY = ''
      HISTORY.X.Y = ''
      HISTORY.POS = 1
*
      CURRENT.LINE = 1
      LINE.START = 1
*
      GOSUB PUT.CURSOR.TOP.LEFT
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'DICT ' : FILENAME : ' ' : RECORD.ID :
*
      GOSUB PUT.CURSOR.TOP.LEFT
*
   END ELSE IF EDITOR.COMMAND = 'help' OR EDITOR.COMMAND = 'h' THEN
      GOSUB PUSH.EXPLODE
      INSIDE.VIEW.BUFFER = TRUE
*
      RAW.LINES = HELP.LINES
      ORIGINAL.RAW.LINES = RAW.LINES
*
      HISTORY = ''
      HISTORY.X.Y = ''
      HISTORY.POS = 1
*
      CURRENT.LINE = 1
      LINE.START = 1
*
      GOSUB PUT.CURSOR.TOP.LEFT
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'Help':
*
      GOSUB PUT.CURSOR.TOP.LEFT
*
   END ELSE IF EDITOR.COMMAND = '^' THEN
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
*
      IF FILETYPE = 'DATA' THEN
         IF UP.CARET.MODE THEN
            UP.CARET.MODE = FALSE
            PRINT 'Turned off up-arrow mode.' :
         END ELSE
            UP.CARET.MODE = TRUE
            PRINT 'Turned on up-arrow mode.' :
         END
*
         GOSUB CONVERT.RAW.LINES
         GOSUB DISPLAY.LINES
*
      END ELSE
         PRINT 'Up-arrow mode is only available for data files. Please change the file type.' :
      END
*
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND[1,6] = 'syntax' THEN
      FILETYPE = FIELD(EDITOR.COMMAND,'=',2)
      GOSUB SYNTAX.INIT
      GOSUB DISPLAY.LINES
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND = 'gf' THEN
      IF IS.OS.FILE THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to open vlist on OS file.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      LINE = TRIM(LINES<CURRENT.LINE>)
*
      FIRST.WORD = FIELD(LINE,' ',1)
      SECOND.WORD = FIELD(LINE,' ',2)
*
      IF FIRST.WORD # 'CALL' THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Not a subroutine.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      GF.RECORD.ID = SECOND.WORD[1,INDEX(SECOND.WORD,'(',1)-1]
*
      READ GF.RAW.LINES FROM FILE,GF.RECORD.ID ELSE
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Failed to open: ' : FILENAME : ' ' : RECORD.ID : '.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      GOSUB PUSH.EXPLODE
      INSIDE.VIEW.BUFFER = TRUE
*
      RAW.LINES = GF.RAW.LINES
      ORIGINAL.RAW.LINES = RAW.LINES
*
      HISTORY = ''
      HISTORY.X.Y = ''
      HISTORY.POS = 1
*
      CURRENT.LINE = 1
      LINE.START = 1
*
      GOSUB PUT.CURSOR.TOP.LEFT
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'Viewing ' : FILENAME : ' ' : GF.RECORD.ID :
*
      GOSUB PUT.CURSOR.TOP.LEFT
*
   END ELSE IF EDITOR.COMMAND = 'vlist' THEN
      IF IS.OS.FILE THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to open vlist on OS file.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      EXECUTE 'VLIST ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
*
      GOSUB PUSH.EXPLODE
      INSIDE.VIEW.BUFFER = TRUE
*
      RAW.LINES = ''
      NUMBER.OF.VLIST = DCOUNT(RESULTS,@AM)
*
      FOR RESULT.CTR = 1 TO NUMBER.OF.VLIST
         IF RESULTS<RESULT.CTR> # '' THEN
            RAW.LINES<-1> = RESULTS<RESULT.CTR>
         END
      NEXT RESULT.CTR
*
      ORIGINAL.RAW.LINES = RAW.LINES
*
      HISTORY = ''
      HISTORY.X.Y = ''
      HISTORY.POS = 1
*
      CURRENT.LINE = 1
      LINE.START = 1
*
      GOSUB PUT.CURSOR.TOP.LEFT
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'VLIST ' : FILENAME : ' ' : RECORD.ID :
*
      GOSUB PUT.CURSOR.TOP.LEFT
*
   END ELSE IF EDITOR.COMMAND = 'r' THEN
      IF OPEN.READONLY THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'This file is read only.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      IF IS.OS.FILE THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to open run OS file.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      IF FILETYPE # 'BASIC' THEN RETURN
*
      GOSUB SAVE.FILE
*
      EXECUTE 'BASIC ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
*
      IF RESULTS<3> = '' THEN
         EXECUTE 'RUN ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
         PRINT CLEAR.SCREEN :
         PRINT @(0,0) :
         PRINT OCONV(TIME(),'MTS') : ': ' :
         PRINT 'SUCCESS -----------------'
         PRINT
*
         FOR J = 1 TO DCOUNT(RESULTS,@AM)
            PRINT RESULTS<J>
         NEXT J
*
         PRINT 'Program finished - Press Return : ' :
         INPUT ANYTHING :
*
         GOSUB DISPLAY.LINES
         PRINT @(X.POS,Y.POS) :
*
      END ELSE
         PRINT CLEAR.SCREEN :
         PRINT @(0,0) :
         PRINT OCONV(TIME(),'MTS') : ': ' :
         PRINT 'Error -----------------'
         PRINT
*
         FOR J = 1 TO DCOUNT(RESULTS,@AM)
            PRINT RESULTS<J>
         NEXT J
*
         PRINT 'Program finished - Press Return : ' :
         INPUT ANYTHING :
*
         GOSUB DISPLAY.LINES
         PRINT @(X.POS,Y.POS) :
      END
*
   END ELSE IF EDITOR.COMMAND = 'f' THEN
      IF FILETYPE = 'HTML' THEN
         UNDO.OP = 'FORMAT.FILE'
         GOSUB PUSH.HISTORY
*
         GOSUB FORMAT.HTML
*
      END ELSE IF FILETYPE = 'BASIC' THEN
         UNDO.OP = 'FORMAT.FILE'
         GOSUB PUSH.HISTORY
*
         GOSUB FORMAT.BASIC
      END
*
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'Formatted file.' :
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND = 'dec' OR EDITOR.COMMAND = 'decompile' THEN
      GOSUB DECOMPILE
*
   END ELSE IF EDITOR.COMMAND = 'prec' OR EDITOR.COMMAND = 'precompile' THEN
      GOSUB PRECOMPILE
*
   END ELSE IF EDITOR.COMMAND = 'comp' THEN
      IF FILETYPE # 'BASIC' THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'This file is not a BASIC file.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      READ ANYTHING FROM VOC.FILE,'DECOMPILE' ELSE
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'DECOMPILE is not available.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      GOSUB SAVE.FILE
*
      EXECUTE 'DECOMPILE ' : FILENAME : ' ' : RECORD.ID
      EXECUTE 'PRECOMPILE ' : FILENAME : ' ' : RECORD.ID : ' (A'
*
      READU RAW.LINES FROM FILE,RECORD.ID ELSE
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Error reading file after pre-processing.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
      $IFDEF DATABASE.UV
         CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
      $ENDIF
*
      $IFDEF DATABASE.QM
         CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
      $ENDIF
*
      $IFDEF DATABASE.D3
         CURRENT.CHECKSUM = OCONV(RAW.LINES,'u001e')
      $ENDIF
*
      GOSUB FORMAT.BASIC
*
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'Decompiled and precompiled file.' :
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND[1,1] = 'a' THEN
      EDITOR.COMMAND = EDITOR.COMMAND[2,9999]
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
*
      NUMBER.OF.ARGUMENTS = DCOUNT(EDITOR.COMMAND,' ')
*
      APPEND.LINES = FIELD(EDITOR.COMMAND,' ',1)
      APPEND.STRING = FIELD(EDITOR.COMMAND,' ',2)
*
      IF APPEND.LINES = '' THEN APPEND.LINES = 1
*
      IF APPEND.STRING # '' THEN
         LINES.LEFT = DCOUNT(RAW.LINES,@AM) - REAL.LINE.NUMBER
         IF APPEND.LINES > LINES.LEFT THEN
            APPEND.LINES = LINES.LEFT + 1
         END
*
         LINES.TO.APPEND.TO = REAL.LINE.NUMBER + APPEND.LINES - 1
*
         APPEND.START = REAL.LINE.NUMBER
*
         FOR REAL.LINE.NUMBER = APPEND.START TO LINES.TO.APPEND.TO
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
            UNDO.OP = 'CHANGE'
            GOSUB PUSH.HISTORY
*
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINES<REAL.LINE.NUMBER> : APPEND.STRING
            GOSUB UPDATE.LINE
         NEXT REAL.LINE.NUMBER
*
         GOSUB DISPLAY.LINES
*
         PRINT @(X.POS,Y.POS) :
      END
*
   END ELSE IF EDITOR.COMMAND = 'drop' THEN
      GOSUB DROP.BLOCK
      EDITOR.COMMAND = ''
*
   END ELSE IF EDITOR.COMMAND = 'm' THEN
      GOSUB DROP.BLOCK
      GOSUB PASTE.BLOCK
      EDITOR.COMMAND = ''
*
   END ELSE IF EDITOR.COMMAND[1,2] = 'dt' THEN
      POSSIBLE.NUMBER = EDITOR.COMMAND[3,999]
      IF POSSIBLE.NUMBER = '' THEN
         POSSIBLE.NUMBER = 1
      END
*
      IF NOT(NUM(POSSIBLE.NUMBER)) THEN
         EDITOR.COMMAND = ''
         PRINT BOTTOM : CLEAR.REST.OF.LINE :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      IF POSSIBLE.NUMBER > DCOUNT(RAW.LINES,@AM) - REAL.LINE.NUMBER + 1 THEN
         POSSIBLE.NUMBER = DCOUNT(RAW.LINES,@AM) - REAL.LINE.NUMBER + 1
         IF POSSIBLE.NUMBER = 0 THEN POSSIBLE.NUMBER = REAL.LINE.NUMBER
      END
*
      IF POSSIBLE.NUMBER < REAL.LINE.NUMBER THEN
         POSSIBLE.NUMBER = REAL.LINE.NUMBER
      END
*
      FOR EDITOR.CTR = REAL.LINE.NUMBER TO POSSIBLE.NUMBER
         IF DCOUNT(RAW.LINES,@AM) = 0 THEN
            PRINT BOTTOM : CLEAR.REST.OF.LINE :
            PRINT @(X.POS,Y.POS) :
*
         END ELSE
            ORIGINAL.NUMBER.OF.LINES = DCOUNT(LINES,@AM)
*
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
            UNDO.OP = 'DELETE.LINE'
            GOSUB PUSH.HISTORY
*
            RAW.LINES = DELETE(RAW.LINES,REAL.LINE.NUMBER)
*
            IF DCOUNT(RAW.LINES,@AM) = 0 THEN
               RAW.LINES<-1> = ''
               LINES = ''
               LINE.NUMBERS = 1
            END
*
            IF CURRENT.LINE =  ORIGINAL.NUMBER.OF.LINES AND CURRENT.LINE # 1 THEN
               Y.POS = Y.POS - 1
               CURRENT.LINE = CURRENT.LINE - 1
            END
         END
      NEXT EDITOR.CTR
*
      PASTE.NEWLINE = TRUE
      YANKED.LINES = RAW.LINE
      IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
      X.POS = MARGIN.LEFT
      PRINT @(X.POS,Y.POS) :
*
      EDITOR.COMMAND = ''
*
*
   END ELSE IF EDITOR.COMMAND[1,1] = 'd' THEN
      POSSIBLE.NUMBER = EDITOR.COMMAND[2,999]
      IF POSSIBLE.NUMBER = '' THEN
         POSSIBLE.NUMBER = 1
      END
*
      IF NOT(NUM(POSSIBLE.NUMBER)) THEN
         EDITOR.COMMAND = ''
         PRINT BOTTOM : CLEAR.REST.OF.LINE :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      IF POSSIBLE.NUMBER > DCOUNT(RAW.LINES,@AM) - REAL.LINE.NUMBER + 1 THEN
         POSSIBLE.NUMBER = DCOUNT(RAW.LINES,@AM) - REAL.LINE.NUMBER + 1
         IF POSSIBLE.NUMBER = 0 THEN POSSIBLE.NUMBER = 1
      END
*
      FOR EDITOR.CTR = 1 TO POSSIBLE.NUMBER
         IF DCOUNT(RAW.LINES,@AM) = 0 THEN
            PRINT BOTTOM : CLEAR.REST.OF.LINE :
            PRINT @(X.POS,Y.POS) :
*
         END ELSE
            ORIGINAL.NUMBER.OF.LINES = DCOUNT(LINES,@AM)
*
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
            UNDO.OP = 'DELETE.LINE'
            GOSUB PUSH.HISTORY
*
            RAW.LINES = DELETE(RAW.LINES,REAL.LINE.NUMBER)
*
            IF DCOUNT(RAW.LINES,@AM) = 0 THEN
               RAW.LINES<-1> = ''
               LINES = ''
               LINE.NUMBERS = 1
            END
*
            IF CURRENT.LINE =  ORIGINAL.NUMBER.OF.LINES AND CURRENT.LINE # 1 THEN
               Y.POS = Y.POS - 1
               CURRENT.LINE = CURRENT.LINE - 1
            END
         END
      NEXT EDITOR.CTR
*
      PASTE.NEWLINE = TRUE
      YANKED.LINES = RAW.LINE
      IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
*
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
      X.POS = MARGIN.LEFT
      PRINT @(X.POS,Y.POS) :
*
      EDITOR.COMMAND = ''
*
   END ELSE IF EDITOR.COMMAND = 'e' THEN
      SEARCH.STRING = '%END'
      GOSUB PROCESS.SEARCH
*
      IF SEARCH.RESULTS.EXIST THEN
         FORWARD.SEARCH = TRUE
         GOSUB GOTO.SEARCH.RESULT
      END
*
   END ELSE IF EDITOR.COMMAND[1,2] = '%s' THEN
      VALUE = EDITOR.COMMAND[3,999]
*
      DELIMITER = VALUE[1,1]
      NEEDLE = FIELD(VALUE,DELIMITER,2)
      NEW.VALUE = FIELD(VALUE,DELIMITER,3)
*
      REPLACE.TO = DCOUNT(RAW.LINES,@AM)
*
      FOR REPLACE.LINE.CTR = 1 TO REPLACE.TO
         REAL.LINE.NUMBER = REPLACE.LINE.CTR
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         UNDO.OP = 'CHANGE'
         GOSUB PUSH.HISTORY
*
         IF NEEDLE = '' THEN
            RAW.LINE = NEW.VALUE : RAW.LINE
         END ELSE
            RAW.LINE = CHANGE(RAW.LINE,NEEDLE,NEW.VALUE)
         END
*
         RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
         GOSUB UPDATE.LINE
      NEXT REPLACE.LINE.CTR
*
      GOSUB DISPLAY.LINES
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND[1,1] = 's' THEN
      VALUE = EDITOR.COMMAND[2,999]
*
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
*
      DELIMITER = VALUE[1,1]
      NEEDLE = FIELD(VALUE,DELIMITER,2)
      NEW.VALUE = FIELD(VALUE,DELIMITER,3)
      OCCURANCES = FIELD(VALUE,DELIMITER,4)
*
      IF OCCURANCES = '' OR NOT(NUM(OCCURANCES)) THEN
         OCCURANCES = 1
      END
*
      REPLACE.TO = REAL.LINE.NUMBER + OCCURANCES - 1
*
      FOR REPLACE.LINE.CTR = REAL.LINE.NUMBER TO REPLACE.TO
         REAL.LINE.NUMBER = REPLACE.LINE.CTR
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         UNDO.OP = 'CHANGE'
         GOSUB PUSH.HISTORY
*
         IF NEEDLE = '' THEN
            RAW.LINE = NEW.VALUE : RAW.LINE
         END ELSE
            RAW.LINE = CHANGE(RAW.LINE,NEEDLE,NEW.VALUE)
         END
*
         RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
         GOSUB UPDATE.LINE
      NEXT REPLACE.LINE.CTR
*
      GOSUB DISPLAY.LINES
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND = 'ev' THEN
      GOSUB PUSH.EXPLODE
*
      $IFDEF DATABASE.UV
         RAISED.RECORD = RAISE(RAW.LINES<REAL.LINE.NUMBER>)
      $ENDIF
*
      $IFDEF DATABASE.QM
         RAISED.RECORD = RAISE(RAW.LINES<REAL.LINE.NUMBER>)
      $ENDIF
*
      $IFDEF DATABASE.D3
         RAISED.RECORD = RAW.LINES<REAL.LINE.NUMBER>
         CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
      $ENDIF
      RAW.LINES = RAISED.RECORD
*
      ORIGINAL.RAW.LINES = RAW.LINES
*
      HISTORY = ''
      HISTORY.X.Y = ''
      HISTORY.POS = 1
*
      CURRENT.LINE = 1
      LINE.START = 1
*
      SHOW.RIGHT.WINDOW = FALSE
      MARGIN.RIGHT = 1
      VIEW.WIDTH = SCREEN.WIDTH - MARGIN.LEFT - MARGIN.RIGHT
*
      GOSUB PUT.CURSOR.TOP.LEFT
      GOSUB CONVERT.RAW.LINES
      GOSUB DISPLAY.LINES
*
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'Exploded line ' : CURRENT.LINE : '.' :
*
      GOSUB PUT.CURSOR.TOP.LEFT
*
   END ELSE IF EDITOR.COMMAND[1,1] = 'q' OR EDITOR.COMMAND = 'exk'  OR EDITOR.COMMAND = 'x' THEN
      IF NEST.LEVEL # 0 THEN
         IF ORIGINAL.RAW.LINES = RAW.LINES THEN
            SAVE.ROW = FALSE
            GOSUB POP.EXPLODE
*
         END ELSE
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
            PRINT 'There are unsaved changes. Are you sure you want to exit? (y/n) ' :
            INPUT ANSWER :
*
            IF OCONV(ANSWER,'MCL') = 'y' THEN
               SAVE.ROW = FALSE
               GOSUB POP.EXPLODE
            END
*
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
            PRINT @(X.POS,Y.POS) :
         END
*
      END ELSE
         IF ORIGINAL.RAW.LINES = RAW.LINES OR EDITOR.COMMAND[2,1] = '!' THEN
            IF EDITOR.COMMAND = 'exk' OR EDITOR.COMMAND = 'x' THEN QUIT.ALL.FLAG = TRUE
            QUIT.FLAG = TRUE
*
         END ELSE
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
            PRINT 'There are unsaved changes. Are you sure you want to exit? (y/n) ' :
            INPUT ANSWER :
*
            IF OCONV(ANSWER,'MCL') = 'y' THEN
               IF EDITOR.COMMAND = 'exk' OR EDITOR.COMMAND = 'x' THEN QUIT.ALL.FLAG = TRUE
               QUIT.FLAG = TRUE
            END
*
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
            PRINT @(X.POS,Y.POS) :
         END
      END
*
   END ELSE IF EDITOR.COMMAND = 'lint' THEN
      IF IS.OS.FILE THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to run the linter on an OS file.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      EXECUTE 'LINT ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
*
      PRINT CLEAR.SCREEN :
      PRINT @(0,MARGIN.TOP) :
      PRINT OCONV(TIME(),'MTS') : ': ' :
*
      FOR J = 1 TO DCOUNT(RESULTS,@AM)
         PRINT RESULTS<J>
      NEXT J
      INPUT ANYTHING :
*
      GOSUB DISPLAY.LINES
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND[1,1] = 'w' THEN
      IF OPEN.READONLY THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'This file is read only.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      GOSUB SAVE.FILE
      GOSUB COMPILE.FILE
*
      IF NEST.LEVEL = 0 AND EDITOR.COMMAND[2,1] = 'q' THEN
         QUIT.FLAG = TRUE
      END
*
   END ELSE IF EDITOR.COMMAND = 'fd' THEN
      IF IS.OS.FILE THEN
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
         PRINT 'Unable to open delete an OS file.' :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
*
      PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
      PRINT 'You are trying to delete the entire record. Are you sure? (y/n) ' :
*
      INPUT ANS :
      IF ANS = 'Y' THEN
         DELETE FILE,RECORD.ID
         QUIT.FLAG = TRUE
      END
*
      PRINT BOTTOM : CLEAR.REST.OF.LINE :
      PRINT @(X.POS,Y.POS) :
*
   END ELSE IF EDITOR.COMMAND[1,4] = 'load' THEN
      NUMBER.OF.ARGUMENTS = DCOUNT(EDITOR.COMMAND,' ')
*
      IF NUMBER.OF.ARGUMENTS = 2 THEN
         DICT = ''
         LOAD.FILENAME = FILENAME
         LOAD.ITEM.ID = FIELD(EDITOR.COMMAND,' ',2)
*
      END ELSE IF NUMBER.OF.ARGUMENTS = 3 THEN
         DICT = ''
         LOAD.FILENAME = FIELD(EDITOR.COMMAND,' ',2)
         LOAD.ITEM.ID = FIELD(EDITOR.COMMAND,' ',3)
*
      END ELSE IF NUMBER.OF.ARGUMENTS = 4 THEN
         DICT = 'DICT'
         LOAD.FILENAME = FIELD(EDITOR.COMMAND,' ',3)
         LOAD.ITEM.ID = FIELD(EDITOR.COMMAND,' ',4)
      END
*
      OPEN DICT,LOAD.FILENAME TO LOAD.FILE THEN
         READ LOAD.ITEM FROM LOAD.FILE,LOAD.ITEM.ID THEN
            MAT UNDO.STACK = ''
            MAT REDO.STACK = ''
*
            UNDO.PTR = 0
            REDO.PTR = 0
*
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Starting line/field number: ' :
            INPUT LOAD.START :
*
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Ending line/field number: ' :
            INPUT LOAD.END :
*
            LOAD.LENGTH = DCOUNT(LOAD.ITEM,@AM)
            IF LOAD.END > LOAD.LENGTH THEN
               LOAD.END = LOAD.LENGTH
            END
            IF LOAD.END < LOAD.START THEN
               LOAD.END = LOAD.START
            END
*
            IF DCOUNT(RAW.LINES,@AM) = 0 THEN
               INSERT.AT.LINE = 1
            END ELSE
               REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
               INSERT.AT.LINE = REAL.LINE.NUMBER + 1
            END
*
            LINE.COUNTER = 0
            FOR I = LOAD.START TO LOAD.END
               RAW.LINES = INSERT(RAW.LINES,INSERT.AT.LINE;LOAD.ITEM<I>)
               INSERT.AT.LINE = INSERT.AT.LINE + 1
               LINE.COUNTER = LINE.COUNTER + 1
            NEXT I
*
            GOSUB CONVERT.RAW.LINES
            GOSUB DISPLAY.LINES
*
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT LINE.COUNTER : ' lines/fields loaded.' :
*
         END ELSE
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Unable to open record: ' : LOAD.ITEM.ID :
         END
      END ELSE
         PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
         PRINT 'Unable to open file: ' : LOAD.FILENAME :
      END
*
      PRINT @(X.POS,Y.POS) :
*
   END ELSE
      PRINT BOTTOM : CLEAR.REST.OF.LINE :
      PRINT @(X.POS,Y.POS) :
   END
*
   EDITOR.COMMAND = ''
*
   RETURN
*
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.SEARCH.INPUT:NULL
*
   PRINT BOTTOM : EDITOR.COLOR : CLEAR.REST.OF.LINE :
   PRINT SEARCH.PROMPT :
*
   INPUT.PROMPT = SEARCH.PROMPT
   INPUT.STRING = ''
   INPUT.X.POS = 0
   INPUT.MARGIN.LEFT = SEARCH.MARGIN.LEFT
   INPUT.HISTORY = SEARCH.HISTORY
*
   GOSUB PROCESS.INPUT
*
   SEARCH.POSITION = 0
   SEARCH.STRING = INPUT.STRING
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.SEARCH:NULL
*
   IF SEARCH.STRING = '' THEN
      SEARCH.STRING = ORIGINAL.SEARCH.STRING
      IF SEARCH.STRING = '' THEN
         PRINT BOTTOM : CLEAR.REST.OF.LINE :
         PRINT @(X.POS,Y.POS) :
         RETURN
      END
   END
*
   IF SEARCH.HISTORY<1,DCOUNT(SEARCH.HISTORY<1>,@VM)> # SEARCH.STRING THEN
      SEARCH.HISTORY<1,-1> = SEARCH.STRING
      IF EVA.HISTORY.OPENED THEN WRITEV SEARCH.HISTORY ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.SEARCH.ATTRIBUTE
   END
*
   ORIGINAL.SEARCH.STRING = SEARCH.STRING
   SEARCH.FOUND = FALSE
*
   SEARCH.LINE.NUMBERS = ''
   SEARCH.X.POSITIONS = ''
*
   SEARCH.CTR = 0
*
   NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
   SEARCH.RESULTS.EXIST = TRUE
*
   FOR REAL.LINE.NUMBER = 1 TO NUMBER.OF.RAW.LINES
      RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
      SEARCH.OCCURANCE = 0
*
      LOOP
         SEARCH.OCCURANCE = SEARCH.OCCURANCE + 1
         FOUND.POS = INDEX(OCONV(RAW.LINE,'MCU'),OCONV(SEARCH.STRING,'MCU'),SEARCH.OCCURANCE)
*
      UNTIL FOUND.POS = 0 DO
         SEARCH.CTR = SEARCH.CTR + 1
         SEARCH.LINE.NUMBERS<-1> = REAL.LINE.NUMBER
         SEARCH.X.POSITIONS<-1> = FOUND.POS
      REPEAT
   NEXT REAL.LINE.NUMBER
*
   IF SEARCH.LINE.NUMBERS = '' AND NOT(INITIAL.SEARCH) THEN
      SEARCH.RESULTS.EXIST = FALSE
      ERROR.MESSAGE = 'No results for: "' : SEARCH.STRING : '"'
      PRINT BOTTOM : CLEAR.REST.OF.LINE :
      PRINT ERROR.MESSAGE :
      PRINT @(X.POS,Y.POS) :
   END
*
   INITIAL.SEARCH = FALSE
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GOTO.SEARCH.RESULT:NULL
*
   IF FORWARD.SEARCH THEN
      SEARCH.LINE = SEARCH.LINE.NUMBERS<SEARCH.POSITION>
*
      SEARCH.POSITION = SEARCH.POSITION + 1
*
      SEARCH.DONE = FALSE
*
      IF LINE.NUMBERS<CURRENT.LINE> < SEARCH.LINE THEN
         SEARCH.POSITION = 0
      END
*
      LOOP UNTIL SEARCH.DONE DO
         SEARCH.LINE = SEARCH.LINE.NUMBERS<SEARCH.POSITION>
*
         IF SEARCH.POSITION > DCOUNT(SEARCH.LINE.NUMBERS,@AM) THEN
            SEARCH.DONE = TRUE
         END ELSE IF LINE.NUMBERS<CURRENT.LINE> > SEARCH.LINE THEN
            SEARCH.POSITION = SEARCH.POSITION + 1
         END ELSE
            SEARCH.DONE = TRUE
         END
      REPEAT
*
   END ELSE
      SEARCH.LINE = SEARCH.LINE.NUMBERS<SEARCH.POSITION>
*
      SEARCH.POSITION = SEARCH.POSITION - 1
*
      SEARCH.DONE = FALSE
*
      IF LINE.NUMBERS<CURRENT.LINE> > SEARCH.LINE THEN
         SEARCH.POSITION = DCOUNT(SEARCH.LINE.NUMBERS,@AM)
      END
*
      LOOP UNTIL SEARCH.DONE DO
         SEARCH.LINE = SEARCH.LINE.NUMBERS<SEARCH.POSITION>
*
         IF SEARCH.POSITION < 1 THEN
            SEARCH.DONE = TRUE
         END ELSE IF LINE.NUMBERS<CURRENT.LINE> < SEARCH.LINE THEN
            SEARCH.POSITION = SEARCH.POSITION - 1
         END ELSE
            SEARCH.DONE = TRUE
         END
      REPEAT
*
   END
*
   IF SEARCH.POSITION > DCOUNT(SEARCH.LINE.NUMBERS,@AM) THEN
      PRINT BOTTOM : CLEAR.REST.OF.LINE :
      PRINT MESSAGE.COLOR :
      PRINT 'Search hit the bottom, starting from the top.' :
      SEARCH.POSITION = 1
   END
*
   IF SEARCH.POSITION < 1 THEN
      PRINT BOTTOM : CLEAR.REST.OF.LINE :
      PRINT MESSAGE.COLOR :
      PRINT 'Search hit the top, starting from the bottom.' :
      SEARCH.POSITION = DCOUNT(SEARCH.LINE.NUMBERS,@AM)
   END
*
   GOTO.LINE = SEARCH.LINE.NUMBERS<SEARCH.POSITION>
   FOUND.POS = SEARCH.X.POSITIONS<SEARCH.POSITION>
*
   GOSUB GOTO.LINE.POSITION
*
   IF FOUND.POS <= VIEW.WIDTH THEN
      X.POS = FOUND.POS + MARGIN.LEFT - 1
*
   END ELSE
      NUMBER.OF.LINES = INT(FOUND.POS / VIEW.WIDTH)
*
      X.POS = FOUND.POS - ((NUMBER.OF.LINES) * VIEW.WIDTH) + MARGIN.LEFT - 1
      Y.POS = Y.POS + NUMBER.OF.LINES
      CURRENT.LINE = CURRENT.LINE + NUMBER.OF.LINES
   END
*
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.INPUT:NULL
*
   INPUT.SEARCH.TRIGGERED = FALSE
   INPUT.SEARCH.TERM = ''
*
   INPUT.HISTORY.POS = DCOUNT(INPUT.HISTORY,@VM) + 1
*
   LOOP WHILE TRUE DO
      $IFDEF DATABASE.UV
         CHR = KEYIN()
      $ENDIF
*
      $IFDEF DATABASE.QM
         CHR = KEYIN()
      $ENDIF
*
      $IFDEF DATABASE.D3
         INPUT CHR,0
      $ENDIF
*
      ASCII.CODE = SEQ(CHR)
*
      IF ASCII.CODE = SEQ(KEY.ESCAPE) THEN
         GOSUB PROCESS.ESCAPE.KEY
*
         IF ESCAPE.SEQUENCE = LEFT.ARROW THEN
            IF INPUT.X.POS > 0 THEN
               INPUT.X.POS = INPUT.X.POS - 1
            END
         END ELSE IF ESCAPE.SEQUENCE = RIGHT.ARROW THEN
            IF INPUT.X.POS < LEN(INPUT.STRING) THEN
               INPUT.X.POS = INPUT.X.POS + 1
            END
         END ELSE IF ESCAPE.SEQUENCE = UP.ARROW THEN
            IF NOT(INPUT.SEARCH.TRIGGERED) THEN
               IF INPUT.HISTORY.POS > 1 THEN
                  INPUT.HISTORY.POS = INPUT.HISTORY.POS - 1
                  INPUT.STRING = INPUT.HISTORY<1,INPUT.HISTORY.POS>
                  INPUT.X.POS = LEN(INPUT.STRING)
               END
            END ELSE
               OLD.INPUT.HISTORY.POS = INPUT.HISTORY.POS
               INPUT.HISTORY.POS = INPUT.HISTORY.POS - 1
               IF INPUT.HISTORY.POS = 0 THEN INPUT.HISTORY.POS = 1
*
               LOOP
                  PREV.INPUT = INPUT.HISTORY<1, INPUT.HISTORY.POS>
                  INPUT.HISTORY.RESULT = INDEX(OCONV(PREV.INPUT,'MCU'),OCONV(INPUT.SEARCH.TERM,'MCU'),1)
               UNTIL (INPUT.HISTORY.POS <= 1 OR INPUT.HISTORY.RESULT # 0) DO
                  INPUT.HISTORY.POS = INPUT.HISTORY.POS - 1
               REPEAT
*
               IF INPUT.HISTORY.RESULT = 0 THEN
                  PREV.INPUT = INPUT.HISTORY<1, OLD.INPUT.HISTORY.POS>
                  INPUT.HISTORY.POS = OLD.INPUT.HISTORY.POS
               END
*
               INPUT.STRING = PREV.INPUT
               INPUT.X.POS = LEN(INPUT.STRING)
            END
*
         END ELSE IF ESCAPE.SEQUENCE = DOWN.ARROW THEN
            IF NOT(INPUT.SEARCH.TRIGGERED) THEN
               IF INPUT.HISTORY.POS < DCOUNT(INPUT.HISTORY,@VM) THEN
                  INPUT.HISTORY.POS = INPUT.HISTORY.POS + 1
                  INPUT.STRING = INPUT.HISTORY<1,INPUT.HISTORY.POS>
                  INPUT.X.POS = LEN(INPUT.STRING)
               END
*
            END ELSE
               OLD.INPUT.HISTORY.POS = INPUT.HISTORY.POS
               INPUT.HISTORY.LEN = DCOUNT(INPUT.HISTORY<1>,@VM)
               INPUT.HISTORY.POS = INPUT.HISTORY.POS + 1
*
               LOOP
                  NEXT.INPUT = INPUT.HISTORY<1, INPUT.HISTORY.POS>
                  INPUT.HISTORY.RESULT = INDEX(OCONV(NEXT.INPUT,'MCU'),OCONV(INPUT.SEARCH.TERM,'MCU'),1)
               UNTIL (INPUT.HISTORY.POS > INPUT.HISTORY.LEN OR INPUT.HISTORY.RESULT # 0) DO
                  INPUT.HISTORY.POS = INPUT.HISTORY.POS + 1
               REPEAT
*
               IF INPUT.HISTORY.RESULT = 0 THEN
                  NEXT.INPUT = INPUT.HISTORY<1, OLD.INPUT.HISTORY.POS>
                  INPUT.HISTORY.POS = OLD.INPUT.HISTORY.POS
               END
*
               INPUT.STRING = NEXT.INPUT
               INPUT.X.POS = LEN(INPUT.STRING)
            END
         END
*
      END ELSE IF ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) THEN
         EXIT
*
      END ELSE IF ASCII.CODE = SEQ(KEY.BACKSPACE) OR ASCII.CODE = SEQ(KEY.DELETE) THEN
         IF INPUT.X.POS <= 0 THEN
            EXIT
*
         END ELSE
            INPUT.STRING = INPUT.STRING[1,INPUT.X.POS-1] : INPUT.STRING[INPUT.X.POS+1,9999]
            INPUT.X.POS = INPUT.X.POS - 1
         END
*
      END ELSE
         INPUT.SEARCH.TRIGGERED = TRUE
         INPUT.STRING = INPUT.STRING[1,INPUT.X.POS] : CHR : INPUT.STRING[INPUT.X.POS+1,9999]
         INPUT.X.POS = INPUT.X.POS + 1
         INPUT.SEARCH.TERM = INPUT.STRING
      END
*
      PRINT BOTTOM : EDITOR.COLOR : INPUT.PROMPT : INPUT.STRING : CLEAR.REST.OF.LINE :
      PRINT @(INPUT.X.POS + INPUT.MARGIN.LEFT) :
   REPEAT
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GET.INSERT.CHAR.POS:NULL
*
   REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
   LOCATE(REAL.LINE.NUMBER,LINE.NUMBERS;LINE.START.POS) ELSE LINE.START.POS = CURRENT.LINE
*
   PREV.CTR = CURRENT.LINE - LINE.START.POS
   INSERT.CHAR.POSITION = (PREV.CTR * VIEW.WIDTH) + X.POS - MARGIN.LEFT
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.INSERT.LINE:NULL
*
   REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
   CURRENT.RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
   IF INSERT.LINE = '' THEN
      RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
      NUMBER.OF.SPACES = INDEX(RAW.LINE,TRIMF(RAW.LINE),1) - 1
      INSERT.LINE = SPACE(NUMBER.OF.SPACES)
      X.POS = NUMBER.OF.SPACES + MARGIN.LEFT
   END ELSE
      X.POS = MARGIN.LEFT
   END
*
   RAW.LINES = INSERT(RAW.LINES,REAL.LINE.NUMBER+1;INSERT.LINE)
   NEXT.LINE.NUMBER = REAL.LINE.NUMBER + 1
*
   UNDO.OP = 'INSERT.LINE'
   GOSUB PUSH.HISTORY
*
   IF LEN(CURRENT.RAW.LINE) < VIEW.WIDTH AND LEN(INSERT.LINE) < VIEW.WIDTH THEN
      LINES = INSERT(LINES,CURRENT.LINE+1;INSERT.LINE)
      LINE.NUMBERS = INSERT(LINE.NUMBERS,CURRENT.LINE+1;REAL.LINE.NUMBER)
*
      NUMBER.OF.LINES = DCOUNT(LINES,@AM)
*
* REAL.LINE.NUMBER INSERTED WILL GET BUMPED UP BY THE FOR LOOP
* FOR LOOP STARTS AT THE INSERTED POSITION TO THE END
*
      FOR J = CURRENT.LINE+1 TO NUMBER.OF.LINES
         LINE.NUMBERS<J> = LINE.NUMBERS<J> + 1
      NEXT J
   END ELSE
      GOSUB CONVERT.RAW.LINES
   END
*
   LOCATE(REAL.LINE.NUMBER,LINE.NUMBERS;LINE.START.POS) ELSE LINE.START.POS = 1
*
   TOTAL.LINES = 0
   NUMBER.OF.LINES = DCOUNT(LINES,@AM)
*
   FOR LS.POS = LINE.START.POS TO NUMBER.OF.LINES
      IF LINE.NUMBERS<LS.POS> = REAL.LINE.NUMBER THEN
         TOTAL.LINES = TOTAL.LINES + 1
      END ELSE
         EXIT
      END
   NEXT LS.POS
*
   LINES.TO.SKIP = TOTAL.LINES - (CURRENT.LINE - LINE.START.POS)
*
   Y.POS = Y.POS + LINES.TO.SKIP
*
   LOCATE(NEXT.LINE.NUMBER,LINE.NUMBERS;CURRENT.LINE) ELSE CURRENT.LINE = 1
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.DELETE.LINE:NULL
*
   IF INSIDE.VIEW.BUFFER THEN RETURN
*
   PRINT @(X.POS,Y.POS) :
*
   EDITOR.COMMAND = 'd'
*
   LOOP
      $IFDEF DATABASE.UV
         CHR = KEYIN()
      $ENDIF
*
      $IFDEF DATABASE.QM
         CHR = KEYIN()
      $ENDIF
*
      $IFDEF DATABASE.D3
         INPUT CHR,0
      $ENDIF
      ASCII.CODE = SEQ(CHR)
   UNTIL ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) OR NOT(NUM(CHR)) DO
      EDITOR.COMMAND = EDITOR.COMMAND : CHR
   REPEAT
*
   IF ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) OR EDITOR.COMMAND = 'd' THEN
      EDITOR.COMMAND.AVAILABLE = TRUE
      GOSUB PROCESS.EDITOR.COMMAND
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.INSERT:NULL
*
   IF INSIDE.VIEW.BUFFER THEN RETURN
*
   PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
   PRINT @(X.POS,Y.POS) :
*
   LOOP WHILE TRUE DO
      $IFDEF DATABASE.UV
         CHR = KEYIN()
      $ENDIF
*
      $IFDEF DATABASE.QM
         CHR = KEYIN()
      $ENDIF
*
      $IFDEF DATABASE.D3
         INPUT CHR,0
      $ENDIF
      ASCII.CODE = SEQ(CHR)
*
      IF ASCII.CODE = SEQ(KEY.CTRL.S) THEN
         IF OPEN.READONLY THEN
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
            PRINT 'This file is read only.' :
            PRINT @(X.POS,Y.POS) :
            RETURN
         END
*
         GOSUB SAVE.FILE
*
      END ELSE IF ASCII.CODE = SEQ(KEY.ESCAPE) THEN
         GOSUB PROCESS.ESCAPE.KEY
*
         IF ESCAPE.SEQUENCE = UP.ARROW THEN
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            GOSUB SCROLL.UP
            PRINT @(X.POS,Y.POS) :
            CONTINUE
*
         END ELSE IF ESCAPE.SEQUENCE = DOWN.ARROW THEN
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            GOSUB SCROLL.DOWN
            PRINT @(X.POS,Y.POS) :
            CONTINUE
*
         END ELSE IF ESCAPE.SEQUENCE = LEFT.ARROW THEN
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            GOSUB PRINT.CURRENT.LINE
            GOSUB SCROLL.LEFT
            PRINT @(X.POS,Y.POS) :
*
         END ELSE IF ESCAPE.SEQUENCE = RIGHT.ARROW THEN
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            GOSUB PRINT.CURRENT.LINE
            GOSUB SCROLL.RIGHT
            PRINT @(X.POS,Y.POS) :
*
         END ELSE
            IF CC.LIST.OPEN THEN
               CC.LIST.OPEN = FALSE
               GOSUB DISPLAY.LINES
            END
*
            PRINT BOTTOM : CLEAR.REST.OF.LINE :
            PRINT @(X.POS,Y.POS) :
            EXIT
         END
*
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
         PRINT @(X.POS,Y.POS) :
         CONTINUE
*
      END ELSE IF ASCII.CODE = SEQ(KEY.TAB) THEN
         REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         UNDO.OP = 'CHANGE'
         GOSUB PUSH.HISTORY
*
         GOSUB GET.INSERT.CHAR.POS
*
         RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION] : SPACE(TAB.SIZE) : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
         RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
         GOSUB UPDATE.LINE
*
         GOSUB PRINT.CURRENT.LINE
*
         X.POS = X.POS + TAB.SIZE
         IF X.POS > SCREEN.WIDTH - MARGIN.RIGHT THEN
            X.POS = MARGIN.LEFT + 1
            Y.POS = Y.POS + 1
            CURRENT.LINE = CURRENT.LINE + 1
         END
*
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF ASCII.CODE = SEQ(KEY.BACKSPACE) OR ASCII.CODE = SEQ(KEY.DELETE) THEN
         IF X.POS > MARGIN.LEFT THEN
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
            UNDO.OP = 'CHANGE'
            GOSUB PUSH.HISTORY
*
            GOSUB GET.INSERT.CHAR.POS
*
            DELETE.CHAR = RAW.LINE[INSERT.CHAR.POSITION,1]
*
            IF CC.LIST.OPEN THEN
               CC.LIST.OPEN = FALSE
               GOSUB DISPLAY.LINES
            END
*
            DELETE.TAB = FALSE
*
            IF DELETE.CHAR = ' ' AND INSERT.CHAR.POSITION >= TAB.SIZE THEN
               TAB.TEST = RAW.LINE[INSERT.CHAR.POSITION-TAB.SIZE,TAB.SIZE]
               TAB.TEST = TRIMF(TRIMB(TAB.TEST))
               IF TAB.TEST = '' THEN DELETE.TAB = TRUE
            END
*
            RAW.LINE.LEN = LEN(RAW.LINE)
*
            IF DELETE.TAB THEN
               RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION-TAB.SIZE] : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
               X.POS = X.POS - TAB.SIZE
            END ELSE
               RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION-1] : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
               X.POS = X.POS - 1
            END
*
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
            GOSUB UPDATE.LINE
            GOSUB PRINT.CURRENT.LINE
*
         END ELSE IF Y.POS > 1 THEN
            PREV.LINE = CURRENT.LINE - 1
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            PREV.LINE.NUMBER = LINE.NUMBERS<PREV.LINE>
*
            IF REAL.LINE.NUMBER = PREV.LINE.NUMBER THEN
               GOSUB GET.INSERT.CHAR.POS
*
               RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
               RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION-1] : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
               RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
               GOSUB CONVERT.RAW.LINES
               GOSUB DISPLAY.LINES
*
               X.POS = SCREEN.WIDTH - MARGIN.RIGHT - 1
               Y.POS = Y.POS - 1
               CURRENT.LINE = CURRENT.LINE - 1
*
            END ELSE
               RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
               PREV.LINE = RAW.LINES<PREV.LINE.NUMBER>
*
               NUMBER.OF.LINES = INT(LEN(PREV.LINE) / VIEW.WIDTH)
*
               IF NUMBER.OF.LINES = 1 THEN
                  X.POS = SCREEN.WIDTH - MARGIN.RIGHT
               END ELSE
                  X.POS = (LEN(PREV.LINE) - (NUMBER.OF.LINES * VIEW.WIDTH)) + MARGIN.LEFT
               END
*
               Y.POS = Y.POS - 1
               CURRENT.LINE = CURRENT.LINE - 1
*
               RAW.LINES = DELETE(RAW.LINES,REAL.LINE.NUMBER)
               RAW.LINES<PREV.LINE.NUMBER> = PREV.LINE : RAW.LINE
            END
*
            GOSUB CONVERT.RAW.LINES
            GOSUB DISPLAY.LINES
         END
*
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE IF ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) THEN
         REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
         NEXT.LINE.NUMBER = REAL.LINE.NUMBER+1
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         NUMBER.OF.SPACES = INDEX(RAW.LINE,TRIMF(RAW.LINE),1) - 1
         IF NUMBER.OF.SPACES < 1 THEN NUMBER.OF.SPACES = 0
*
         UNDO.OP = 'CHANGE'
         GOSUB PUSH.HISTORY
*
         GOSUB GET.INSERT.CHAR.POS
*
         IF CC.LIST.OPEN THEN
            CC.WORD = CC.LIST<CC.POS,1>
            CC.DESCRIPTION = CC.LIST<CC.POS,2>
            CC.STRUCTURE = CC.LIST<CC.POS,3>
*
            IF CC.STRUCTURE # '' THEN
               L = RAW.LINE[1,INSERT.CHAR.POSITION-CC.TRIGGER.LEN] : CC.STRUCTURE<1,1,1> : RAW.LINE[INSERT.CHAR.POSITION+1,999]
               RAW.LINES<REAL.LINE.NUMBER> = L
               INSERT.POS = REAL.LINE.NUMBER
               FOR CC.LINE.CTR = 2 TO DCOUNT(CC.STRUCTURE,@SVM)
                  INSERT.POS = INSERT.POS + 1
                  INSERT.LINE = SPACE(NUMBER.OF.SPACES) : CC.STRUCTURE<1,1,CC.LINE.CTR>
*
                  UNDO.OP = 'INSERT.LINE'
                  GOSUB PUSH.HISTORY
*
                  RAW.LINES = INSERT(RAW.LINES,INSERT.POS;INSERT.LINE)
               NEXT CC.LINE.CTR
            END ELSE
               L = RAW.LINE[1,INSERT.CHAR.POSITION-CC.TRIGGER.LEN] : CC.WORD : RAW.LINE[INSERT.CHAR.POSITION+1,999]
               RAW.LINES<REAL.LINE.NUMBER> = L
            END
*
            CC.LIST.OPEN = FALSE
*
            GOSUB CONVERT.RAW.LINES
            GOSUB DISPLAY.LINES
*
            X.POS = X.POS + LEN(CC.WORD) - CC.TRIGGER.LEN
*
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            PRINT @(X.POS,Y.POS) :
*
            CONTINUE
         END
*
         ORIGINAL.LINE = RAW.LINE[1,INSERT.CHAR.POSITION]
         INSERT.LINE = SPACE(NUMBER.OF.SPACES) : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
*
         UNDO.OP = 'INSERT.LINE'
         GOSUB PUSH.HISTORY
*
         RAW.LINES<REAL.LINE.NUMBER> = ORIGINAL.LINE
         RAW.LINES = INSERT(RAW.LINES,REAL.LINE.NUMBER+1;INSERT.LINE)
*
         GOSUB CC.TOKENIZE.LINE
*
         CURRENT.LINE = CURRENT.LINE + 1
*
         X.POS = MARGIN.LEFT + NUMBER.OF.SPACES
         Y.POS = Y.POS + 1
*
         IF Y.POS > VIEW.HEIGHT THEN
            LINE.START = LINE.START + 1
            Y.POS = VIEW.HEIGHT
         END
*
         GOSUB CONVERT.RAW.LINES
         GOSUB DISPLAY.LINES
*
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE
         REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         UNDO.OP = 'CHANGE'
         GOSUB PUSH.HISTORY
*
         GOSUB GET.INSERT.CHAR.POS
*
         RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION] : CHR : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
         RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
         LOCATE(CHR,CC.BREAK.CHARACTERS;BREAK.POS) THEN
            IF CC.LIST.OPEN THEN
               CC.LIST.OPEN = FALSE
               GOSUB DISPLAY.LINES
            END
         END
*
         IF CHR = ' ' THEN
            GOSUB CC.TOKENIZE.LINE
         END ELSE
            LOCATE(CHR,CC.BREAK.CHARACTERS;ANYPOS) THEN
               GOSUB CC.TOKENIZE.LINE
            END
         END
*
         GOSUB UPDATE.LINE
*
         X.POS = X.POS + 1
         FORCE.REDRAW = FALSE
*
         IF X.POS > SCREEN.WIDTH - MARGIN.RIGHT THEN
            X.POS = MARGIN.LEFT + 1
            Y.POS = Y.POS + 1
            IF Y.POS > VIEW.HEIGHT THEN
               LINE.START = LINE.START + 1
               Y.POS = VIEW.HEIGHT
            END
            CURRENT.LINE = CURRENT.LINE + 1
            FORCE.REDRAW = TRUE
         END
*
         LINE = LINES<CURRENT.LINE>
         CURRENT.WORD = ''
         CURSOR.POSITION = X.POS - MARGIN.LEFT
*
         IF CURSOR.POSITION > 1 THEN
            FOR CC.WORD.START = CURSOR.POSITION TO 1 STEP -1
               CHARACTER = LINE[CC.WORD.START,1]
               LOCATE(CHARACTER,CC.BREAK.CHARACTERS;BREAK.POS) THEN
                  EXIT
               END
               CURRENT.WORD = CHARACTER : CURRENT.WORD
            NEXT CC.WORD.START
         END
*
         IF CURRENT.WORD = '' OR LEN(CURRENT.WORD) < 2 THEN
            CC.LIST.OPEN = FALSE
            CC.LIST = ''
*
         END ELSE
            IF CURRENT.WORD[1,1] = '/' THEN
               SEARCH.PATH = CURRENT.WORD[1,INDEX(CURRENT.WORD,'/',COUNT(CURRENT.WORD,'/'))]
               SEARCH.WORD = CURRENT.WORD[LEN(SEARCH.PATH)+1,9999]
*
               $IFDEF PLATFORM.LINUX
                  STATEMENT = 'SH -c "ls -ap ' : SEARCH.PATH : ' | grep ^' : SEARCH.WORD  : '"'
                  EXECUTE STATEMENT CAPTURING RESULTS
               $ENDIF
*
               $IFDEF PLATFORM.WINDOWS
                  RESULTS = ''
               $ENDIF
*
               RECORDS.SELECTED = DCOUNT(RESULTS,@AM)
*
               LIST.OF.FILES = ''
*
               FOR RESULT.CTR = 1 TO RECORDS.SELECTED
                  RESULT.FILE = RESULTS<RESULT.CTR>
*
                  IF RESULT.FILE[LEN(RESULT.FILE),1] = '/' THEN
                     RESULT.FILE = RESULT.FILE[1,LEN(RESULT.FILE)-11]
                  END
*
                  IF RESULT.FILE # '' THEN
                     LIST.OF.FILES<RESULT.CTR,1> = SEARCH.PATH : RESULT.FILE
                     LIST.OF.FILES<RESULT.CTR,2> = SEARCH.PATH : RESULT.FILE
                  END
               NEXT RESULT.CTR
*
               CC.LIST = LIST.OF.FILES
*
            END ELSE
               CC.LIST = ''
               FOR LIST.CTR = 1 TO DCOUNT(SNIPPETS,@AM)
                  IF INDEX(OCONV(SNIPPETS<LIST.CTR,1>,'MCU'),OCONV(CURRENT.WORD,'MCU'),1) = 1 THEN
                     CC.LIST<-1> = SNIPPETS<LIST.CTR>
                  END
               NEXT LIST.CTR
            END
         END
*
         IF DCOUNT(CC.LIST,@AM) > 0 AND Y.POS < (VIEW.HEIGHT+MARGIN.TOP - DCOUNT(CC.LIST,@AM)-MARGIN.BOTTOM) THEN
            CC.LIST.OPEN = TRUE
            CC.POS = 1
            CC.START.LINE = 1
            CC.TRIGGER.LEN = LEN(CURRENT.WORD)
*
            LINE.FROM = CURRENT.LINE
            LINE.TO = CURRENT.LINE + MAX.SUGGESTIONS + 1
*
            IF LINE.TO > DCOUNT(LINES,@AM) THEN
               GOSUB DISPLAY.LINES
            END ELSE
               LINE.Y.POS = Y.POS
               GOSUB DISPLAY.LINES.FROM.TO
            END
*
            GOSUB DISPLAY.CC.LIST
*
         END ELSE IF CC.LIST.OPEN THEN
            CC.LIST.OPEN = FALSE
            GOSUB DISPLAY.LINES
*
         END ELSE
            GOSUB PRINT.CURRENT.LINE
*
            IF FORCE.REDRAW THEN
               GOSUB DISPLAY.LINES
            END
         END
*
         PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
         PRINT @(X.POS,Y.POS) :
      END
*
   REPEAT
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.DELETE.CHARACTER:NULL
*
   IF INSIDE.VIEW.BUFFER THEN RETURN
*
   REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
   RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
   UNDO.OP = 'CHANGE'
   GOSUB PUSH.HISTORY
*
   GOSUB GET.INSERT.CHAR.POS
*
   RAW.LINE.LEN = LEN(RAW.LINE)
*
   RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION] : RAW.LINE[INSERT.CHAR.POSITION+2,9999]
   RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
   GOSUB UPDATE.LINE
*
   GOSUB PRINT.CURRENT.LINE
*
   IF X.POS # MARGIN.LEFT AND X.POS = MARGIN.LEFT + LEN(LINES<CURRENT.LINE>) THEN
      X.POS = X.POS - 1
   END
*
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.REPLACE.CHARACTER:NULL
*
   $IFDEF DATABASE.UV
      CHR = KEYIN()
   $ENDIF
*
   $IFDEF DATABASE.QM
      CHR = KEYIN()
   $ENDIF
*
   $IFDEF DATABASE.D3
      INPUT CHR,0
   $ENDIF
*
   REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
   RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
   UNDO.OP = 'CHANGE'
   GOSUB PUSH.HISTORY
*
   GOSUB GET.INSERT.CHAR.POS
*
   RAW.LINE[INSERT.CHAR.POSITION+1,1] = CHR
   RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
   GOSUB UPDATE.LINE
*
   GOSUB PRINT.CURRENT.LINE
*
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SCROLL.UP:NULL
*
   IF CC.LIST.OPEN THEN
      IF CC.POS > 1 THEN
         IF CC.POS <= CC.START.LINE THEN
            CC.START.LINE = CC.START.LINE - 1
         END
         CC.POS = CC.POS - 1
         GOSUB DISPLAY.CC.LIST
      END
      RETURN
   END
*
   GOSUB PRINT.CURRENT.LINE
*
   IF CURRENT.LINE = 1 THEN
      RETURN
   END
*
   IF Y.POS > MARGIN.TOP THEN
      CURRENT.LINE = CURRENT.LINE - 1
      Y.POS = Y.POS - 1
   END ELSE
      LINE.START = LINE.START - 1
      CURRENT.LINE = CURRENT.LINE - 1
      LINE = LINES<CURRENT.LINE>
      LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
*
      $IFDEF DATABASE.UV
         PRINT @(-49) :
         GOSUB PRINT.CURRENT.LINE
      $ENDIF
*
      $IFDEF DATABASE.QM
         PRINT @(-17) :
         GOSUB PRINT.CURRENT.LINE
      $ENDIF
*
      $IFDEF DATABASE.D3
         PRINT @(-106)
         GOSUB PRINT.CURRENT.LINE
      $ENDIF
   END
*
   GOSUB SET.X.POS
   GOSUB DISPLAY.HEADER
   PRINT @(X.POS, Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SCROLL.DOWN:NULL
*
   IF CC.LIST.OPEN THEN
      IF CC.POS < DCOUNT(CC.LIST,@AM) THEN
         IF CC.POS > MAX.SUGGESTIONS THEN
            CC.START.LINE = CC.START.LINE + 1
         END
         CC.POS = CC.POS + 1
         GOSUB DISPLAY.CC.LIST
      END
      RETURN
   END
*
   IF CURRENT.LINE >= DCOUNT(LINES,@AM) THEN
      RETURN
   END
*
   IF Y.POS < VIEW.HEIGHT THEN
      CURRENT.LINE = CURRENT.LINE + 1
      Y.POS = Y.POS + 1
   END ELSE
      LINE.START = LINE.START + 1
      CURRENT.LINE = CURRENT.LINE + 1
      LINE = LINES<CURRENT.LINE>
      LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
*
      $IFDEF DATABASE.UV
         PRINT @(-48) :
         GOSUB PRINT.CURRENT.LINE
      $ENDIF
*
      $IFDEF DATABASE.QM
         PRINT
         PRINT
         GOSUB PRINT.CURRENT.LINE
      $ENDIF
*
      $IFDEF DATABASE.D3
         PRINT
         PRINT
         GOSUB PRINT.CURRENT.LINE
      $ENDIF
   END
*
   GOSUB SET.X.POS
   GOSUB DISPLAY.HEADER
   PRINT @(X.POS, Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SCROLL.RIGHT:NULL
*
   IF CC.LIST.OPEN THEN
      CC.LIST.OPEN = FALSE
      GOSUB DISPLAY.LINES
   END
*
   LINE.LEN = LEN(LINES<CURRENT.LINE>)
   IF X.POS + 1 >= LINE.LEN + MARGIN.LEFT+1 THEN
      PRINT @(X.POS, Y.POS) :
      RETURN
   END
*
   IF X.POS > SCREEN.WIDTH - MARGIN.RIGHT THEN
      PRINT @(X.POS, Y.POS) :
      RETURN
   END
*
   ORIGINAL.X.POS = 0
   X.POS = X.POS + 1
*
   GOSUB DISPLAY.HEADER
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SCROLL.LEFT:NULL
*
   IF CC.LIST.OPEN THEN
      CC.LIST.OPEN = FALSE
      GOSUB DISPLAY.LINES
   END
*
   IF X.POS - 1 < MARGIN.LEFT THEN
      PRINT @(X.POS, Y.POS) :
      RETURN
   END
*
   ORIGINAL.X.POS = 0
   X.POS = X.POS - 1
*
   GOSUB DISPLAY.HEADER
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PASTE.BLOCK:NULL
*
   IF PASTE.NEWLINE THEN
      NUMBER.OF.YANKED.LINES = DCOUNT(YANKED.LINES,@VM)
*
      OFFSET = VIEW.HEIGHT - Y.POS
      TRUE.NUMBER.OF.YANKED.LINES = 0
*
      FOR PASTE.CTR = 1 TO NUMBER.OF.YANKED.LINES
         INSERT.LINE = YANKED.LINES<1,PASTE.CTR>
         TRUE.NUMBER.OF.YANKED.LINES = TRUE.NUMBER.OF.YANKED.LINES + INT(LEN(INSERT.LINE) / VIEW.WIDTH) + 1
         GOSUB PROCESS.INSERT.LINE
      NEXT PASTE.CTR
*
      IF Y.POS > VIEW.HEIGHT THEN
         LINE.START = LINE.START + TRUE.NUMBER.OF.YANKED.LINES - OFFSET
         Y.POS = VIEW.HEIGHT
      END
*
      GOSUB DISPLAY.LINES
      PRINT @(X.POS,Y.POS) :
*
   END ELSE
      REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
      RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
      UNDO.OP = 'CHANGE'
      GOSUB PUSH.HISTORY
*
      GOSUB GET.INSERT.CHAR.POS
*
      RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION+1] : YANKED.LINES : RAW.LINE[INSERT.CHAR.POSITION+2,9999]
      RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
      GOSUB UPDATE.LINE
      GOSUB DISPLAY.LINES
*
      PRINT @(X.POS,Y.POS) :
   END
*
   RETURN
*
*
*********************  S U B R O U T I N E  *********************
*
DROP.BLOCK:NULL
*
   IF BLOCK.END < BLOCK.START THEN
      PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
      PRINT 'Cannot drop from ' : BLOCK.START : ' to ' : BLOCK.END : '.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   LOCATE(BLOCK.START,LINE.NUMBERS;REAL.BLOCK.START) ELSE REAL.BLOCK.START = 1
   LOCATE(BLOCK.END,LINE.NUMBERS;REAL.BLOCK.END) ELSE REAL.BLOCK.END = 1
*
   FOR EDITOR.CTR = REAL.BLOCK.START TO REAL.BLOCK.END
      IF DCOUNT(RAW.LINES,@AM) = 0 THEN
         PRINT BOTTOM : CLEAR.REST.OF.LINE :
         PRINT @(X.POS,Y.POS) :
*
      END ELSE
         REAL.LINE.NUMBER = LINE.NUMBERS<REAL.BLOCK.START>
         RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
         UNDO.OP = 'DELETE.LINE'
         GOSUB PUSH.HISTORY
*
         RAW.LINES = DELETE(RAW.LINES,REAL.LINE.NUMBER)
         IF Y.POS > 1 THEN
            Y.POS = Y.POS - 1
            CURRENT.LINE = CURRENT.LINE - 1
         END
*
         IF DCOUNT(RAW.LINES,@AM) = 0 THEN
            RAW.LINES<-1> = ''
            LINES = ''
            LINE.NUMBERS = 1
         END
      END
   NEXT EDITOR.CTR
*
   GOSUB CONVERT.RAW.LINES
   GOSUB DISPLAY.LINES
*
   X.POS = MARGIN.LEFT
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SAVE.FILE:NULL
*
   IF UP.CARET.MODE THEN
      PRINT BOTTOM : CLEAR.REST.OF.LINE :
      PRINT MESSAGE.COLOR :
      PRINT 'Cannot save in up-arrow mode.' : CLEAR.REST.OF.LINE :
*
   END ELSE IF INSIDE.VIEW.BUFFER THEN
      PRINT BOTTOM : CLEAR.REST.OF.LINE :
      PRINT MESSAGE.COLOR :
      PRINT 'Cannot save inside a view buffer.' : CLEAR.REST.OF.LINE :
*
   END ELSE IF NEST.LEVEL # 0 THEN
      SAVE.ROW = TRUE
      GOSUB POP.EXPLODE
*
   END ELSE
      UNDO.STACK.MATRIX = ''
*
      FOR UNDO.CTR = 1 TO UNDO.PTR
         $IFDEF DATABASE.UV
            LOWERED.RECORD = LOWER(UNDO.STACK(UNDO.CTR))
         $ENDIF
*
         $IFDEF DATABASE.QM
            LOWERED.RECORD = LOWER(UNDO.STACK(UNDO.CTR))
         $ENDIF
*
         $IFDEF DATABASE.D3
            LOWERED.RECORD = UNDO.STACK(UNDO.CTR)
            CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
         $ENDIF
         UNDO.STACK.MATRIX<-1> = LOWERED.RECORD
      NEXT UNDO.CTR
*
* CHECK IF FILE HAS CHANGED SINCE OPENING
*
      ORIGINAL.CHECKSUM = CURRENT.CHECKSUM
*
      IF IS.UNIVERSE.FILE THEN
         READ CHECK.LINES FROM FILE,RECORD.ID ELSE CHECK.LINES = ''
*
      END ELSE
         $IFDEF DATABASE.UV
            $IFDEF PLATFORM.LINUX
               IF CREATE.NEW.OS.FILE THEN
                  CHECK.LINES = ''
               END ELSE
                  OPENSEQ FILENAME TO FLAT.FILE THEN
                     READBLK CHECK.LINES FROM FLAT.FILE, 100000000 THEN
                        RELEASE FLAT.FILE
                        CLOSESEQ FLAT.FILE
                     END
                     CHECK.LINES = CHECK.LINES[1,LEN(CHECK.LINES)-1]
                     CHECK.LINES = CHANGE(CHECK.LINES,CHAR(10),@AM)
                  END
               END
            $ENDIF
         $ENDIF
      END
*
      $IFDEF DATABASE.UV
         DIRTY.CHECKSUM = CHECKSUM(CHECK.LINES)
      $ENDIF
*
      $IFDEF DATABASE.QM
         DIRTY.CHECKSUM = CHECKSUM(CHECK.LINES)
      $ENDIF
*
      $IFDEF DATABASE.D3
         DIRTY.CHECKSUM = OCONV(CHECK.LINES,'u001e')
      $ENDIF
*
      IF ORIGINAL.CHECKSUM # DIRTY.CHECKSUM THEN
         PRINT BOTTOM : CLEAR.REST.OF.LINE :
         PRINT MESSAGE.COLOR :
         PRINT 'File has changed since originally reading it. Are you sure you want to save? (y/n) ' :
*
         INPUT ANS :
         IF ANS # 'Y' THEN
            RETURN
         END
      END
*
* SAVE CHECKSUM AND UNDO.STACK
*
      $IFDEF DATABASE.UV
         CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
      $ENDIF
*
      $IFDEF DATABASE.QM
         CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
      $ENDIF
*
      $IFDEF DATABASE.D3
         CURRENT.CHECKSUM = OCONV(RAW.LINES,'u001e')
      $ENDIF
*
      READ CHECKSUM.MATRIX FROM EVA.HISTORY.FILE,'CHECKSUM' ELSE CHECKSUM.MATRIX = ''
*
      LOCATE(FULL.NAME,CHECKSUM.MATRIX<1>,1;CHECKSUM.POS) THEN
         CHECKSUM.MATRIX<2,CHECKSUM.POS> = CURRENT.CHECKSUM
      END ELSE
         CHECKSUM.MATRIX<1,-1> = FULL.NAME
         CHECKSUM.MATRIX<2,-1> = CURRENT.CHECKSUM
      END
*
      WRITE CHECKSUM.MATRIX ON EVA.HISTORY.FILE,'CHECKSUM'
      WRITE UNDO.STACK.MATRIX ON EVA.HISTORY.FILE,UNDO.FILE.NAME
*
* SAVE FILE
*
      ORIGINAL.RAW.LINES = RAW.LINES
*
      IF IS.UNIVERSE.FILE THEN
         WRITEU RAW.LINES ON FILE, RECORD.ID
*
      END ELSE
         $IFDEF DATABASE.UV
            $IFDEF PLATFORM.LINUX
               OPENSEQ FILENAME TO FLAT.FILE ELSE
                  CREATE FLAT.FILE ELSE
                     PRINT BOTTOM : CLEAR.REST.OF.LINE :
                     PRINT MESSAGE.COLOR :
                     PRINT 'Unable to open/create OS file: ' : FILENAME :
                     PRINT @(X.POS,Y.POS) :
                     RETURN
                  END
               END
*
               WEOFSEQ FLAT.FILE
*
               FILE.LINES = CHANGE(RAW.LINES,@AM,CHAR(10))
               WRITESEQ FILE.LINES ON FLAT.FILE ELSE NULL
*
               FLUSH FLAT.FILE ELSE NULL
               CLOSESEQ FLAT.FILE
            $ENDIF
         $ENDIF
      END
*
      PRINT BOTTOM : CLEAR.REST.OF.LINE :
      PRINT MESSAGE.COLOR :
*
      IF IS.UNIVERSE.FILE THEN
         PRINT FILENAME : ' ' : RECORD.ID : ' saved.' : CLEAR.REST.OF.LINE :
      END ELSE
         PRINT FILENAME : ' saved.' : CLEAR.REST.OF.LINE :
      END
*
      PRINT @(X.POS,Y.POS) :
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
COMPILE.FILE:NULL
*
   IF INSIDE.VIEW.BUFFER THEN RETURN
*
   IF FILETYPE # 'BASIC' THEN RETURN
*
   $IFDEF DATABASE.UV
      EXECUTE 'BASIC ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
   $ENDIF
*
   $IFDEF DATABASE.QM
      EXECUTE 'BASIC ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
   $ENDIF
*
   $IFDEF DATABASE.D3
      EXECUTE 'COMPILE ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
   $ENDIF
*
   IF RESULTS<3> = '' OR INDEX(RESULTS,'no errors',1) > 0 THEN
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT OCONV(TIME(),'MTS') : ': Finished compiling ' : RECORD.ID :
      PRINT @(X.POS,Y.POS) :
*
   END ELSE
      PRINT CLEAR.SCREEN :
      PRINT @(0,MARGIN.TOP) :
      PRINT OCONV(TIME(),'MTS') : ': ' :
      PRINT 'Error -----------------'
      PRINT
*
      FOR J = 1 TO DCOUNT(RESULTS,@AM)
         PRINT RESULTS<J>
      NEXT J
      INPUT ANYTHING :
*
      GOSUB DISPLAY.LINES
      PRINT @(X.POS,Y.POS) :
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
FORMAT.HTML:NULL
*
   HTML.FIRST.WORDS.INC = 'a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,button,canvas,caption,center,cite,code,col,colgroup,content,data,datalist,dd,decorator,del,details,dfn,dir,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,html,i,iframe,ins,isindex,kbd,keygen,label,legend,li,listing,main,map,mark,marquee,menu,menuitem,meter,nav,nobr,noframes,noscript,object,ol,optgroup,option,output,p,param,plaintext,pre,progress,q,rp,rt,ruby,s,samp,script,section,select,shadow,small,source,spacer,span,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp'
*
   MORE.HTML.WORDS = HTML.FIRST.WORDS.INC
   CONVERT '>' TO '' IN MORE.HTML.WORDS
   HTML.FIRST.WORDS.INC = HTML.FIRST.WORDS.INC : ',' : MORE.HTML.WORDS
*
   HTML.FIRST.WORDS.DEC = '/a,/abbr,/acronym,/address,/applet,/area,/article,/aside,/audio,/b,/base,/basefont,/bdi,/bdo,/bgsound,/big,/blink,/blockquote,/body,/button,/canvas,/caption,/center,/cite,/code,/col,/colgroup,/content,/data,/datalist,/dd,/decorator,/del,/details,/dfn,/dir,/div,/dl,/dt,/element,/em,/embed,/fieldset,/figcaption,/figure,/font,/footer,/form,/frame,/frameset,/h1,/h2,/h3,/h4,/h5,/h6,/head,/header,/hgroup,/hr,/html,/i,/iframe,/img,/ins,/isindex,/kbd,/keygen,/label,/legend,/li,/listing,/main,/map,/mark,/marquee,/menu,/menuitem,/meter,/nav,/nobr,/noframes,/noscript,/object,/ol,/optgroup,/option,/output,/p,/param,/plaintext,/pre,/progress,/q,/rp,/rt,/ruby,/s,/samp,/script,/section,/select,/shadow,/small,/source,/spacer,/span,/strike,/strong,/style,/sub,/summary,/sup,/table,/tbody,/td,/template,/textarea,/tfoot,/th,/thead,/time,/title,/tr,/track,/tt,/u,/ul,/var,/video,/wbr,/xmp'
*
   FIRST.WORDS.INC = 'FOR,IF,' : HTML.FIRST.WORDS.INC
   CONVERT ',' TO @AM IN FIRST.WORDS.INC
*
   LAST.WORDS.INC = 'THEN,ELSE'
   CONVERT ',' TO @AM IN LAST.WORDS.INC
*
   FIRST.WORDS.DEC = 'NEXT,END,NEXT,' : HTML.FIRST.WORDS.DEC
   CONVERT ',' TO @AM IN FIRST.WORDS.DEC
*
   LAST.WORDS.DEC = HTML.FIRST.WORDS.DEC
   CONVERT ',' TO @AM IN LAST.WORDS.DEC
*
   START.INDENT = -1
   GOSUB FORMAT.FILE
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
FORMAT.BASIC:NULL
*
   FIRST.WORDS.INC = 'FOR,CASE,$IFDEF'
   CONVERT ',' TO @AM IN FIRST.WORDS.INC
*
   LAST.WORDS.INC = 'THEN,ELSE,LOCKED,DO,LOOP,TRANSACTION'
   CONVERT ',' TO @AM IN LAST.WORDS.INC
*
   FIRST.WORDS.DEC = 'END,WHILE,UNTIL,REPEAT,CASE,NEXT,$ENDIF'
   CONVERT ',' TO @AM IN FIRST.WORDS.DEC
*
   LAST.WORDS.DEC = ''
   CONVERT ',' TO @AM IN LAST.WORDS.DEC
*
   START.INDENT = 0
   GOSUB FORMAT.FILE
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
FORMAT.FILE:NULL
*
   FMT.LINES = ''
   INDENT.LEVEL = 1
*
   NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
   FOR FMT.CTR = 1 TO NUMBER.OF.RAW.LINES
      TRIMMED.LINE = TRIMB(TRIMF(RAW.LINES<FMT.CTR>))
*
      IF TRIMMED.LINE[1,1] = '*' OR (INDEX(TRIMMED.LINE,':NULL',1) # 0 AND INDEX(TRIMMED.LINE,'"',1) = 0 AND INDEX(TRIMMED.LINE,"'",1) = 0) THEN
         FMT.LINES<FMT.CTR> = TRIMMED.LINE
         CONTINUE
      END
*
      IF FILETYPE = 'HTML' THEN
         WORKING.LINE = TRIMMED.LINE
         CONVERT '<' TO ' ' IN WORKING.LINE
         CONVERT '>' TO ' ' IN WORKING.LINE
         WORKING.LINE = CHANGE(WORKING.LINE,'{{','')
         WORKING.LINE = CHANGE(WORKING.LINE,'}}','')
         WORKING.LINE = TRIMB(TRIMF(WORKING.LINE))
*
      END ELSE
         WORKING.LINE = TRIMMED.LINE
      END
*
      FIRST.WORD = FIELD(WORKING.LINE,' ',1)
      LAST.WORD = FIELD(WORKING.LINE,' ',DCOUNT(WORKING.LINE,' '))
*
      IF WORKING.LINE = 'END CASE' THEN
         INDENT.LEVEL = INDENT.LEVEL - 2
         IF INDENT.LEVEL = 0 THEN INDENT.LEVEL = 1
*
      END ELSE
         LOCATE(FIRST.WORD,FIRST.WORDS.DEC;LAST.ANYPOS) THEN
            INDENT.LEVEL = INDENT.LEVEL - 1
            IF INDENT.LEVEL = 0 THEN INDENT.LEVEL = 1
         END
      END
*
      FMT.LINE = SPACE((INDENT.LEVEL+START.INDENT) * TAB.SIZE) : TRIMMED.LINE
      FMT.LINES<FMT.CTR> = FMT.LINE
*
      LOCATE(LAST.WORD,LAST.WORDS.INC;LAST.ANYPOS) THEN
         LOCATE(FIRST.WORD,FIRST.WORDS.INC;ANYPOS) ELSE
            INDENT.LEVEL = INDENT.LEVEL + 1
         END
      END
*
      LOCATE(FIRST.WORD,FIRST.WORDS.INC;ANYPOS) THEN
         LOCATE(LAST.WORD,LAST.WORDS.DEC;LAST.ANYPOS) ELSE
            INDENT.LEVEL = INDENT.LEVEL + 1
         END
      END
*
      IF WORKING.LINE = 'BEGIN CASE' THEN
         INDENT.LEVEL = INDENT.LEVEL + 2
      END
   NEXT FMT.CTR
*
   RAW.LINES = FMT.LINES
*
   GOSUB CONVERT.RAW.LINES
   GOSUB DISPLAY.LINES
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.CC.LIST:NULL
*
   NUMBER.OF.SUGGESTIONS = DCOUNT(CC.LIST,@AM)
*
   CC.END.LINE = CC.START.LINE + MAX.SUGGESTIONS
*
   IF CC.END.LINE > NUMBER.OF.SUGGESTIONS THEN
      CC.END.LINE = NUMBER.OF.SUGGESTIONS
   END
*
   CTR = 1
   FOR CC.CTR = CC.START.LINE TO CC.END.LINE
      PRINT @(X.POS-CC.TRIGGER.LEN,Y.POS+CTR) :
      CTR = CTR + 1
      CC.WORD = CC.LIST<CC.CTR,1>
      CC.DESCRIPTION = CC.LIST<CC.CTR,2>
      CC.STRUCTURE = CC.LIST<CC.CTR,3>
*
      IF CC.STRUCTURE = '' THEN
         CC.TYPE = ' [A] ' : CC.CTR : '/' : NUMBER.OF.SUGGESTIONS : ' '
      END ELSE
         CC.TYPE = '~[S] ' : CC.CTR : '/' : NUMBER.OF.SUGGESTIONS : ' '
      END
*
      IF CC.CTR = CC.POS THEN
         PRINT BACKGROUND.RED :
         PRINT RAW.WHITE :
         PRINT ' ' : CC.WORD 'L#20' : CC.TYPE
*
         PRINT BACKGROUND.BLACK
         PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
         PRINT CC.DESCRIPTION[1,VIEW.WIDTH] :
*
      END ELSE
         PRINT BACKGROUND.CYAN :
         PRINT RAW.WHITE :
         PRINT ' ' : CC.WORD  'L#20' : CC.TYPE
      END
      PRINT RESET.COLOR :
   NEXT CC.CTR
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
ADD.CC.TOKEN:NULL
*
   IF TOKEN<1,1> = '' THEN RETURN
   IF NUM(TOKEN<1,1>) THEN RETURN
   LOCATE(TOKEN<1,1>,SNIPPET.HEADERS;TOKEN.POS) THEN
      RETURN
   END
   SNIPPETS = INSERT(SNIPPETS,TOKEN.POS;TOKEN)
   SNIPPET.HEADERS = INSERT(SNIPPET.HEADERS,TOKEN.POS;TOKEN<1,1>)
   RETURN
*
*********************  s u b r o u t i n e  *********************
*
CC.TOKENIZE.LINE:NULL
*
   IF FILETYPE = 'BASIC' THEN
      GOSUB CC.TOKENIZE.LINE.BASIC
   END ELSE IF FILETYPE = 'PROC' THEN
   END ELSE IF FILETYPE = 'DATA' THEN
   END
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
CC.TOKENIZE.LINE.BASIC:NULL
*
   TOKEN = ''
   FOR LETTER.CTR = 1 TO LEN(RAW.LINE)
      CHARACTER = RAW.LINE[LETTER.CTR,1]
*
      IF CHARACTER = ' ' THEN
         GOSUB ADD.CC.TOKEN
         TOKEN = ''
      END ELSE
         LOCATE(CHARACTER,CC.BREAK.CHARACTERS;BREAK.POS) THEN
            GOSUB ADD.CC.TOKEN
            TOKEN = ''
         END ELSE
            TOKEN = TOKEN : CHARACTER
         END
      END
   NEXT LETTER.CTR
*
   GOSUB ADD.CC.TOKEN
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
ADD.AUTO.COMPLETE:NULL
*
   NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
   FOR RAW.LINE.CTR = 1 TO NUMBER.OF.RAW.LINES
      RAW.LINE = RAW.LINES<RAW.LINE.CTR>
      GOSUB CC.TOKENIZE.LINE
   NEXT RAW.LINE.CTR
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
ADD.SNIPPETS:NULL
*
   $IFDEF DATABASE.UV
      OPENSEQ PATH TO SNIPPETS.FILE ELSE
         RETURN
      END
*
      DONE = FALSE
      INSIDE.STRUCTURE = FALSE
*
      TOKEN = ''
      LOOP
         READSEQ SNIPPET.LINE FROM SNIPPETS.FILE ELSE
            CLOSESEQ SNIPPETS.FILE
            DONE = TRUE
         END
      UNTIL DONE DO
         IF SNIPPET.LINE[1,7] = 'snippet' THEN
            INSIDE.STRUCTURE = TRUE
            TOKEN<1,1> = FIELD(SNIPPET.LINE,' ', 2)
            TOKEN<1,2> = FIELD(SNIPPET.LINE,'"', 2)
            CONTINUE
         END
*
         IF SNIPPET.LINE[1,10] = 'endsnippet' THEN
            INSIDE.STRUCTURE = FALSE
            GOSUB ADD.CC.TOKEN
            TOKEN = ''
            CONTINUE
         END
*
         IF INSIDE.STRUCTURE THEN
            TOKEN<1,3,-1> = CHANGE(SNIPPET.LINE,'$1','')
         END
*
      REPEAT
   $ENDIF
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
BUILD.DICTIONARY:NULL
*
   MAX.DICT.SIZE = 1
*
   OPEN 'DICT',FILENAME TO DICT.FILE THEN
      $IFDEF DATABASE.UV
         EXECUTE 'SELECT DICT ' : FILENAME : ' WITH F1 = "A"' CAPTURING RESULTS
      $ENDIF
*
      $IFDEF DATABASE.QM
         EXECUTE 'SELECT DICT ' : FILENAME : ' WITH F1 = "A"' CAPTURING RESULTS
      $ENDIF
*
      $IFDEF DATABASE.D3
         EXECUTE 'SELECT DICT ' : FILENAME : ' WITH A1 = "A"' CAPTURING RESULTS
      $ENDIF
*
      DICT.LINES = ''
      DICT.NUMBERS = ''
*
      LOOP
         READNEXT DICT.ITEM.ID ELSE DICT.ITEM.ID = ''
      UNTIL DICT.ITEM.ID = '' DO
         DICT.ITEM.ID = TRIM(DICT.ITEM.ID)
         DICT.SIZE = LEN(DICT.ITEM.ID)
         IF DICT.SIZE > MAX.DICT.SIZE THEN
            MAX.DICT.SIZE = DICT.SIZE
         END
         READV ATTRIBUTE.NUMBER FROM DICT.FILE,DICT.ITEM.ID,2 ELSE
            CONTINUE
         END
         LOCATE(ATTRIBUTE.NUMBER,DICT.NUMBERS;DICT.POS;'AR') ELSE
            DICT.LINES = INSERT(DICT.LINES,DICT.POS;DICT.ITEM.ID)
            DICT.NUMBERS = INSERT(DICT.NUMBERS,DICT.POS;ATTRIBUTE.NUMBER)
         END
      REPEAT
*
      CLOSE DICT.FILE
   END
*
   MAX.DICT.SIZE = MAX.DICT.SIZE + MARGIN.LEFT + 2
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
BUILD.DICT.DICTIONARY:NULL
*
   MAX.DICT.SIZE = 13
*
   DICT.LINES = ''
   DICT.LINES<1> = 'TYPE'
   DICT.LINES<2> = 'FIELD'
   DICT.LINES<3> = 'DESCRIPTION'
   DICT.LINES<7> = 'CONVERSION'
   DICT.LINES<8> = 'CORRELATIVE'
   DICT.LINES<9> = 'JUSTIFICATION'
   DICT.LINES<10> = 'WIDTH'
*
   MAX.DICT.SIZE = MAX.DICT.SIZE + MARGIN.LEFT + 2
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
TOGGLE.DICTIONARY:NULL
*
   IF SHOW.RIGHT.WINDOW THEN
      SHOW.RIGHT.WINDOW = FALSE
      RIGHT.WINDOW.LINES = ''
      MARGIN.RIGHT = ORIGINAL.MARGIN.RIGHT
      VIEW.WIDTH = SCREEN.WIDTH - MARGIN.LEFT - MARGIN.RIGHT
   END ELSE
      IF FILETYPE = 'DATA' THEN
         GOSUB BUILD.DICTIONARY
      END ELSE IF FILETYPE = 'DICT' THEN
         GOSUB BUILD.DICT.DICTIONARY
      END
*
      SHOW.RIGHT.WINDOW = TRUE
      RIGHT.WINDOW.LINES = DICT.LINES
*
      MARGIN.RIGHT = MAX.DICT.SIZE
      VIEW.WIDTH = SCREEN.WIDTH - MARGIN.LEFT - MARGIN.RIGHT
   END
*
   GOSUB CONVERT.RAW.LINES
   GOSUB DISPLAY.LINES
*
   PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
   PRINT 'Showing dictionary' :
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
PRECOMPILE:NULL
*
   IF FILETYPE # 'BASIC' THEN
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'This file is not a BASIC file.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   READ ANYTHING FROM VOC.FILE,'PRECOMPILE' ELSE
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'PRECOMPILE is not available.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   GOSUB SAVE.FILE
*
   EXECUTE 'PRECOMPILE ' : FILENAME : ' ' : RECORD.ID : ' (A'
*
   READU RAW.LINES FROM FILE,RECORD.ID ELSE
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'Error reading file after pre-processing.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   GOSUB CONVERT.RAW.LINES
   GOSUB DISPLAY.LINES
*
   $IFDEF DATABASE.UV
      CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
   $ENDIF
*
   $IFDEF DATABASE.QM
      CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
   $ENDIF
*
   $IFDEF DATABASE.D3
      CURRENT.CHECKSUM = OCONV(RAW.LINES,'u001e')
   $ENDIF
*
   GOSUB FORMAT.BASIC
*
   PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
   PRINT 'Precompiled file.' :
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
DECOMPILE:NULL
*
   IF FILETYPE # 'BASIC' THEN
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'This file is not a BASIC file.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   READ ANYTHING FROM VOC.FILE,'DECOMPILE' ELSE
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'DECOMPILE is not available.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   GOSUB SAVE.FILE
*
   EXECUTE 'DECOMPILE ' : FILENAME : ' ' : RECORD.ID
*
   READU RAW.LINES FROM FILE,RECORD.ID ELSE
      PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
      PRINT 'Error reading file after pre-processing.' :
      PRINT @(X.POS,Y.POS) :
      RETURN
   END
*
   GOSUB CONVERT.RAW.LINES
   GOSUB DISPLAY.LINES
*
   $IFDEF DATABASE.UV
      CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
   $ENDIF
*
   $IFDEF DATABASE.QM
      CURRENT.CHECKSUM = CHECKSUM(RAW.LINES)
   $ENDIF
*
   $IFDEF DATABASE.D3
      CURRENT.CHECKSUM = OCONV(RAW.LINES,'u001e')
   $ENDIF
*
   PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
   PRINT 'Decompiled file.' :
*
   GOTO.LINE = 1
   GOSUB GOTO.LINE.POSITION
*
   X.POS = MARGIN.LEFT
   PRINT @(X.POS,Y.POS) :
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
CHECK.WINTEGRATE:NULL
*
   $IFDEF DATABASE.D3
      WINTEGRATE.FLAG = 1
   $ENDIF
*
   $IFDEF DATABASE.QM
      WINTEGRATE.FLAG = 1
   $ENDIF
*
   $IFDEF DATABASE.UV
      PROMPT ''
      PRINT @(-42): ; * lock keyboard
      ECHO OFF
      PRINT COM.START : "enter stx" : COM.END :
      MS = 0
      LOOP MS += 1 WHILE MS < 500 DO
         INPUTIF BUFFER THEN
            IF INDEX(BUFFER, STX, 1) THEN
               WINTEGRATE.FLAG= TRUE
               ECHO ON
               PRINT @(-43): ; * unlock keyboard
               RETURN
            END
         END ELSE NAP 1
      REPEAT
      ECHO ON
      PRINT @(-43): ; * unlock keyboard
   $ENDIF
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
GET.WINTEGRATE.VALUE:NULL
*
   WINT.VALUE = ''
*
   PROMPT ''
   ECHO OFF
   PRINT COM.START : 'Enter stx:Get(' : WINT.KEY : ')' : COM.END :
   LOOP
      INPUT ANYTHING :
   UNTIL INDEX(ANYTHING,STX,1) DO REPEAT
   ECHO ON
*
   WINT.VALUE = FIELD(ANYTHING,STX,2)
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SET.WINTEGRATE.VALUE:NULL
*
   PROMPT ''
   ECHO OFF
   PRINT COM.START : 'Set ' : WINT.KEY : '=`' : WINT.VALUE : '`' : COM.END :
   ECHO ON
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SETUP.WINTEGRATE:NULL
*
   WINT.KEY = 'Effect_Normal'
   GOSUB GET.WINTEGRATE.VALUE
   WINTEGRATE.COLORS = WINT.VALUE
   CONVERT ',' TO @AM IN WINTEGRATE.COLORS
   WINTEGRATE.BACKGROUND = WINTEGRATE.COLORS<2>
*
   IF WINTEGRATE.BACKGROUND = 0 THEN
      DARK.MODE = TRUE
   END
*
   WINT.KEY = 'Emulation'
   GOSUB GET.WINTEGRATE.VALUE
   ORIGINAL.WINT.TERM = WINT.VALUE
*
   WINT.KEY = 'Emulation'
   WINT.VALUE = 'ansi'
   GOSUB SET.WINTEGRATE.VALUE
*
   WINT.KEY = 'Columns'
   GOSUB GET.WINTEGRATE.VALUE
   TERM.WIDTH = WINT.VALUE
*
   WINT.KEY = 'Lines'
   GOSUB GET.WINTEGRATE.VALUE
   TERM.HEIGHT = WINT.VALUE
*
   WINT.KEY = 'Key_PageUp'
   WINT.VALUE = '\e[5~'
   GOSUB SET.WINTEGRATE.VALUE
*
   WINT.KEY = 'Key_PageDown'
   WINT.VALUE = '\e[6~'
   GOSUB SET.WINTEGRATE.VALUE
*
   $IFDEF DATABASE.UV
      WINT.KEY = 'Key_UpArrow'
      WINT.VALUE = '\eOA'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_DownArrow'
      WINT.VALUE = '\eOB'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_LeftArrow'
      WINT.VALUE = '\eOD'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_RightArrow'
      WINT.VALUE = '\eOC'
      GOSUB SET.WINTEGRATE.VALUE
   $ENDIF
*
   $IFDEF DATABASE.QM
      WINT.KEY = 'Key_UpArrow'
      WINT.VALUE = '\eOA'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_DownArrow'
      WINT.VALUE = '\eOB'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_LeftArrow'
      WINT.VALUE = '\eOD'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_RightArrow'
      WINT.VALUE = '\eOC'
      GOSUB SET.WINTEGRATE.VALUE
   $ENDIF
*
   $IFDEF DATABASE.D3
      WINT.KEY = 'Key_UpArrow'
      WINT.VALUE = '\e[A'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_DownArrow'
      WINT.VALUE = '\e[B'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_LeftArrow'
      WINT.VALUE = '\e[D'
      GOSUB SET.WINTEGRATE.VALUE
*
      WINT.KEY = 'Key_RightArrow'
      WINT.VALUE = '\e[C'
      GOSUB SET.WINTEGRATE.VALUE
   $ENDIF
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
SETUP.PUTTY:NULL
*
   $IFDEF PLATFORM.LINUX
      $IFDEF DATABASE.UV
         EXECUTE 'SH -c "stty size"' CAPTURING TERM.SIZE
         TERM.HEIGHT = FIELD(TERM.SIZE<1>,' ',1)
         TERM.WIDTH = FIELD(TERM.SIZE<1>,' ',2)
      $ENDIF
*
      $IFDEF DATABASE.QM
         EXECUTE '!stty size' CAPTURING TERM.SIZE
         TERM.HEIGHT = FIELD(TERM.SIZE<1>,' ',1)
         TERM.WIDTH = FIELD(TERM.SIZE<1>,' ',2)
      $ENDIF
*
      $IFDEF DATABASE.D3
         EXECUTE '!stty size' CAPTURING TERM.SIZE
         TERM.HEIGHT = FIELD(TERM.SIZE<1>,' ',1)
         TERM.WIDTH = FIELD(TERM.SIZE<1>,' ',2)
      $ENDIF
   $ENDIF
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
BUILD.HELP.LINES:NULL
*
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '# EVA Editor'
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = 'EVA is a modal editor for UniVerse and D3. It is multivalue aware and can be used to edit BASIC programs, PROCs, multivalue records and any other files that you can access from UniVerse and D3. It can also edit files on the Linux filesystem directly.'
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = 'Commands starting with : are commands you can run in command mode. You can enter this mode by press shift and the : key in normal mode.'
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '## Quick Start'
   HELP.LINES<-1> = '    escape - Enter Normal mode  '
   HELP.LINES<-1> = '    :q - Exit  '
   HELP.LINES<-1> = '    :w - Save a file  '
   HELP.LINES<-1> = '    i - Insert mode  '
   HELP.LINES<-1> = '    / - Search mode  '
   HELP.LINES<-1> = '    arrow-keys - Movement  '
   HELP.LINES<-1> = '    :help - Help'
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '## Features'
   HELP.LINES<-1> = '    01. Persistent Undo History'
   HELP.LINES<-1> = '    02. Syntax Highlighting for BASIC and PROCs'
   HELP.LINES<-1> = '    03. BASIC code formatter'
   HELP.LINES<-1> = '    04. Auto Complete based on the current file'
   HELP.LINES<-1> = '    05. BASIC snippets for commonly used functions like MATREAD and LOCATE'
   HELP.LINES<-1> = '    06. Natively handle multivalue data and encoding'
   HELP.LINES<-1> = '    07. Explode, edit and view multivalue data easily'
   HELP.LINES<-1> = '    08. Simple searching and replacing'
   HELP.LINES<-1> = '    09. View dictionaries alongside record data'
   HELP.LINES<-1> = '    10. Open linux file paths and write out linux files'
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '## Modes'
   HELP.LINES<-1> = '    01. Normal Mode - This is the default mode  '
   HELP.LINES<-1> = '    02. Insert Mode - Press "i" to enter insert mode, this is how you edit things  '
   HELP.LINES<-1> = '    03. Command Mode - Press ":" to enter command mode, here you can type in commands to run  '
   HELP.LINES<-1> = '    04. Visual Mode -  Press "v" to copy text from a single line  '
   HELP.LINES<-1> = '    05. Search Mode - Press "/" to enter search mode  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '## Opening Files'
   HELP.LINES<-1> = '    EVA BP SOME.FILE - This will open a file inside BP.  '
   HELP.LINES<-1> = '    EVA STUDENT.FILE 47 - This will open a data file.  '
   HELP.LINES<-1> = '    EVA DICT STUDENT.FILE FIRST.NAME - This will open a dictionary  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '## Normal Mode Keys'
   HELP.LINES<-1> = '    Escape - Will put you in normal mode  '
   HELP.LINES<-1> = '    i - enter Insert mode, you can edit and insert characters  '
   HELP.LINES<-1> = '    space - Space will highlight a column of characters. '
   HELP.LINES<-1> = '    : - Command Mode  '
   HELP.LINES<-1> = '    v - Enter visual mode and copy part of a line  '
   HELP.LINES<-1> = '    v -> $ - Inside Visual mode, you can use $ to go to the end of a line  '
   HELP.LINES<-1> = '    v -> d - Inside Visual mode, you can use d to delete a portion of the a line  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    / - Enter search mode and type in a string to search for  '
   HELP.LINES<-1> = '    ctrl+f - Enter search mode and type in a string to search for  '
   HELP.LINES<-1> = '    n - Go to the next search result  '
   HELP.LINES<-1> = '    N - Go to the previous search result  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    c - Add "* TEMP" to the beginning of a line  '
   HELP.LINES<-1> = '    e - Add a new line containing just "*" after the cursor  '
   HELP.LINES<-1> = '    s - Add a internal subroutine template '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    d - This command can be followed by another "d" or a number to delete that many lines  '
   HELP.LINES<-1> = '    o - Insert a blank new line and enter insert mode  '
   HELP.LINES<-1> = '    x - Delete the character at the cursor  '
   HELP.LINES<-1> = '    r - Replace the character at the cursor with the next keypress  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    u - Undo the last change  '
   HELP.LINES<-1> = '    ctrl+r - Redo the last undo  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    y - Yank the current line  '
   HELP.LINES<-1> = '    p - Paste the current buffer  '
   HELP.LINES<-1> = '    1 - Place a starting mark, the will be the starting line for a block  '
   HELP.LINES<-1> = '    ` - Place an ending mark, this will be the end of a block  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    up-arrow - Move the cursor up  '
   HELP.LINES<-1> = '    down-arrow - Move the cursor down  '
   HELP.LINES<-1> = '    left-arrow - Move the cursor to the left  '
   HELP.LINES<-1> = '    right-arrow - Move the cursor to the right  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    Backspace - Will move the cursor to the right  '
   HELP.LINES<-1> = '    Enter - Will move the cursor down  '
   HELP.LINES<-1> = '    Enter GOSUB - Enter on GOSUB will take you to the internal subroutine'
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    h - Move the cursor left    '
   HELP.LINES<-1> = '    j - Move the cursor down    '
   HELP.LINES<-1> = '    k - Move the cursor up  '
   HELP.LINES<-1> = '    l - Move the cursor right  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    G - Place the cursor on the last line  '
   HELP.LINES<-1> = '    $ - Place the cursor at the end of the line  '
   HELP.LINES<-1> = '    0 - Place the cursor at the beginning of the line  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    " - Enclose a word in double quotes  '
   HELP.LINES<-1> = "    ' - Enclose a word in single quotes "
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '## Editor Mode Commands'
   HELP.LINES<-1> = '    :help - Display the help  '
   HELP.LINES<-1> = '    :h - Display the help  '
   HELP.LINES<-1> = '    :^ - Enter up-arrow mode to view non-printable characters  '
   HELP.LINES<-1> = '    :syntax={BASIC,PROC,DATA} - Change the syntax highlighting  '
   HELP.LINES<-1> = '    :{lineNumber} - This will put the cursor on that line number  '
   HELP.LINES<-1> = '    :e - Go to %END'
   HELP.LINES<-1> = '    :gf - Typing gf on a CALL SUBROUTINE will open the subroutine in a view only buffer '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :invert - This will inverse the case of a line  '
   HELP.LINES<-1> = '    :lower - Transform the line to lowercase  '
   HELP.LINES<-1> = '    :upper - Transform the line to uppercase  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :numbers - Toggle the line numbers   '
   HELP.LINES<-1> = '    :f - Format the file  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :dec - Decompile a file - ASI  '
   HELP.LINES<-1> = '    :prec - Precompile a file - ASI  '
   HELP.LINES<-1> = '    :comp - Decompile and Precompile a file - ASI  '
   HELP.LINES<-1> = '    :lint - Lint a BASIC program  '
   HELP.LINES<-1> = '    :archive - Archive a record in a file, creates a copy to ARCHIVE-{FILE} with a datestamp  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :vlist - View the object code source of a BASIC program  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :fa - Toggle the file attributes, only works in dictionaries  '
   HELP.LINES<-1> = '    :dict - View the dictionary in a seperate buffer  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :count {string} - Count the occurnace of the string  '
   HELP.LINES<-1> = '    :s/{SS}/{RR}/{number=1} - Replace SS with RR in the current line and next number of lines  '
   HELP.LINES<-1> = '    :%s/{SS}/{RR} - Replace SS with RR globally  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :a{num} {string} - Append a string to the next number of lines  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :dt{lineNumber} - Delete to a specific line number  '
   HELP.LINES<-1> = '    :d{number} - Delete the next number of lines  '
   HELP.LINES<-1> = '    :drop - Delete a block that has been marked  '
   HELP.LINES<-1> = '    :d - Move a block that has been marked  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :ev - Explode into a multivalue line  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :load {file} {record} - This will prompt for the line start and end, load in this lines from a seperate file  '
   HELP.LINES<-1> = '    :w - Save the record  '
   HELP.LINES<-1> = '    :r - Save and run a file, the output will be captured to a seperate buffer  '
   HELP.LINES<-1> = '    :fd - Delete the record  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '    :q - Exit a file  '
   HELP.LINES<-1> = '    :exk - Exit a file and exit the readnext loop  '
   HELP.LINES<-1> = '    :x - Exit a file and exit the readnext loop  '
   HELP.LINES<-1> = '*'
   HELP.LINES<-1> = '* END'
   HELP.LINES<-1> = '*'
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
ADD.DEFAULT.SNIPPETS:NULL
*
   SNIPPETS<1,1> = 'ABORT'
   SNIPPETS<1,2> = 'Use the ABORT statement to terminate execution of a BASIC program and return to the UniVerse prompt.'
   SNIPPETS<1,3,1> = "ABORT "
   SNIPPETS<2,1> = 'ABS'
   SNIPPETS<2,2> = 'Use the ABS function to return the absolute value of any numeric expression.'
   SNIPPETS<2,3,1> = "ABS()"
   SNIPPETS<3,1> = 'ABSS'
   SNIPPETS<3,2> = 'Use the ABSS function to return the absolute values of all the elements in a dynamic array.'
   SNIPPETS<3,3,1> = "ABSS()"
   SNIPPETS<4,1> = 'ACOS'
   SNIPPETS<4,2> = 'Use the ACOS function to return the trigonometric arc-cosine of expression.'
   SNIPPETS<4,3,1> = "ACOS()"
   SNIPPETS<5,1> = 'ACTIVATEKEY'
   SNIPPETS<5,2> = 'Use the ACTIVATEKEY statement to activate a key.'
   SNIPPETS<5,3,1> = "ACTIVATEKEY <key.id>, <password> [ON <hostname>]"
   SNIPPETS<6,1> = 'ADDS'
   SNIPPETS<6,2> = 'Use the ADDS function to create a dynamic array of the element-by-element addition of two dynamic arrays.'
   SNIPPETS<6,3,1> = "ADDS(,)"
   SNIPPETS<7,1> = 'ALPHA'
   SNIPPETS<7,2> = 'Use the ALPHA function to determine whether expression is an alphabetic or non-alphabetic string.'
   SNIPPETS<7,3,1> = "ALPHA()"
   SNIPPETS<8,1> = 'ANDS'
   SNIPPETS<8,2> = 'Use the ANDS function to create a dynamic array of the logical AND of corresponding elements of two dynamic arrays.'
   SNIPPETS<8,3,1> = "ANDS(, )"
   SNIPPETS<9,1> = 'ASCII'
   SNIPPETS<9,2> = 'Use the ASCII function to convert each character of expression from its EBCDIC representation value to its ASCII representation value.'
   SNIPPETS<9,3,1> = "ASCII()"
   SNIPPETS<10,1> = 'ASIN'
   SNIPPETS<10,2> = 'Use the ASIN function to return the trigonometric arc-sine of expression.'
   SNIPPETS<10,3,1> = "ASIN()"
   SNIPPETS<11,1> = 'ASSIGNED'
   SNIPPETS<11,2> = 'Use the ASSIGNED function to determine if variable is assigned a value.'
   SNIPPETS<11,3,1> = "ASSIGNED()"
   SNIPPETS<12,1> = 'ATAN'
   SNIPPETS<12,2> = 'Use the ATAN function to return the trigonometric arc-tangent of expression.'
   SNIPPETS<12,3,1> = "ATAN()"
   SNIPPETS<13,1> = 'AUTHORIZATION'
   SNIPPETS<13,2> = 'Use the AUTHORIZATION statement to specify or change the effective runtime user of a program.'
   SNIPPETS<13,3,1> = "AUTHORIZATION "
   SNIPPETS<14,1> = 'AUXMAP'
   SNIPPETS<14,2> = 'In NLS mode, use the AUXMAP statement to associate an auxiliary device with a terminal.'
   SNIPPETS<14,3,1> = "AUXMAP { ON | OFF | expression }"
   SNIPPETS<15,1> = 'BITAND'
   SNIPPETS<15,2> = 'Use the BITAND function to perform the bitwise AND comparison of two integers specified by numeric expressions.'
   SNIPPETS<15,3,1> = "BITAND(, )"
   SNIPPETS<16,1> = 'BITNOT'
   SNIPPETS<16,2> = 'Use the BITNOT function to return the bitwise negation of an integer specified by any numeric expression.'
   SNIPPETS<16,3,1> = "BITNOT()"
   SNIPPETS<17,1> = 'BITOR'
   SNIPPETS<17,2> = 'Use the BITOR function to perform the bitwise OR comparison of two integers specified by numeric expressions.'
   SNIPPETS<17,3,1> = "BITOR(, )"
   SNIPPETS<18,1> = 'BITRESET'
   SNIPPETS<18,2> = 'Use the BITRESET function to reset to 0 the bit number of the integer specified by expression.'
   SNIPPETS<18,3,1> = "BITRESET(, )"
   SNIPPETS<19,1> = 'BITSET'
   SNIPPETS<19,2> = 'Use the BITSET function to set to 1 the bit number of the integer specified by expression.'
   SNIPPETS<19,3,1> = "BITSET(, )"
   SNIPPETS<20,1> = 'BITTEST'
   SNIPPETS<20,2> = 'Use the BITTEST function to test the bit number of the integer specified by expression.'
   SNIPPETS<20,3,1> = "BITTEST(, )"
   SNIPPETS<21,1> = 'BITXOR'
   SNIPPETS<21,2> = 'Use the BITXOR function to perform the bitwise XOR comparison of two integers specified by numeric expressions.'
   SNIPPETS<21,3,1> = "BITXOR(, )"
   SNIPPETS<22,1> = 'BREAK'
   SNIPPETS<22,2> = 'Use the BREAK statement to enable or disable the Intr, Quit, and Susp keys on the keyboard.'
   SNIPPETS<22,3,1> = "BREAK"
   SNIPPETS<23,1> = 'BSCAN'
   SNIPPETS<23,2> = 'Use the BSCAN statement to scan the leaf nodes of a B-tree file (type 25) or of a secondary index.'
   SNIPPETS<23,3,1> = "BSCAN ITEM.ID FROM "
   SNIPPETS<24,1> = 'BYTE'
   SNIPPETS<24,2> = 'In NLS mode, use the BYTE function to generate a byte from the numeric value of expression.'
   SNIPPETS<24,3,1> = "BYTE()"
   SNIPPETS<25,1> = 'BYTELEN'
   SNIPPETS<25,2> = 'In NLS mode, use the BYTELEN function to generate the number of bytes contained in the ASCII string value in expression.'
   SNIPPETS<25,3,1> = "BYTELEN()"
   SNIPPETS<26,1> = 'BYTETYPE'
   SNIPPETS<26,2> = 'In NLS mode, use the BYTETYPE function to determine the function of a byte in value.'
   SNIPPETS<26,3,1> = "BYTETYPE()"
   SNIPPETS<27,1> = 'BYTEVAL'
   SNIPPETS<27,2> = 'In NLS mode, use the BYTEVAL function to examine the bytes contained in the internal string value of expression.'
   SNIPPETS<27,3,1> = "BYTEVAL()"
   SNIPPETS<28,1> = 'CALL'
   SNIPPETS<28,2> = 'Use the CALL statement to transfer program control from the calling program to an external subroutine or program that has been compiled and cataloged.'
   SNIPPETS<28,3,1> = "CALL"
   SNIPPETS<29,1> = 'CASE'
   SNIPPETS<29,2> = 'Use the CASE statement to alter the sequence of instruction execution based on the value of one or more expressions.'
   SNIPPETS<29,3,1> = "BEGIN CASE"
   SNIPPETS<30,1> = 'CATS'
   SNIPPETS<30,2> = 'Use the CATS function to create a dynamic array of the element-by-element concatenation of two dynamic arrays.'
   SNIPPETS<30,3,1> = "CATS(, )"
   SNIPPETS<31,1> = 'CHAIN'
   SNIPPETS<31,2> = 'Use the CHAIN statement to terminate execution of a UniVerse BASIC program and to execute the value of command.'
   SNIPPETS<31,3,1> = "CHAIN "
   SNIPPETS<32,1> = 'CHANGE'
   SNIPPETS<32,2> = 'Use the CHANGE function to replace a substring in expression with another substring.'
   SNIPPETS<32,3,1> = "CHANGE(, S, R)"
   SNIPPETS<33,1> = 'CHAR'
   SNIPPETS<33,2> = 'Use the CHAR function to generate an ASCII character from the numeric value of expression.'
   SNIPPETS<33,3,1> = "CHAR()"
   SNIPPETS<34,1> = 'CHARS'
   SNIPPETS<34,2> = 'Use the CHARS function to generate a dynamic array of ASCII characters from the decimal numeric value of each element of dynamic.'
   SNIPPETS<34,3,1> = "CHARS()"
   SNIPPETS<35,1> = 'CHECKSUM'
   SNIPPETS<35,2> = 'Use the CHECKSUM function to return a cyclical redundancy code (a checksum value).'
   SNIPPETS<35,3,1> = "CHECKSUM()"
   SNIPPETS<36,1> = 'CLEAR'
   SNIPPETS<36,2> = 'Use the CLEAR statement at the beginning of a program to set all assigned and unassigned values of variables outside of the common area of the program to 0.'
   SNIPPETS<36,3,1> = "CLEAR [COMMON]"
   SNIPPETS<37,1> = 'CLEARDATA'
   SNIPPETS<37,2> = 'Use the CLEARDATA statement to flush all data that has been loaded in the input stack by the DATA statement.'
   SNIPPETS<37,3,1> = "CLEARDATA"
   SNIPPETS<38,1> = 'CLEARFILE'
   SNIPPETS<38,2> = 'Use the CLEARFILE statement to delete all records in an open dictionary or data file.'
   SNIPPETS<38,3,1> = "CLEARFILE "
   SNIPPETS<39,1> = 'CLEARPROMPTS'
   SNIPPETS<39,2> = 'Use the CLEARPROMPTS statement to clear the value of the inline prompt.'
   SNIPPETS<39,3,1> = "CLEARPROMPTS"
   SNIPPETS<40,1> = 'CLEARSELECT'
   SNIPPETS<40,2> = 'Use the CLEARSELECT statement to clear an active select list.'
   SNIPPETS<40,3,1> = "CLEARSELECT "
   SNIPPETS<41,1> = 'CLOSE'
   SNIPPETS<41,2> = 'Use the CLOSE statement after opening and processing a file.'
   SNIPPETS<41,3,1> = "CLOSE "
   SNIPPETS<42,1> = 'CLOSESEQ'
   SNIPPETS<42,2> = 'Use the CLOSESEQ statement after opening and processing a file opened for sequential processing.'
   SNIPPETS<42,3,1> = "CLOSESEQ "
   SNIPPETS<43,1> = 'COMMIT'
   SNIPPETS<43,2> = 'Use the COMMIT statement to commit all file I/O changes made during a transaction.'
   SNIPPETS<43,3,1> = "COMMIT"
   SNIPPETS<44,1> = 'COMMON'
   SNIPPETS<44,2> = 'Use the COMMON statement to provide a storage area for variables.'
   SNIPPETS<44,3,1> = "COMMON"
   SNIPPETS<45,1> = 'COMPARE'
   SNIPPETS<45,2> = 'Use the COMPARE function to compare two strings and return a numeric value indicating the result.'
   SNIPPETS<45,3,1> = "COMPARE(, )"
   SNIPPETS<46,1> = 'CONVERT'
   SNIPPETS<46,2> = 'Use the CONVERT statement to replace every occurrence of specific characters in a string with other characters.'
   SNIPPETS<46,3,1> = "CONVERT S TO R IN XX"
   SNIPPETS<47,1> = 'COS'
   SNIPPETS<47,2> = 'Use the COS function to return the trigonometric cosine of an angle.'
   SNIPPETS<47,3,1> = "COS()"
   SNIPPETS<48,1> = 'COSH'
   SNIPPETS<48,2> = 'Use the COSH function to return the hyperbolic cosine of expression.'
   SNIPPETS<48,3,1> = "COSH()"
   SNIPPETS<49,1> = 'COUNT'
   SNIPPETS<49,2> = 'Use the COUNT function to return the number of times a substring is repeated in a string value.'
   SNIPPETS<49,3,1> = "COUNT(, S)"
   SNIPPETS<50,1> = 'COUNTS'
   SNIPPETS<50,2> = 'Use the COUNTS function to count the number of times a substring is repeated in each element of a dynamic array.'
   SNIPPETS<50,3,1> = "COUNTS(, )"
   SNIPPETS<51,1> = 'CREATE'
   SNIPPETS<51,2> = 'Use the CREATE statement after an OPENSEQ statement to create a record in a type 1 or type statement fails.'
   SNIPPETS<51,3,1> = "CREATE FLAT.FILE ELSE"
   SNIPPETS<52,1> = 'CRT'
   SNIPPETS<52,2> = 'Use the CRT statement to print data on the screen, regardless of whether a PRINTER ON statement has been executed.'
   SNIPPETS<52,3,1> = "CRT "
   SNIPPETS<53,1> = 'DATA'
   SNIPPETS<53,2> = 'Use the DATA statement to place values in an input stack.'
   SNIPPETS<53,3,1> = "DATA "
   SNIPPETS<54,1> = 'DATE'
   SNIPPETS<54,2> = 'Use the DATE function to return the numeric value of the internal system date.'
   SNIPPETS<54,3,1> = "DATE()"
   SNIPPETS<55,1> = 'DBTOXML'
   SNIPPETS<55,2> = 'To create an XML document from the UniVerse database using UniVerse BASIC, use the DBTOXML function.'
   SNIPPETS<55,3,1> = "DBTOXML(xml_document, doc_location, u2xmap_file, u2xmap_location,"
   SNIPPETS<56,1> = 'DCOUNT'
   SNIPPETS<56,2> = 'Use the DCOUNT function to return the number of delimited fields in a data string.'
   SNIPPETS<56,3,1> = "DCOUNT(, @AM)"
   SNIPPETS<57,1> = 'DEACTIVATEKEY'
   SNIPPETS<57,2> = 'Use the DEACTIVATEKEY command to deactivate one or more encryption keys.'
   SNIPPETS<57,3,1> = "DEACTIVATEKEY <key.id>, <password> [ON <hostname>]"
   SNIPPETS<58,1> = 'DEBUG'
   SNIPPETS<58,2> = 'Use the DEBUG statement to invoke RAID, the interactive UniVerse BASIC debugger.'
   SNIPPETS<58,3,1> = "DEBUG"
   SNIPPETS<59,1> = 'DEFFUN'
   SNIPPETS<59,2> = 'Use the DEFFUN statement to define a user-written function.'
   SNIPPETS<59,3,1> = "DEFFUN "
   SNIPPETS<60,1> = 'DEL'
   SNIPPETS<60,2> = 'Use the DEL statement to delete a field, value, or subvalue from a dynamic array.'
   SNIPPETS<60,3,1> = "DEL "
   SNIPPETS<61,1> = 'DELETE'
   SNIPPETS<61,2> = 'Use the DELETE statements to delete a record from a UniVerse file.'
   SNIPPETS<61,3,1> = "DELETE  ,"
   SNIPPETS<62,1> = 'DELETELIST'
   SNIPPETS<62,2> = 'Use the DELETELIST statement to delete a select list saved in the &SAVEDLISTS& file.'
   SNIPPETS<62,3,1> = "DELETELIST "
   SNIPPETS<63,1> = 'DESCRINFO'
   SNIPPETS<63,2> = 'The DESCRINFO function returns requested information (key) about a variable.'
   SNIPPETS<63,3,1> = "DESCRINFO(,)"
   SNIPPETS<64,1> = 'DIGEST'
   SNIPPETS<64,2> = 'The DIGEST() function generates a message digest of supplied data.'
   SNIPPETS<64,3,1> = "DIGEST(, , , )"
   SNIPPETS<65,1> = 'DIMENSION'
   SNIPPETS<65,2> = 'Use the DIMENSION statement to define the dimensions of an array variable before referencing the array in the program.'
   SNIPPETS<65,3,1> = "DIM ()"
   SNIPPETS<66,1> = 'DISABLEDEC'
   SNIPPETS<66,2> = 'Use the DISABLEDEC command to turn off decryption on a field or fields you specify.'
   SNIPPETS<66,3,1> = "DISABLEDEC "
   SNIPPETS<67,1> = 'DISPLAY'
   SNIPPETS<67,2> = 'Use the DISPLAY statement to print data on the screen, regardless of whether a PRINTER ON statement has been executed.'
   SNIPPETS<67,3,1> = "DISPLAY "
   SNIPPETS<68,1> = 'DIV'
   SNIPPETS<68,2> = 'Use the DIV function to calculate the value of the quotient after dividend is divided by divisor.'
   SNIPPETS<68,3,1> = "DIV(, )"
   SNIPPETS<69,1> = 'DIVS'
   SNIPPETS<69,2> = 'Use the DIVS function to create a dynamic array containing the result of the element-by-element division of two dynamic arrays.'
   SNIPPETS<69,3,1> = "DIVS(, )"
   SNIPPETS<70,1> = 'DOWNCASE'
   SNIPPETS<70,2> = 'Use the DOWNCASE function to change all uppercase letters in expression to lowercase.'
   SNIPPETS<70,3,1> = "DOWNCASE()"
   SNIPPETS<71,1> = 'DQUOTE'
   SNIPPETS<71,2> = 'Use the DQUOTE function to enclose an expression in double quotation marks.'
   SNIPPETS<71,3,1> = "DQUOTE()"
   SNIPPETS<72,1> = 'DTX'
   SNIPPETS<72,2> = 'Use the DTX function to convert a decimal integer to its hexadecimal equivalent.'
   SNIPPETS<72,3,1> = "DTX()"
   SNIPPETS<73,1> = 'EBCDIC'
   SNIPPETS<73,2> = 'Use the EBCDIC function to convert each character of expression from its ASCII representation value to its EBCDIC representation value.'
   SNIPPETS<73,3,1> = "EBCDIC()"
   SNIPPETS<74,1> = 'ECHO'
   SNIPPETS<74,2> = 'Use the ECHO statement to control the display of input characters on the screen.'
   SNIPPETS<74,3,1> = "ECHO ON"
   SNIPPETS<75,1> = 'ENABLEDEC'
   SNIPPETS<75,2> = 'Use the ENABLEDEC command to activate decryption on a file or fields you specify.'
   SNIPPETS<75,3,1> = "ENABLEDEC "
   SNIPPETS<76,1> = 'ENCODE'
   SNIPPETS<76,2> = 'The ENCODE() function performs data encoding on input data.'
   SNIPPETS<76,3,1> = "ENCODE(, , , , , )"
   SNIPPETS<77,1> = 'ENCRYPT'
   SNIPPETS<77,2> = 'The ENCRYPT() function performs symmetric encryption operations.'
   SNIPPETS<77,3,1> = "ENCRYPT(, , , ,, , ,,)"
   SNIPPETS<78,1> = 'END'
   SNIPPETS<78,2> = 'Use the END statement to terminate a BASIC program or a section of an IF statement, READ statement, or OPEN statement.'
   SNIPPETS<78,3,1> = "END"
   SNIPPETS<79,1> = 'ENTER'
   SNIPPETS<79,2> = 'Use the ENTER statement to transfer program control from the calling program to an external subroutine without returning to the calling program.'
   SNIPPETS<79,3,1> = "ENTER "
   SNIPPETS<80,1> = 'EQS'
   SNIPPETS<80,2> = 'Use the EQS function to test if elements of one dynamic array are equal to the elements of another dynamic array.'
   SNIPPETS<80,3,1> = "EQS(, )"
   SNIPPETS<81,1> = 'EQUATE'
   SNIPPETS<81,2> = 'In an EQUATE statement, symbol represents the value of expression or string.'
   SNIPPETS<81,3,1> = "EQU TO "
   SNIPPETS<82,1> = 'EREPLACE'
   SNIPPETS<82,2> = 'Use the EREPLACE function to replace substring in expression with another substring.'
   SNIPPETS<82,3,1> = "EREPLACE(,S,R)"
   SNIPPETS<83,1> = 'ERRMSG'
   SNIPPETS<83,2> = 'Use the ERRMSG statement to print a formatted error message from the ERRMSG file.'
   SNIPPETS<83,3,1> = "ERRMSG "
   SNIPPETS<84,1> = 'EXCHANGE'
   SNIPPETS<84,2> = 'Use the EXCHANGE function to replace one character with another or to delete all occurrences of the specified character.'
   SNIPPETS<84,3,1> = "EXCHANGE(, , )"
   SNIPPETS<85,1> = 'EXECUTE'
   SNIPPETS<85,2> = 'Use the EXECUTE statement to execute UniVerse commands from within the BASIC program and then return execution to the statement following the EXECUTE statement.'
   SNIPPETS<85,3,1> = "EXECUTE CAPTURING RESULTS"
   SNIPPETS<86,1> = 'EXIT'
   SNIPPETS<86,2> = 'Use the EXIT statement to quit execution of a FOR.'
   SNIPPETS<86,3,1> = "EXIT"
   SNIPPETS<87,1> = 'EXP'
   SNIPPETS<87,2> = 'Use the EXP function to return the value of e raised to the power designated by expression.'
   SNIPPETS<87,3,1> = "EXP()"
   SNIPPETS<88,1> = 'EXTRACT'
   SNIPPETS<88,2> = 'Use the EXTRACT function to access the data contents of a specified field, value, or subvalue from a dynamic array.'
   SNIPPETS<88,3,1> = "EXTRACT(, )"
   SNIPPETS<89,1> = 'FADD'
   SNIPPETS<89,2> = 'Use the FADD function to perform floating-point addition on two numeric values.'
   SNIPPETS<89,3,1> = "CALL !FADD(, , )"
   SNIPPETS<90,1> = 'FDIV'
   SNIPPETS<90,2> = 'Use the FDIV function to perform floating-point division on two numeric values.'
   SNIPPETS<90,3,1> = "FDIV(, )"
   SNIPPETS<91,1> = 'FFIX'
   SNIPPETS<91,2> = 'Use the FFIX function to convert a floating-point number to a numeric string with fixed precision.'
   SNIPPETS<91,3,1> = "FFIX()"
   SNIPPETS<92,1> = 'FFLT'
   SNIPPETS<92,2> = 'Use the FFLT function to round a number to a string with a precision of 13.'
   SNIPPETS<92,3,1> = "FFLT()"
   SNIPPETS<93,1> = 'FIELD'
   SNIPPETS<93,2> = 'Use the FIELD function to return one or more substrings located between specified delimiters in string.'
   SNIPPETS<93,3,1> = "FIELD(, ,)"
   SNIPPETS<94,1> = 'FIELDS'
   SNIPPETS<94,2> = 'Use the FIELDS function to return a dynamic array of substrings located between specified delimiters in each element of dynamic.'
   SNIPPETS<94,3,1> = "FIELDS(, , )"
   SNIPPETS<95,1> = 'FIELDSTORE'
   SNIPPETS<95,2> = 'Use the FIELDSTORE function to modify character strings by inserting, deleting, or replacing fields separated by specified delimiters.'
   SNIPPETS<95,3,1> = "FIELDSTORE(, , , , )"
   SNIPPETS<96,1> = 'FIELDWRITE'
   SNIPPETS<96,2> = 'The FIELDWRITE statement allows you to update the specified fields in an existing record and releases locks set by the same process.'
   SNIPPETS<96,3,1> = "FIELDWRITE[U] expression {ON | TO} [file.variable,] record.ID,"
   SNIPPETS<97,1> = 'FILEINFO'
   SNIPPETS<97,2> = 'Use the FILEINFO function to return information about the specified files configuration, such as the specified files parameters, its modulus and load, its operating system file name, and its VOC name.'
   SNIPPETS<97,3,1> = "FILEINFO(,)"
   SNIPPETS<98,1> = 'FILELOCK'
   SNIPPETS<98,2> = 'Use the FILELOCK statement to acquire a lock on an entire file.'
   SNIPPETS<98,3,1> = "FILELOCK "
   SNIPPETS<99,1> = 'FILEUNLOCK'
   SNIPPETS<99,2> = 'Use the FILEUNLOCK statement to release a file lock set by the FILELOCK statement.'
   SNIPPETS<99,3,1> = "FILEUNLOCK "
   SNIPPETS<100,1> = 'FIND'
   SNIPPETS<100,2> = 'Use the FIND statement to locate an element in dynamic.'
   SNIPPETS<100,3,1> = "FIND IN "
   SNIPPETS<101,1> = 'FINDSTR'
   SNIPPETS<101,2> = 'Use the FINDSTR statement to locate substring in dynamic.'
   SNIPPETS<101,3,1> = "FINDSTR IN "
   SNIPPETS<102,1> = 'FIX'
   SNIPPETS<102,2> = 'Use the FIX function to convert a numeric value to a floating-point number with a specified precision.'
   SNIPPETS<102,3,1> = "FIX()"
   SNIPPETS<103,1> = 'FLUSH'
   SNIPPETS<103,2> = 'The FLUSH statement causes all the buffers for a sequential I/O file to be written immediately.'
   SNIPPETS<103,3,1> = "FLUSH "
   SNIPPETS<104,1> = 'FMT'
   SNIPPETS<104,2> = 'Use the FMT function or a format expression to format data for output.'
   SNIPPETS<104,3,1> = "FMT(, )"
   SNIPPETS<105,1> = 'FMTDP'
   SNIPPETS<105,2> = 'In NLS mode, use the FMTDP function to format data for output in display positions rather than character lengths.'
   SNIPPETS<105,3,1> = "FMTDP(,)"
   SNIPPETS<106,1> = 'FMTS'
   SNIPPETS<106,2> = 'Use the FMTS function to format elements of dynamic.'
   SNIPPETS<106,3,1> = "FMTS(,)"
   SNIPPETS<107,1> = 'FMTSDP'
   SNIPPETS<107,2> = 'In NLS mode, use the FMTSDP function to format elements of dynamic.'
   SNIPPETS<107,3,1> = "FMTSDP(,)"
   SNIPPETS<108,1> = 'FMUL'
   SNIPPETS<108,2> = 'Use the FMUL function to perform floating-point multiplication on two numeric values.'
   SNIPPETS<108,3,1> = "FMUL(,)"
   SNIPPETS<109,1> = 'FOLD'
   SNIPPETS<109,2> = 'Use the FOLD function to divide a string into a number of substrings separated by field marks.'
   SNIPPETS<109,3,1> = "FOLD(,)"
   SNIPPETS<110,1> = 'FOLDDP'
   SNIPPETS<110,2> = 'In NLS mode, use the FOLDDP function to divide a string into a number of substrings separated by field marks.'
   SNIPPETS<110,3,1> = "FOLDDP(,)"
   SNIPPETS<111,1> = 'FOOTING'
   SNIPPETS<111,2> = 'Use the FOOTING statement to specify the text and format of the footing to print at the bottom of each page of output.'
   SNIPPETS<111,3,1> = "FOOTING "
   SNIPPETS<112,1> = 'FOR'
   SNIPPETS<112,2> = 'Use the FOR statement to create a FORNEXT program loop.'
   SNIPPETS<112,3,1> = "FOR I = 1 TO "
   SNIPPETS<112,3,2> = "NEXT I"
   SNIPPETS<113,1> = 'FORMLIST'
   SNIPPETS<113,2> = 'The FORMLIST statement is the same as the SELECT statements.'
   SNIPPETS<113,3,1> = "FORMLIST "
   SNIPPETS<114,1> = 'FSUB'
   SNIPPETS<114,2> = 'Use the FSUB function to perform floating-point subtraction on two numeric values.'
   SNIPPETS<114,3,1> = "FSUB(, )"
   SNIPPETS<115,1> = 'FUNCTION'
   SNIPPETS<115,2> = 'Use the FUNCTION statement to identify a user-written function and to specify the number and names of the arguments to be passed to it.'
   SNIPPETS<115,3,1> = "FUNCTION "
   SNIPPETS<116,1> = 'GES'
   SNIPPETS<116,2> = 'Use the GES function to test if elements of one dynamic array are greater than or equal to corresponding elements of another dynamic array.'
   SNIPPETS<116,3,1> = "GES(, )"
   SNIPPETS<117,1> = 'GET'
   SNIPPETS<117,2> = 'Use GET statements to read a block of data from an input stream associated with a device, such as a serial line or terminal.'
   SNIPPETS<117,3,1> = "GET[X]read.var[, length] [SETTING read.count] FROM device [UNTIL"
   SNIPPETS<118,1> = 'GETX'
   SNIPPETS<118,2> = 'Use the GETX statement to read a block of data from an input stream and return the characters in ASCII hexadecimal format.'
   SNIPPETS<118,3,1> = "GET(ARG. [,arg#] ) variable [THEN statements] [ELSE statements]"
   SNIPPETS<119,1> = 'GETLIST'
   SNIPPETS<119,2> = 'Use the GETLIST statement to activate a saved select list so that a READNEXT statement can use it.'
   SNIPPETS<119,3,1> = "GETLIST "
   SNIPPETS<120,1> = 'GETLOCALE'
   SNIPPETS<120,2> = 'In NLS mode use the GETLOCALE function to return the names of specified categories of the current locale.'
   SNIPPETS<120,3,1> = "GETLOCALE()"
   SNIPPETS<121,1> = 'GETREM'
   SNIPPETS<121,2> = 'Use the GETREM function after the execution of a REMOVE statement, a REMOVE function, or a REVREMOVE statement, to return the numeric value for the character position of the pointer associated with dynamic.'
   SNIPPETS<121,3,1> = "GETREM()"
   SNIPPETS<122,1> = 'GOSUB'
   SNIPPETS<122,2> = 'Use the GOSUB statement to transfer program control to an internal subroutine referenced by statement.'
   SNIPPETS<122,3,1> = "GOSUB "
   SNIPPETS<123,1> = 'GOTO'
   SNIPPETS<123,2> = 'Use the GOTO statement to transfer program control to the statement specified by statement.'
   SNIPPETS<123,3,1> = "GOTO"
   SNIPPETS<124,1> = 'GROUP'
   SNIPPETS<124,2> = 'Use the GROUP function to return one or more substrings located between specified delimiters in string.'
   SNIPPETS<124,3,1> = "GROUP(, ,)"
   SNIPPETS<125,1> = 'GROUPSTORE'
   SNIPPETS<125,2> = 'Use the GROUPSTORE statement to modify character strings by inserting, deleting, or replacing fields separated by specified delimiters.'
   SNIPPETS<125,3,1> = "GROUPSTORE IN USING "
   SNIPPETS<126,1> = 'GTS'
   SNIPPETS<126,2> = 'Use the GTS function to test if elements of one dynamic array are greater than elements of another dynamic array.'
   SNIPPETS<126,3,1> = "GTS(, )"
   SNIPPETS<127,1> = 'HEADING'
   SNIPPETS<127,2> = 'Use the HEADING statement to specify the text and format of the heading to print at the top of each page of output.'
   SNIPPETS<127,3,1> = "HEADING "
   SNIPPETS<128,1> = 'HMAC'
   SNIPPETS<128,2> = 'HMAC (keyed-Hash Message Authentication Code) is a specific construction for calculating a message authentication code (MAC) involving a cryptographic hash function in combination with a secret key.'
   SNIPPETS<128,3,1> = "hmac= HMAC(, , , )"
   SNIPPETS<129,1> = 'HUSH'
   SNIPPETS<129,2> = 'Use the HUSH statement to suppress the display of all output normally sent to a terminal during processing.'
   SNIPPETS<129,3,1> = "HUSH ON"
   SNIPPETS<130,1> = 'ICHECK'
   SNIPPETS<130,2> = 'Use the ICHECK function to check if data you intend to write to an SQL table violates any SQL integrity constraints.'
   SNIPPETS<130,3,1> = "ICHECK()"
   SNIPPETS<131,1> = 'ICONV'
   SNIPPETS<131,2> = 'Use the ICONV function to convert string to a specified internal storage format.'
   SNIPPETS<131,3,1> = "ICONV(, "")"
   SNIPPETS<132,1> = 'ICONVS'
   SNIPPETS<132,2> = 'Use the ICONVS function to convert each element of dynamic.'
   SNIPPETS<132,3,1> = "ICONVS(, "")"
   SNIPPETS<133,1> = 'IF'
   SNIPPETS<133,2> = 'Use the IF statement to determine program flow based on the evaluation of expression.'
   SNIPPETS<133,3,1> = "IF  THEN"
   SNIPPETS<133,3,2> = "END"
   SNIPPETS<134,1> = 'IFS'
   SNIPPETS<134,2> = 'Use the IFS function to return a dynamic array whose elements are chosen individually from one of two dynamic arrays based on the contents of a third dynamic array.'
   SNIPPETS<134,3,1> = "IFS(, , )"
   SNIPPETS<135,1> = 'ILPROMPT'
   SNIPPETS<135,2> = 'Use the ILPROMPT function to evaluate a string containing UniVerse in-line prompts.'
   SNIPPETS<135,3,1> = "ILPROMPT()"
   SNIPPETS<136,1> = 'INCLUDE'
   SNIPPETS<136,2> = 'Use the INCLUDE statement to direct the compiler to insert the source code in the record program and compile it along with the main program.'
   SNIPPETS<136,3,1> = "INCLUDE "
   SNIPPETS<137,1> = 'INDEX'
   SNIPPETS<137,2> = 'Use the INDEX function to return the starting character position for the specified occurrence of substring in string.'
   SNIPPETS<137,3,1> = "INDEX(H,N,1)"
   SNIPPETS<138,1> = 'INDEXS'
   SNIPPETS<138,2> = 'Use the INDEXS function to return a dynamic array of the starting column positions for a specified occurrence of a substring in each element of dynamic.'
   SNIPPETS<138,3,1> = "INDEXS(, , )"
   SNIPPETS<139,1> = 'INDICES'
   SNIPPETS<139,2> = 'Use the INDICES function to return information about the secondary key indexes in a file.'
   SNIPPETS<139,3,1> = "INDICES()"
   SNIPPETS<140,1> = 'INMAT'
   SNIPPETS<140,2> = 'Use the INMAT function to return the number of array elements that have been loaded after the execution of MATREAD statements, MATREADL statement, MATREADU statement, or MATPARSE statement, or to return the modulo of a file after the execution of an OPEN statement.'
   SNIPPETS<140,3,1> = "INMAT()"
   SNIPPETS<141,1> = 'INPUT'
   SNIPPETS<141,2> = 'Use the INPUT statement to halt program execution and prompt the user to enter a response.'
   SNIPPETS<141,3,1> = "INPUT "
   SNIPPETS<142,1> = 'INPUTCLEAR'
   SNIPPETS<142,2> = 'Use the INPUTCLEAR statement to clear the type-ahead buffer.'
   SNIPPETS<142,3,1> = "INPUTCLEAR"
   SNIPPETS<143,1> = 'INPUTDISP'
   SNIPPETS<143,2> = 'Use the INPUTDISP statement with an @ expression to position the cursor at a specified location and define a format for the variable to print.'
   SNIPPETS<143,3,1> = "INPUTDISP "
   SNIPPETS<144,1> = 'INPUTDP'
   SNIPPETS<144,2> = 'In NLS mode, use the INPUTDP statement to let the user enter data.'
   SNIPPETS<144,3,1> = "INPUTDP "
   SNIPPETS<145,1> = 'INPUTERR'
   SNIPPETS<145,2> = 'Use the INPUTERR statement to print a formatted error message on the bottom line of the terminal.'
   SNIPPETS<145,3,1> = "INPUTERR "
   SNIPPETS<146,1> = 'INPUTNULL'
   SNIPPETS<146,2> = 'Use the INPUTNULL statement to define a character to be recognized as an empty string when it is input in response to an INPUT statement.'
   SNIPPETS<146,3,1> = "INPUTNULL "
   SNIPPETS<147,1> = 'INPUTTRAP'
   SNIPPETS<147,2> = 'Use the INPUTTRAP statement to branch to a program label or subroutine when a trap character is input.'
   SNIPPETS<147,3,1> = "INPUTTRAP "
   SNIPPETS<148,1> = 'INS'
   SNIPPETS<148,2> = 'Use the INS statement to insert a new field, value, or subvalue into the specified dynamic.'
   SNIPPETS<148,3,1> = "INS BEFORE "
   SNIPPETS<149,1> = 'INSERT'
   SNIPPETS<149,2> = 'Use the INSERT function to return a dynamic array that has a new field, value, or subvalue inserted into the specified dynamic array.'
   SNIPPETS<149,3,1> = "INSERT(, , )"
   SNIPPETS<150,1> = 'INT'
   SNIPPETS<150,2> = 'Use the INT function to return the integer portion of an expression.'
   SNIPPETS<150,3,1> = "INT()"
   SNIPPETS<151,1> = 'ISNULL'
   SNIPPETS<151,2> = 'Use the ISNULL function to test whether a variable is the null value.'
   SNIPPETS<151,3,1> = "ISNULL()"
   SNIPPETS<152,1> = 'ISNULLS'
   SNIPPETS<152,2> = 'Use the ISNULLS function to test whether any element of dynamic.'
   SNIPPETS<152,3,1> = "ISNULLS()"
   SNIPPETS<153,1> = 'ITYPE'
   SNIPPETS<153,2> = 'The ITYPE function leverages the object code stored within a compiled i.'
   SNIPPETS<153,3,1> = "ITYPE()"
   SNIPPETS<154,1> = 'KEYEDIT'
   SNIPPETS<154,2> = 'Use the KEYEDIT statement to assign specific keyboard keys to the editing functions of the INPUT @ statement, and to the !EDIT.'
   SNIPPETS<154,3,1> = "KEYEDIT(, )"
   SNIPPETS<155,1> = 'KEYEXIT'
   SNIPPETS<155,2> = 'Use the KEYEXIT statement to specify exit traps for the keys assigned specific functions by the KEYEDIT statement.'
   SNIPPETS<155,3,1> = "KEYEXIT(,)"
   SNIPPETS<156,1> = 'KEYIN'
   SNIPPETS<156,2> = 'Use the KEYIN function to read a single character from the input buffer and return it.'
   SNIPPETS<156,3,1> = "KEYIN()"
   SNIPPETS<157,1> = 'KEYTRAP'
   SNIPPETS<157,2> = 'Use the KEYTRAP statement to specify traps for the keys assigned specific functions by the KEYEDIT statement.'
   SNIPPETS<157,3,1> = "KEYTRAP(,)"
   SNIPPETS<158,1> = 'LEFT'
   SNIPPETS<158,2> = 'Use the LEFT function to extract a substring comprising the first n characters of a string, without specifying the starting character position.'
   SNIPPETS<158,3,1> = "LEFT(,)"
   SNIPPETS<159,1> = 'LEN'
   SNIPPETS<159,2> = 'Use the LEN function to return the number of characters in string.'
   SNIPPETS<159,3,1> = "LEN()"
   SNIPPETS<160,1> = 'LENDP'
   SNIPPETS<160,2> = 'In NLS mode, use the LENDP function to return the number of display positions occupied by string when using the specified map.'
   SNIPPETS<160,3,1> = "LENDP()"
   SNIPPETS<161,1> = 'LENS'
   SNIPPETS<161,2> = 'Use the LENS function to return a dynamic array of the number of display positions in each element of dynamic.'
   SNIPPETS<161,3,1> = "LENS()"
   SNIPPETS<162,1> = 'LENSDP'
   SNIPPETS<162,2> = 'In NLS mode, use the LENSDP function to return a dynamic array of the number of display positions occupied by each element of dynamic.'
   SNIPPETS<162,3,1> = "LENSDP()"
   SNIPPETS<163,1> = 'LES'
   SNIPPETS<163,2> = 'Use the LES function to test if elements of one dynamic array are less than or equal to the elements of another dynamic array.'
   SNIPPETS<163,3,1> = "LES(,)"
   SNIPPETS<164,1> = 'LET'
   SNIPPETS<164,2> = 'Use the LET statement to assign the value of expression to variable.'
   SNIPPETS<164,3,1> = "LET"
   SNIPPETS<165,1> = 'LN'
   SNIPPETS<165,2> = 'Use the LN function to calculate the natural logarithm of the value of an expression, using base e.'
   SNIPPETS<165,3,1> = "LN()"
   SNIPPETS<166,1> = 'LOCATE'
   SNIPPETS<166,2> = 'Find in dynamic array'
   SNIPPETS<166,3,1> = "LOCATE(NEEDLE,HAYSTACK;ANYPOS) ELSE POS = 0"
   SNIPPETS<167,1> = 'LOCALEINFO'
   SNIPPETS<167,2> = 'In NLS mode, use the LOCALEINFO function to retrieve the settings of the current locale.'
   SNIPPETS<167,3,1> = "LOCALEINFO()"
   SNIPPETS<168,1> = 'LOCK'
   SNIPPETS<168,2> = 'Use the LOCK statement to protect specified user-defined resources or events against unauthorized use or simultaneous data file access by different users.'
   SNIPPETS<168,3,1> = "LOCK "
   SNIPPETS<169,1> = 'LOOP'
   SNIPPETS<169,2> = 'Use the LOOP statement to start a LOOPREPEAT program loop.'
   SNIPPETS<169,3,1> = "LOOP"
   SNIPPETS<169,3,2> = "READNEXT ITEM.ID ELSE ITEM.ID = ''"
   SNIPPETS<169,3,3> = "UNTIL ITEM.ID = '' DO"
   SNIPPETS<169,3,4> = "REPEAT"
   SNIPPETS<170,1> = 'LOWER'
   SNIPPETS<170,2> = 'Use the LOWER function to return a value equal to expression, except that system delimiters which appear in expression are converted to the next lower-level delimiter: field marks are changed to value marks, value marks are changed to subvalue marks, and so on.'
   SNIPPETS<170,3,1> = "LOWER()"
   SNIPPETS<171,1> = 'LTS'
   SNIPPETS<171,2> = 'Use the LTS function to test if elements of one dynamic array are less than elements of another dynamic array.'
   SNIPPETS<171,3,1> = "LTS(, )"
   SNIPPETS<172,1> = 'MAT'
   SNIPPETS<172,2> = 'Use the MAT statement to assign one value to all of the elements in the array or to assign all the values of one array to the values of another array.'
   SNIPPETS<172,3,1> = "MAT  = ''"
   SNIPPETS<173,1> = 'MATBUILD'
   SNIPPETS<173,2> = 'Use the MATBUILD statement to build a dynamic array from a dimensioned array.'
   SNIPPETS<173,3,1> = "MATBUILD FROM "
   SNIPPETS<174,1> = 'MATCHFIELD'
   SNIPPETS<174,2> = 'Use the MATCHFIELD function to check a string against a match pattern.'
   SNIPPETS<174,3,1> = "MATCHFIELD(, ,)"
   SNIPPETS<175,1> = 'MATPARSE'
   SNIPPETS<175,2> = 'Use the MATPARSE statement to separate the fields of dynamic.'
   SNIPPETS<175,3,1> = "MATPARSE FROM "
   SNIPPETS<176,1> = 'MATREAD'
   SNIPPETS<176,2> = 'Use the MATREAD statement to assign the contents of the fields of a record from a UniVerse file to consecutive elements of array.'
   SNIPPETS<176,3,1> = "MATREAD  FROM .FILE, .ID ELSE MAT  = ''"
   SNIPPETS<177,1> = 'MATWRITE'
   SNIPPETS<177,2> = 'Use the MATWRITE statement to write data from the elements of a dimensioned array to a record in a UniVerse file.'
   SNIPPETS<177,3,1> = "MATWRITE .ITEM ON .FILE,.ID"
   SNIPPETS<178,1> = 'MAXIMUM'
   SNIPPETS<178,2> = 'Use the MAXIMUM function to return the element with the highest numeric value in dynamic.'
   SNIPPETS<178,3,1> = "MAXIMUM()"
   SNIPPETS<179,1> = 'MINIMUM'
   SNIPPETS<179,2> = 'Use the MINIMUM function to return the element with the lowest numeric value in dynamic.'
   SNIPPETS<179,3,1> = "MINIMUM()"
   SNIPPETS<180,1> = 'MOD'
   SNIPPETS<180,2> = 'Use the MOD function to calculate the value of the remainder after integer division is performed on the dividend expression by the divisor expression.'
   SNIPPETS<180,3,1> = "MOD(, )"
   SNIPPETS<181,1> = 'MODS'
   SNIPPETS<181,2> = 'Use the MODS function to create a dynamic array of the remainder after the integer division of corresponding elements of two dynamic arrays.'
   SNIPPETS<181,3,1> = "MODS(, )"
   SNIPPETS<182,1> = 'MQCLOSE'
   SNIPPETS<182,2> = 'Use the MQCLOSE() function to close access to a queue or other object.'
   SNIPPETS<182,3,1> = "status=MQCLOSE(hConn, hObj, options)"
   SNIPPETS<183,1> = 'MQCONN'
   SNIPPETS<183,2> = 'The MQCONN() function connects an application to a WebSphere MQ queue manager.'
   SNIPPETS<183,3,1> = "status=MQCONN(qManager, hConn)"
   SNIPPETS<184,1> = 'MQDISC'
   SNIPPETS<184,2> = 'The MQDISC function terminates connections to the queue manager that were create using the MQCONN function.'
   SNIPPETS<184,3,1> = "status=MQDISC(hConn)"
   SNIPPETS<185,1> = 'MULS'
   SNIPPETS<185,2> = 'Use the MULS function to create a dynamic array of the element-by-element multiplication of two dynamic arrays.'
   SNIPPETS<185,3,1> = "MULS(,)"
   SNIPPETS<186,1> = 'NAP'
   SNIPPETS<186,2> = 'Use the NAP statement to suspend the execution of a BASIC program, pausing for a specified number of milliseconds.'
   SNIPPETS<186,3,1> = "NAP "
   SNIPPETS<187,1> = 'NEG'
   SNIPPETS<187,2> = 'Use the NEG function to return the arithmetic inverse of the value of the argument.'
   SNIPPETS<187,3,1> = "NEG()"
   SNIPPETS<188,1> = 'NEGS'
   SNIPPETS<188,2> = 'Use the NEGS function to return the negative values of all the elements in a dynamic array.'
   SNIPPETS<188,3,1> = "NEGS()"
   SNIPPETS<189,1> = 'NES'
   SNIPPETS<189,2> = 'Use the NES function to test if elements of one dynamic array are equal to the elements of another dynamic array.'
   SNIPPETS<189,3,1> = "NES(, )"
   SNIPPETS<190,1> = 'NEXT'
   SNIPPETS<190,2> = 'Use the NEXT statement to end a FORNEXT loop, causing the program to branch back to the FOR statement and execute the statements that follow it.'
   SNIPPETS<190,3,1> = "NEXT "
   SNIPPETS<191,1> = 'NOBUF'
   SNIPPETS<191,2> = 'Use the NOBUF statement to turn off buffering for a file previously opened for sequential processing.'
   SNIPPETS<191,3,1> = "NOBUF "
   SNIPPETS<192,1> = 'NOT'
   SNIPPETS<192,2> = 'Use the NOT function to return the logical complement of the value of expression.'
   SNIPPETS<192,3,1> = "NOT()"
   SNIPPETS<193,1> = 'NOTS'
   SNIPPETS<193,2> = 'Use the NOTS function to return a dynamic array of the logical complements of each element of dynamic.'
   SNIPPETS<193,3,1> = "NOTS()"
   SNIPPETS<194,1> = 'NULL'
   SNIPPETS<194,2> = 'Use the NULL statement when a statement is required but no operation is to be performed.'
   SNIPPETS<194,3,1> = "NULL"
   SNIPPETS<195,1> = 'NUM'
   SNIPPETS<195,2> = 'Use the NUM function to determine whether expression is a numeric or nonnumeric string.'
   SNIPPETS<195,3,1> = "NUM()"
   SNIPPETS<196,1> = 'NUMS'
   SNIPPETS<196,2> = 'Use the NUMS function to determine whether the elements of a dynamic array are numeric or nonnumeric strings.'
   SNIPPETS<196,3,1> = "NUMS()"
   SNIPPETS<197,1> = 'OCONV'
   SNIPPETS<197,2> = 'Use the OCONV function to convert string to a specified format for external output.'
   SNIPPETS<197,3,1> = "OCONV(, '')"
   SNIPPETS<198,1> = 'OCONVS'
   SNIPPETS<198,2> = 'Use the OCONVS function to convert the elements of dynamic.'
   SNIPPETS<198,3,1> = "OCONVS(, )"
   SNIPPETS<199,1> = 'ON'
   SNIPPETS<199,2> = 'Use the ON statement to transfer program control to one of the internal subroutines named in the GOSUB clause or to one of the statements named in the GOTO clause.'
   SNIPPETS<199,3,1> = "ON GOSUB "
   SNIPPETS<200,1> = 'OPEN'
   SNIPPETS<200,2> = 'Use the OPEN statement to open a UniVerse file for use by BASIC programs.'
   SNIPPETS<200,3,1> = "OPEN '','' TO .FILE ELSE"
   SNIPPETS<200,3,2> = "PRINT 'Unable to open file: -FILE - Press RETURN':"
   SNIPPETS<200,3,3> = "INPUT ANYTHING"
   SNIPPETS<200,3,4> = "STOP"
   SNIPPETS<200,3,5> = "END"
   SNIPPETS<201,1> = 'OPENCHECK'
   SNIPPETS<201,2> = 'Use the OPENCHECK statement to open an SQL table for use by BASIC programs, enforcing SQL integrity checking.'
   SNIPPETS<201,3,1> = "OPENCHECK "
   SNIPPETS<202,1> = 'OPENDEV'
   SNIPPETS<202,2> = 'Use the OPENDEV statement to open a device for sequential processing.'
   SNIPPETS<202,3,1> = "OPENDEV device TO file.variable [LOCKED statements] {THEN statements"
   SNIPPETS<203,1> = 'OPENPATH'
   SNIPPETS<203,2> = 'The OPENPATH statement is similar to the OPEN statement, except that the pathname of the file is specified.'
   SNIPPETS<203,3,1> = "OPENPATH pathname [TO file.variable] [ON ERROR statements] {THEN"
   SNIPPETS<204,1> = 'OPENSEQ'
   SNIPPETS<204,2> = 'Use the OPENSEQ statement to open a file for sequential processing.'
   SNIPPETS<204,3,1> = "PATH = '/home/export/'"
   SNIPPETS<204,3,2> = "FLAT.FILE.NAME = 'Something.csv'"
   SNIPPETS<204,3,3> = "*"
   SNIPPETS<204,3,4> = "FULL.PATH = PATH : FLAT.FILE.NAME"
   SNIPPETS<204,3,5> = "*"
   SNIPPETS<204,3,6> = "OPENSEQ FULL.PATH TO FLAT.FILE ELSE"
   SNIPPETS<204,3,7> = "CREATE FLAT.FILE ELSE"
   SNIPPETS<204,3,8> = "PRINT 'Unable to open/create ' : FULL.PATH :"
   SNIPPETS<204,3,9> = "INPUT ANYTHING :"
   SNIPPETS<204,3,10> = "STOP"
   SNIPPETS<204,3,11> = "END"
   SNIPPETS<204,3,12> = "END"
   SNIPPETS<204,3,13> = "*"
   SNIPPETS<204,3,14> = "WEOFSEQ FLAT.FILE"
   SNIPPETS<204,3,15> = "*"
   SNIPPETS<204,3,16> = "WRITESEQ BUFFER ON FLAT.FILE ELSE NULL"
   SNIPPETS<204,3,17> = "*"
   SNIPPETS<204,3,18> = "FLUSH FLAT.FILE ELSE NULL"
   SNIPPETS<204,3,19> = "CLOSESEQ FLAT.FILE"
   SNIPPETS<204,3,20> = "*"
   SNIPPETS<204,3,21> = "PRINT ERROR.POSITION : BELL : 'Exported to: ' : FULL.PATH : ' - Press RETURN' :"
   SNIPPETS<204,3,22> = "INPUT ANYTHING :"
   SNIPPETS<205,1> = 'ORS'
   SNIPPETS<205,2> = 'Use the ORS function to create a dynamic array of the logical OR of corresponding elements of two dynamic arrays.'
   SNIPPETS<205,3,1> = "ORS(, )"
   SNIPPETS<206,1> = 'PAGE'
   SNIPPETS<206,2> = 'Use the PAGE statement to print headings, footings, and page advances at the appropriate places on the specified output device.'
   SNIPPETS<206,3,1> = "PAGE "
   SNIPPETS<207,1> = 'PERFORM'
   SNIPPETS<207,2> = 'Use the PERFORM statement to execute a UniVerse sentence, paragraph, menu, or command from within the BASIC program, then return execution to the statement following the PERFORM statement.'
   SNIPPETS<207,3,1> = "PERFORM "
   SNIPPETS<208,1> = 'PRECISION'
   SNIPPETS<208,2> = 'Use the PRECISION statement to control the maximum number of decimal places that are output when the system converts a numeric value from internal binary format to an ASCII character string value.'
   SNIPPETS<208,3,1> = "PRECISION "
   SNIPPETS<209,1> = 'PRINT'
   SNIPPETS<209,2> = 'Use the PRINT statement to send data to the screen, a line printer, or another print file.'
   SNIPPETS<209,3,1> = "PRINT "
   SNIPPETS<210,1> = 'PRINTER'
   SNIPPETS<210,2> = 'Use the PRINTER statement to direct output either to the screen or to a printer.'
   SNIPPETS<210,3,1> = "PRINTER "
   SNIPPETS<211,1> = 'PRINTERR'
   SNIPPETS<211,2> = 'Use the PRINTERR statement to print a formatted error message on the bottom line of the terminal.'
   SNIPPETS<211,3,1> = "PRINTERR "
   SNIPPETS<212,1> = 'PROCREAD'
   SNIPPETS<212,2> = 'Use the PROCREAD statement to assign the contents of the primary input buffer to a variable.'
   SNIPPETS<212,3,1> = "PROCREAD  ELSE  = ''"
   SNIPPETS<213,1> = 'PROCWRITE'
   SNIPPETS<213,2> = 'Use the PROCWRITE statement to write string to the primary input buffer.'
   SNIPPETS<213,3,1> = "PROCWRITE "
   SNIPPETS<214,1> = 'PROGRAM'
   SNIPPETS<214,2> = 'Use the PROGRAM statement to identify a program.'
   SNIPPETS<214,3,1> = "PROGRAM "
   SNIPPETS<215,1> = 'PROMPT'
   SNIPPETS<215,2> = 'Use the PROMPT statement to specify the character to be displayed on the screen when user input is required.'
   SNIPPETS<215,3,1> = "PROMPT "
   SNIPPETS<216,1> = 'PWR'
   SNIPPETS<216,2> = 'Use the PWR function to return the value of expression raised to the power specified by power.'
   SNIPPETS<216,3,1> = "PWR(, )"
   SNIPPETS<217,1> = 'QUOTE'
   SNIPPETS<217,2> = 'Use the QUOTE function to enclose an expression in double quotation marks.'
   SNIPPETS<217,3,1> = "QUOTE()"
   SNIPPETS<218,1> = 'RAISE'
   SNIPPETS<218,2> = 'Use the RAISE function to return a value equal to expression, except that system delimiters in expression are converted to the next higher-level delimiter: value marks are changed to field marks, subvalue marks are changed to value marks, and so on.'
   SNIPPETS<218,3,1> = "RAISE()"
   SNIPPETS<219,1> = 'RANDOMIZE'
   SNIPPETS<219,2> = 'Use the RANDOMIZE statement with an expression to make the RND function generate the same sequence of random numbers each time the program is run.'
   SNIPPETS<219,3,1> = "RANDOMIZE "
   SNIPPETS<220,1> = 'READ'
   SNIPPETS<220,2> = 'Use READ statements to assign the contents of a record from a UniVerse file to dynamic.'
   SNIPPETS<220,3,1> = "READ  FROM , ITEM.ID ELSE = ''"
   SNIPPETS<221,1> = 'READBLK'
   SNIPPETS<221,2> = 'Use the READBLK statement to read a block of data of a specified length from a file opened for sequential processing and assign it to a variable.'
   SNIPPETS<221,3,1> = "READBLK XX FROM FLAT.FILE, 100000000 THEN"
   SNIPPETS<221,3,2> = "RELEASE FLAT.FILE"
   SNIPPETS<221,3,3> = "CLOSESEQ FLAT.FILE"
   SNIPPETS<221,3,4> = "END"
   SNIPPETS<222,1> = 'READLIST'
   SNIPPETS<222,2> = 'Use the READLIST statement to read the remainder of an active select list into a dynamic array.'
   SNIPPETS<222,3,1> = "READLIST FROM "
   SNIPPETS<223,1> = 'READNEXT'
   SNIPPETS<223,2> = 'Use the READNEXT statement to assign the next record ID from an active select list to dynamic.'
   SNIPPETS<223,3,1> = "READNEXT  ELSE  = ''"
   SNIPPETS<224,1> = 'READSEQ'
   SNIPPETS<224,2> = 'Use the READSEQ statement to read a line of data from a file opened for sequential processing.'
   SNIPPETS<224,3,1> = "READSEQ FROM "
   SNIPPETS<225,1> = 'READT'
   SNIPPETS<225,2> = 'Use the READT statement to read the next tape record from a magnetic tape unit and assign its contents to a variable.'
   SNIPPETS<225,3,1> = "READT "
   SNIPPETS<226,1> = 'READVU'
   SNIPPETS<226,2> = 'Use the READVU statement to set an update record lock and read the contents of a specified field of a record in a UniVerse file.'
   SNIPPETS<226,3,1> = "Status=ReadXMLData(xml_data_handle, rec)"
   SNIPPETS<227,1> = 'REAL'
   SNIPPETS<227,2> = 'Use the REAL function to convert number into a floating-point number without loss of accuracy.'
   SNIPPETS<227,3,1> = "REAL()"
   SNIPPETS<228,1> = 'RECORDLOCK'
   SNIPPETS<228,2> = 'Use RECORDLOCK statements to acquire a record lock on a record without reading the record.'
   SNIPPETS<228,3,1> = "RECORDLOCKL "
   SNIPPETS<229,1> = 'RECORDLOCKED'
   SNIPPETS<229,2> = 'Use the RECORDLOCKED function to return the status of a record lock.'
   SNIPPETS<229,3,1> = "RECORDLOCKED(, )"
   SNIPPETS<230,1> = 'RELEASE'
   SNIPPETS<230,2> = 'Use the RELEASE statement to unlock, or release, locks set by a FILELOCK statement, MATREADL statement, MATREADU statement, READL statement, READU statement, READVL statement, READVU statement, and OPENSEQ statement.'
   SNIPPETS<230,3,1> = "RELEASE "
   SNIPPETS<231,1> = 'REM'
   SNIPPETS<231,2> = 'Use the REM statement to insert a comment in a BASIC program.'
   SNIPPETS<231,3,1> = "REM "
   SNIPPETS<232,1> = 'REMOVE'
   SNIPPETS<232,2> = 'Use the REMOVE statement to successively extract dynamic array elements that are separated by system delimiters.'
   SNIPPETS<232,3,1> = "REMOVE FROM "
   SNIPPETS<233,1> = 'REPLACE'
   SNIPPETS<233,2> = 'Use the REPLACE function to return a copy of a dynamic array with the specified field, value, or subvalue replaced with new data.'
   SNIPPETS<233,3,1> = "REPLACE(, ,)"
   SNIPPETS<234,1> = 'RETURN'
   SNIPPETS<234,2> = 'Use the RETURN statement to terminate a subroutine and return control to the calling program or statement.'
   SNIPPETS<234,3,1> = "RETURN"
   SNIPPETS<235,1> = 'REUSE'
   SNIPPETS<235,2> = 'Use the REUSE function to specify that the value of the last field, value, or subvalue be reused in a dynamic array operation.'
   SNIPPETS<235,3,1> = "REUSE()"
   SNIPPETS<236,1> = 'REVREMOVE'
   SNIPPETS<236,2> = 'Use the REVREMOVE statement to successively extract dynamic array elements that are separated by system delimiters.'
   SNIPPETS<236,3,1> = "REVREMOVE FROM "
   SNIPPETS<237,1> = 'REWIND'
   SNIPPETS<237,2> = 'Use the REWIND statement to rewind a magnetic tape to the beginning-of-tape position.'
   SNIPPETS<237,3,1> = "REWIND "
   SNIPPETS<238,1> = 'RIGHT'
   SNIPPETS<238,2> = 'Use the RIGHT function to extract a substring comprising the last n characters of a string.'
   SNIPPETS<238,3,1> = "RIGHT(, )"
   SNIPPETS<239,1> = 'RND'
   SNIPPETS<239,2> = 'Use the RND function to generate any positive or negative random integer or 0.'
   SNIPPETS<239,3,1> = "RND()"
   SNIPPETS<240,1> = 'ROLLBACK'
   SNIPPETS<240,2> = 'Use the ROLLBACK statement to cancel all file I/O changes made during a transaction.'
   SNIPPETS<240,3,1> = "ROLLBACK "
   SNIPPETS<241,1> = 'ROUND'
   SNIPPETS<241,2> = 'Use the ROUND function to round a numeric value to the specified number of decimal places.'
   SNIPPETS<241,3,1> = "ROUND(,)"
   SNIPPETS<242,1> = 'SADD'
   SNIPPETS<242,2> = 'Use the SADD function to add two string numbers and return the result as a string number.'
   SNIPPETS<242,3,1> = "SADD(, )"
   SNIPPETS<243,1> = 'SCMP'
   SNIPPETS<243,2> = 'Use the SCMP function to compare two string numbers and return one of the following three numbers: can use this function in any expression where a string or string number is valid.'
   SNIPPETS<243,3,1> = "SCMP(,)"
   SNIPPETS<244,1> = 'SDIV'
   SNIPPETS<244,2> = 'Use the SDIV function to divide string.'
   SNIPPETS<244,3,1> = "SDIV(,)"
   SNIPPETS<245,1> = 'SEEK'
   SNIPPETS<245,2> = 'Use the SEEK statement to move the file pointer by an offset specified in bytes, relative to the current position, the beginning of the file, or the end of the file.'
   SNIPPETS<245,3,1> = "SEEK "
   SNIPPETS<246,1> = 'SELECT'
   SNIPPETS<246,2> = 'Use a SELECT statement to create a numbered select list of record IDs from a UniVerse file or a dynamic array.'
   SNIPPETS<246,3,1> = "SELECT "
   SNIPPETS<247,1> = 'SELECTE'
   SNIPPETS<247,2> = 'Use the SELECTE statement to assign the contents of select list 0 to list.'
   SNIPPETS<247,3,1> = "SELECTE TO "
   SNIPPETS<248,1> = 'SELECTINDEX'
   SNIPPETS<248,2> = 'Use the SELECTINDEX statement to create select lists from secondary indexes.'
   SNIPPETS<248,3,1> = "SELECTINDEX FROM "
   SNIPPETS<249,1> = 'SELECTINFO'
   SNIPPETS<249,2> = 'Use the SELECTINFO function to determine whether a select list is active, or to determine the number of items it contains.'
   SNIPPETS<249,3,1> = "SELECTINFO(, )"
   SNIPPETS<250,1> = 'SEND'
   SNIPPETS<250,2> = 'Use the SEND statement to write a block of data to a device.'
   SNIPPETS<250,3,1> = "SEND TO "
   SNIPPETS<251,1> = 'SENTENCE'
   SNIPPETS<251,2> = 'Use the SENTENCE function to return the stored sentence that invoked the current process.'
   SNIPPETS<251,3,1> = "SENTENCE()"
   SNIPPETS<252,1> = 'SEQ'
   SNIPPETS<252,2> = 'Use the SEQ function to convert an ASCII character to its numeric string equivalent.'
   SNIPPETS<252,3,1> = "SEQ()"
   SNIPPETS<253,1> = 'SEQS'
   SNIPPETS<253,2> = 'Use the SEQS function to convert a dynamic array of ASCII characters to their numeric string equivalents.'
   SNIPPETS<253,3,1> = "SEQS()"
   SNIPPETS<254,1> = 'SETLOCALE'
   SNIPPETS<254,2> = 'In NLS mode, use the SETLOCALE function to enable or disable a locale for a specified category or change its setting.'
   SNIPPETS<254,3,1> = "SETLOCALE(, )"
   SNIPPETS<255,1> = 'SETREM'
   SNIPPETS<255,2> = 'Use the SETREM statement to set the remove pointer in dynamic.'
   SNIPPETS<255,3,1> = "SETREM ON "
   SNIPPETS<256,1> = 'SIGNATURE'
   SNIPPETS<256,2> = 'The SIGNATURE() function generates a digital signature or verifies a signature using the supplied key.'
   SNIPPETS<256,3,1> = "SIGNATURE(, , , , , , , )"
   SNIPPETS<257,1> = 'SIN'
   SNIPPETS<257,2> = 'Use the SIN function to return the trigonometric sine of an expression.'
   SNIPPETS<257,3,1> = "SIN()"
   SNIPPETS<258,1> = 'SINH'
   SNIPPETS<258,2> = 'Use the SINH function to return the hyperbolic sine of expression.'
   SNIPPETS<258,3,1> = "SINH()"
   SNIPPETS<259,1> = 'SLEEP'
   SNIPPETS<259,2> = 'Use the SLEEP statement to suspend execution of a BASIC program, pausing for a specified number of seconds.'
   SNIPPETS<259,3,1> = "SLEEP "
   SNIPPETS<260,1> = 'SMUL'
   SNIPPETS<260,2> = 'Use the SMUL function to multiply two string numbers and return the result as a string number.'
   SNIPPETS<260,3,1> = "SMUL(, )"
   SNIPPETS<261,1> = 'SOUNDEX'
   SNIPPETS<261,2> = 'The SOUNDEX function evaluates expression and returns the most significant letter in the input string followed by a phonetic code.'
   SNIPPETS<261,3,1> = "SOUNDEX()"
   SNIPPETS<262,1> = 'SPACE'
   SNIPPETS<262,2> = 'Use the SPACE function to return a string composed of blank spaces.'
   SNIPPETS<262,3,1> = "SPACE()"
   SNIPPETS<263,1> = 'SPACES'
   SNIPPETS<263,2> = 'Use the SPACES function to return a dynamic array with elements composed of blank spaces.'
   SNIPPETS<263,3,1> = "SPACES()"
   SNIPPETS<264,1> = 'SPLICE'
   SNIPPETS<264,2> = 'Use the SPLICE function to create a dynamic array of the element-by-element concatenation of two dynamic arrays, separating concatenated elements by the value of expression.'
   SNIPPETS<264,3,1> = "SPLICE(, , )"
   SNIPPETS<265,1> = 'SQUOTE'
   SNIPPETS<265,2> = 'Use the SQUOTE function to enclose an expression in single quotation marks.'
   SNIPPETS<265,3,1> = "SQUOTE()"
   SNIPPETS<266,1> = 'SSELECT'
   SNIPPETS<266,2> = 'Use an SSELECT statement to create:   A numbered select list of record IDs in sorted order from a UniVerse file  A numbered select list of record IDs from a dynamic array.'
   SNIPPETS<266,3,1> = "SSELECT "
   SNIPPETS<267,1> = 'SSUB'
   SNIPPETS<267,2> = 'Use the SSUB function to subtract string.'
   SNIPPETS<267,3,1> = "SSUB(, )"
   SNIPPETS<268,1> = 'STATUS'
   SNIPPETS<268,2> = 'Use the STATUS statement to determine the status of an open file.'
   SNIPPETS<268,3,1> = "STATUS FROM"
   SNIPPETS<269,1> = 'STOP'
   SNIPPETS<269,2> = 'Use the STOP statement to terminate program execution and return system control to the invoking process.'
   SNIPPETS<269,3,1> = "STOP"
   SNIPPETS<270,1> = 'STORAGE'
   SNIPPETS<270,2> = 'The STORAGE statement performs no function.'
   SNIPPETS<270,3,1> = "STORAGE "
   SNIPPETS<271,1> = 'STR'
   SNIPPETS<271,2> = 'Use the STR function to produce a specified number of repetitions of a particular character string.'
   SNIPPETS<271,3,1> = "STR(, )"
   SNIPPETS<272,1> = 'STRS'
   SNIPPETS<272,2> = 'Use the STRS function to produce a dynamic array containing the specified number of repetitions of each element of dynamic.'
   SNIPPETS<272,3,1> = "STRS(, )"
   SNIPPETS<273,1> = 'SUBR'
   SNIPPETS<273,2> = 'Use the SUBR function to return the value of an external subroutine.'
   SNIPPETS<273,3,1> = "SUBR()"
   SNIPPETS<274,1> = 'SUBROUTINE'
   SNIPPETS<274,2> = 'Use the SUBROUTINE statement to identify an external subroutine.'
   SNIPPETS<274,3,1> = "SUBROUTINE ()"
   SNIPPETS<275,1> = 'SUBS'
   SNIPPETS<275,2> = 'Use the SUBS function to create a dynamic array of the element-by-element subtraction of two dynamic arrays.'
   SNIPPETS<275,3,1> = "SUBS(, )"
   SNIPPETS<276,1> = 'SUBSTRINGS'
   SNIPPETS<276,2> = 'Use the SUBSTRINGS function to create a dynamic array each of whose elements are substrings of the corresponding elements of dynamic.'
   SNIPPETS<276,3,1> = "SUBSTRINGS(, , )"
   SNIPPETS<277,1> = 'SUM'
   SNIPPETS<277,2> = 'Use the SUM function to calculate the sum of numeric data.'
   SNIPPETS<277,3,1> = "SUM()"
   SNIPPETS<278,1> = 'SUMMATION'
   SNIPPETS<278,2> = 'Use the SUMMATION function to return the sum of all the elements in dynamic.'
   SNIPPETS<278,3,1> = "SUMMATION()"
   SNIPPETS<279,1> = 'SWAP'
   SNIPPETS<279,2> = 'The SWAP statement interchanges the values in the variables you specify.'
   SNIPPETS<279,3,1> = "SWAP , "
   SNIPPETS<280,1> = 'SYSTEM'
   SNIPPETS<280,2> = 'Use the SYSTEM function to check on the status of a system function.'
   SNIPPETS<280,3,1> = "SYSTEM()"
   SNIPPETS<281,1> = 'TABSTOP'
   SNIPPETS<281,2> = 'Use the TABSTOP statement to set the current tabstop width for PRINT statement.'
   SNIPPETS<281,3,1> = "TABSTOP "
   SNIPPETS<282,1> = 'TAN'
   SNIPPETS<282,2> = 'Use the TAN function to return the trigonometric tangent of expression.'
   SNIPPETS<282,3,1> = "TAN()"
   SNIPPETS<283,1> = 'TANH'
   SNIPPETS<283,2> = 'Use the TANH function to return the hyperbolic tangent of expression.'
   SNIPPETS<283,3,1> = "TANH()"
   SNIPPETS<284,1> = 'TERMINFO'
   SNIPPETS<284,2> = 'Use the TERMINFO function to access the device-independent terminal handler string defined for the current terminal type.'
   SNIPPETS<284,3,1> = "TERMINFO()"
   SNIPPETS<285,1> = 'TIME'
   SNIPPETS<285,2> = 'Use the TIME function to return a string value expressing the internal time of day.'
   SNIPPETS<285,3,1> = "TIME()"
   SNIPPETS<286,1> = 'TIMEDATE'
   SNIPPETS<286,2> = 'Use the TIMEDATE function to return the current system time and date.'
   SNIPPETS<286,3,1> = "TIMEDATE()"
   SNIPPETS<287,1> = 'TIMEOUT'
   SNIPPETS<287,2> = 'Use the TIMEOUT statement to terminate a READSEQ statement or READBLK statement if no data is read in the specified time.'
   SNIPPETS<287,3,1> = "TIMEOUT "
   SNIPPETS<288,1> = 'TPARM'
   SNIPPETS<288,2> = 'Use the TPARM function to evaluate a parameterized terminfo string.'
   SNIPPETS<288,3,1> = "TPARM(,)"
   SNIPPETS<289,1> = 'TPRINT'
   SNIPPETS<289,2> = 'Use the TPRINT statement to send data to the screen, a line printer, or another print file.'
   SNIPPETS<289,3,1> = "TPRINT "
   SNIPPETS<290,1> = 'TRANS'
   SNIPPETS<290,2> = 'Use the TRANS function to return the contents of a field or a record in a UniVerse file.'
   SNIPPETS<290,3,1> = "TRANS()"
   SNIPPETS<291,1> = 'TRIM'
   SNIPPETS<291,2> = 'Use the TRIM function to remove unwanted characters in expression.'
   SNIPPETS<291,3,1> = "TRIM()"
   SNIPPETS<292,1> = 'TRIMB'
   SNIPPETS<292,2> = 'Use the TRIMB function to remove all trailing spaces and tabs from expression.'
   SNIPPETS<292,3,1> = "TRIMB()"
   SNIPPETS<293,1> = 'TRIMBS'
   SNIPPETS<293,2> = 'Use the TRIMBS function to remove all trailing spaces and tabs from each element of dynamic.'
   SNIPPETS<293,3,1> = "TRIMBS()"
   SNIPPETS<294,1> = 'TRIMF'
   SNIPPETS<294,2> = 'Use the TRIMF function to remove all leading spaces and tabs from expression.'
   SNIPPETS<294,3,1> = "TRIMF()"
   SNIPPETS<295,1> = 'TRIMFS'
   SNIPPETS<295,2> = 'Use the TRIMFS function to remove all leading spaces and tabs from each element of dynamic.'
   SNIPPETS<295,3,1> = "TRIMFS()"
   SNIPPETS<296,1> = 'TRIMS'
   SNIPPETS<296,2> = 'Use the TRIMS function to remove unwanted spaces and tabs from each element of dynamic.'
   SNIPPETS<296,3,1> = "TRIMS()"
   SNIPPETS<297,1> = 'TRUNC'
   SNIPPETS<297,2> = 'Use the TRUNC function to truncate a numeric variable or string to a specified number of decimal places.'
   SNIPPETS<297,3,1> = "TRUNC()"
   SNIPPETS<298,1> = 'TTYCTL'
   SNIPPETS<298,2> = 'Use the TTYCTL statement to set terminal device characteristics on Berkeley terminal drivers.'
   SNIPPETS<298,3,1> = "TTYCTL "
   SNIPPETS<299,1> = 'TTYGET'
   SNIPPETS<299,2> = 'Use the TTYGET statement to assign the characteristics of a terminal, line printer channel, or tape unit as a dynamic array to variable.'
   SNIPPETS<299,3,1> = "TTYGET "
   SNIPPETS<300,1> = 'TTYSET'
   SNIPPETS<300,2> = 'Use the TTYSET statement to set the characteristics of a terminal, line printer channel, or tape unit.'
   SNIPPETS<300,3,1> = "TTYSET "
   SNIPPETS<301,1> = 'UNASSIGNED'
   SNIPPETS<301,2> = 'Use the UNASSIGNED function to determine if variable is unassigned.'
   SNIPPETS<301,3,1> = "UNASSIGNED()"
   SNIPPETS<302,1> = 'UNICHAR'
   SNIPPETS<302,2> = 'Use the UNICHAR function to generate a single character from a Unicode value.'
   SNIPPETS<302,3,1> = "UNICHAR()"
   SNIPPETS<303,1> = 'UNICHARS'
   SNIPPETS<303,2> = 'Use the UNICHARS function to generate a dynamic array of characters from a dynamic array of Unicode values.'
   SNIPPETS<303,3,1> = "UNICHARS()"
   SNIPPETS<304,1> = 'UNISEQ'
   SNIPPETS<304,2> = 'Use the UNISEQ function to generate a Unicode value from expression.'
   SNIPPETS<304,3,1> = "UNISEQ()"
   SNIPPETS<305,1> = 'UNISEQS'
   SNIPPETS<305,2> = 'Use the UNISEQS function to generate an array of Unicode values from a dynamic array of characters.'
   SNIPPETS<305,3,1> = "UNISEQS()"
   SNIPPETS<306,1> = 'UNLOCK'
   SNIPPETS<306,2> = 'Use the UNLOCK statement to release a process lock set by the LOCK statement.'
   SNIPPETS<306,3,1> = "UNLOCK "
   SNIPPETS<307,1> = 'UPCASE'
   SNIPPETS<307,2> = 'Use the UPCASE function to change all lowercase letters in expression to uppercase.'
   SNIPPETS<307,3,1> = "UPCASE()"
   SNIPPETS<308,1> = 'UPRINT'
   SNIPPETS<308,2> = 'In NLS mode, use the UPRINT statement to print data that was mapped to an external format using OCONV mapname.'
   SNIPPETS<308,3,1> = "UPRINT "
   SNIPPETS<309,1> = 'USERINFO'
   SNIPPETS<309,2> = 'Use the USERINFO function to get the pid, user number, and more for the pid or user number specified.'
   SNIPPETS<309,3,1> = "USERINFO(, , )"
   SNIPPETS<310,1> = 'WEOF'
   SNIPPETS<310,2> = 'Use the WEOF statement to write an end-of-file (EOF) mark to tape.'
   SNIPPETS<310,3,1> = "WEOF "
   SNIPPETS<311,1> = 'WEOFSEQ'
   SNIPPETS<311,2> = 'Use the WEOFSEQ statement to write an end-of-file (EOF) mark in a file opened for sequential access.'
   SNIPPETS<311,3,1> = "WEOFSEQ"
   SNIPPETS<312,1> = 'WRITE'
   SNIPPETS<312,2> = 'Use WRITE statements to write new data to a record in a UniVerse file.'
   SNIPPETS<312,3,1> = "WRITE  ON .FILE, .ID"
   SNIPPETS<313,1> = 'WRITEBLK'
   SNIPPETS<313,2> = 'Use the WRITEBLK statement to write a block of data to a file opened for sequential processing.'
   SNIPPETS<313,3,1> = "WRITEBLK ON"
   SNIPPETS<314,1> = 'WRITELIST'
   SNIPPETS<314,2> = 'Use the WRITELIST statement to save a list as a record in the &SAVEDLISTS& file.'
   SNIPPETS<314,3,1> = "WRITELIST ON "
   SNIPPETS<315,1> = 'WRITESEQ'
   SNIPPETS<315,2> = 'Use the WRITESEQ statement to write new lines to a file opened for sequential processing.'
   SNIPPETS<315,3,1> = "WRITESEQ"
   SNIPPETS<316,1> = 'WRITESEQF'
   SNIPPETS<316,2> = 'Use the WRITESEQF statement to write new lines to a file opened for sequential processing, and to ensure that data is physically written to disk (that is, not buffered) before the next statement in the program is executed.'
   SNIPPETS<316,3,1> = "WRITESEQF"
   SNIPPETS<317,1> = 'WRITET'
   SNIPPETS<317,2> = 'Use the WRITET statement to write a tape record to tape.'
   SNIPPETS<317,3,1> = "WRITET"
   SNIPPETS<318,1> = 'WRITEVU'
   SNIPPETS<318,2> = 'Use the WRITEVU statement to maintain an update record lock while writing on the contents of a specified field of a record of a UniVerse file.'
   SNIPPETS<318,3,1> = "XDOMAddChild(, , ,,)"
   SNIPPETS<319,1> = 'XLATE'
   SNIPPETS<319,2> = 'Use the XLATE function to return the contents of a field or a record in a UniVerse file.'
   SNIPPETS<319,3,1> = "XLATE()"
   SNIPPETS<320,1> = 'XMLTODB'
   SNIPPETS<320,2> = 'You can also populate the UniVerse database by calling the UniVerse BASIC XMLTODB function.'
   SNIPPETS<320,3,1> = "XMLTODB()"
   SNIPPETS<321,1> = 'XTD'
   SNIPPETS<321,2> = 'Use the XTD function to convert a string of hexadecimal characters to an integer.'
   SNIPPETS<321,3,1> = "XTD()"
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
ADD.MARKDOWN.SNIPPETS:NULL
*
   SNIPPETS<1,1> = 'newpost'
   SNIPPETS<1,2> = 'YAML Frontmatter'
   SNIPPETS<1,3,1> = '---'
   SNIPPETS<1,3,2> = 'Title:'
   SNIPPETS<1,3,3> = 'Date: ' : OCONV(DATE(),'D-YMD[4,2,2]')
   SNIPPETS<1,3,4> = 'Sequence: 1'
   SNIPPETS<1,3,5> = 'Tags: []'
   SNIPPETS<1,3,6> = '---'
   SNIPPETS<1,3,7> = ''
*
   RETURN
*
* END OF PROGRAM
*
   END
*

